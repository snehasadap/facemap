(self.webpackChunkmy_facial_recognition_app=self.webpackChunkmy_facial_recognition_app||[]).push([[792],{563:(cm,Io,So)=>{"use strict";let Gn=null,Yv=1;const Bl=Symbol("SIGNAL");function st(e){const t=Gn;return Gn=e,t}const AO={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function MO(e){if((!pm(e)||e.dirty)&&(e.dirty||e.lastCleanEpoch!==Yv)){if(!e.producerMustRecompute(e)&&!Q1(e))return e.dirty=!1,void(e.lastCleanEpoch=Yv);e.producerRecomputeValue(e),e.dirty=!1,e.lastCleanEpoch=Yv}}function Y1(e){return e&&(e.nextProducerIndex=0),st(e)}function Q1(e){Jv(e);for(let t=0;t<e.producerNode.length;t++){const n=e.producerNode[t],r=e.producerLastReadVersion[t];if(r!==n.version||(MO(n),r!==n.version))return!0}return!1}function J1(e){if(Jv(e),pm(e))for(let t=0;t<e.producerNode.length;t++)Qv(e.producerNode[t],e.producerIndexOfThis[t]);e.producerNode.length=e.producerLastReadVersion.length=e.producerIndexOfThis.length=0,e.liveConsumerNode&&(e.liveConsumerNode.length=e.liveConsumerIndexOfThis.length=0)}function Qv(e,t){if(function LO(e){e.liveConsumerNode??=[],e.liveConsumerIndexOfThis??=[]}(e),1===e.liveConsumerNode.length&&function zO(e){return void 0!==e.producerNode}(e))for(let r=0;r<e.producerNode.length;r++)Qv(e.producerNode[r],e.producerIndexOfThis[r]);const n=e.liveConsumerNode.length-1;if(e.liveConsumerNode[t]=e.liveConsumerNode[n],e.liveConsumerIndexOfThis[t]=e.liveConsumerIndexOfThis[n],e.liveConsumerNode.length--,e.liveConsumerIndexOfThis.length--,t<e.liveConsumerNode.length){const r=e.liveConsumerIndexOfThis[t],a=e.liveConsumerNode[t];Jv(a),a.producerIndexOfThis[r]=t}}function pm(e){return e.consumerIsAlwaysLive||(e?.liveConsumerNode?.length??0)>0}function Jv(e){e.producerNode??=[],e.producerIndexOfThis??=[],e.producerLastReadVersion??=[]}let BO=null;function an(e){return"function"==typeof e}function eS(e){const n=e(r=>{Error.call(r),r.stack=(new Error).stack});return n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n}const tS=eS(e=>function(n){e(this),this.message=n?`${n.length} errors occurred during unsubscription:\n${n.map((r,a)=>`${a+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=n});function nS(e,t){if(e){const n=e.indexOf(t);0<=n&&e.splice(n,1)}}class Hr{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:n}=this;if(n)if(this._parentage=null,Array.isArray(n))for(const i of n)i.remove(this);else n.remove(this);const{initialTeardown:r}=this;if(an(r))try{r()}catch(i){t=i instanceof tS?i.errors:[i]}const{_finalizers:a}=this;if(a){this._finalizers=null;for(const i of a)try{HO(i)}catch(s){t=t??[],s instanceof tS?t=[...t,...s.errors]:t.push(s)}}if(t)throw new tS(t)}}add(t){var n;if(t&&t!==this)if(this.closed)HO(t);else{if(t instanceof Hr){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(n=this._finalizers)&&void 0!==n?n:[]).push(t)}}_hasParent(t){const{_parentage:n}=this;return n===t||Array.isArray(n)&&n.includes(t)}_addParent(t){const{_parentage:n}=this;this._parentage=Array.isArray(n)?(n.push(t),n):n?[n,t]:t}_removeParent(t){const{_parentage:n}=this;n===t?this._parentage=null:Array.isArray(n)&&nS(n,t)}remove(t){const{_finalizers:n}=this;n&&nS(n,t),t instanceof Hr&&t._removeParent(this)}}Hr.EMPTY=(()=>{const e=new Hr;return e.closed=!0,e})();const WO=Hr.EMPTY;function jO(e){return e instanceof Hr||e&&"closed"in e&&an(e.remove)&&an(e.add)&&an(e.unsubscribe)}function HO(e){an(e)?e():e.unsubscribe()}const Vl={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},tb={setTimeout(e,t,...n){const{delegate:r}=tb;return r?.setTimeout?r.setTimeout(e,t,...n):setTimeout(e,t,...n)},clearTimeout(e){const{delegate:t}=tb;return(t?.clearTimeout||clearTimeout)(e)},delegate:void 0};function GO(e){tb.setTimeout(()=>{const{onUnhandledError:t}=Vl;if(!t)throw e;t(e)})}function rS(){}const UQ=aS("C",void 0,void 0);function aS(e,t,n){return{kind:e,value:t,error:n}}let Ul=null;function nb(e){if(Vl.useDeprecatedSynchronousErrorHandling){const t=!Ul;if(t&&(Ul={errorThrown:!1,error:null}),e(),t){const{errorThrown:n,error:r}=Ul;if(Ul=null,n)throw r}}else e()}class iS extends Hr{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,jO(t)&&t.add(this)):this.destination=XQ}static create(t,n,r){return new oS(t,n,r)}next(t){this.isStopped?lS(function jQ(e){return aS("N",e,void 0)}(t),this):this._next(t)}error(t){this.isStopped?lS(function WQ(e){return aS("E",void 0,e)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?lS(UQ,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const GQ=Function.prototype.bind;function sS(e,t){return GQ.call(e,t)}class qQ{constructor(t){this.partialObserver=t}next(t){const{partialObserver:n}=this;if(n.next)try{n.next(t)}catch(r){rb(r)}}error(t){const{partialObserver:n}=this;if(n.error)try{n.error(t)}catch(r){rb(r)}else rb(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(n){rb(n)}}}class oS extends iS{constructor(t,n,r){let a;if(super(),an(t)||!t)a={next:t??void 0,error:n??void 0,complete:r??void 0};else{let i;this&&Vl.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),a={next:t.next&&sS(t.next,i),error:t.error&&sS(t.error,i),complete:t.complete&&sS(t.complete,i)}):a=t}this.destination=new qQ(a)}}function rb(e){Vl.useDeprecatedSynchronousErrorHandling?function HQ(e){Vl.useDeprecatedSynchronousErrorHandling&&Ul&&(Ul.errorThrown=!0,Ul.error=e)}(e):GO(e)}function lS(e,t){const{onStoppedNotification:n}=Vl;n&&tb.setTimeout(()=>n(e,t))}const XQ={closed:!0,next:rS,error:function KQ(e){throw e},complete:rS},uS="function"==typeof Symbol&&Symbol.observable||"@@observable";function Wl(e){return e}function qO(e){return 0===e.length?Wl:1===e.length?e[0]:function(n){return e.reduce((r,a)=>a(r),n)}}let yr=(()=>{class e{constructor(n){n&&(this._subscribe=n)}lift(n){const r=new e;return r.source=this,r.operator=n,r}subscribe(n,r,a){const i=function QQ(e){return e&&e instanceof iS||function YQ(e){return e&&an(e.next)&&an(e.error)&&an(e.complete)}(e)&&jO(e)}(n)?n:new oS(n,r,a);return nb(()=>{const{operator:s,source:o}=this;i.add(s?s.call(i,o):o?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(n){try{return this._subscribe(n)}catch(r){n.error(r)}}forEach(n,r){return new(r=KO(r))((a,i)=>{const s=new oS({next:o=>{try{n(o)}catch(l){i(l),s.unsubscribe()}},error:i,complete:a});this.subscribe(s)})}_subscribe(n){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(n)}[uS](){return this}pipe(...n){return qO(n)(this)}toPromise(n){return new(n=KO(n))((r,a)=>{let i;this.subscribe(s=>i=s,s=>a(s),()=>r(i))})}}return e.create=t=>new e(t),e})();function KO(e){var t;return null!==(t=e??Vl.Promise)&&void 0!==t?t:Promise}const JQ=eS(e=>function(){e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let si=(()=>{class e extends yr{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(n){const r=new XO(this,this);return r.operator=n,r}_throwIfClosed(){if(this.closed)throw new JQ}next(n){nb(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(n)}})}error(n){nb(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=n;const{observers:r}=this;for(;r.length;)r.shift().error(n)}})}complete(){nb(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:n}=this;for(;n.length;)n.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var n;return(null===(n=this.observers)||void 0===n?void 0:n.length)>0}_trySubscribe(n){return this._throwIfClosed(),super._trySubscribe(n)}_subscribe(n){return this._throwIfClosed(),this._checkFinalizedStatuses(n),this._innerSubscribe(n)}_innerSubscribe(n){const{hasError:r,isStopped:a,observers:i}=this;return r||a?WO:(this.currentObservers=null,i.push(n),new Hr(()=>{this.currentObservers=null,nS(i,n)}))}_checkFinalizedStatuses(n){const{hasError:r,thrownError:a,isStopped:i}=this;r?n.error(a):i&&n.complete()}asObservable(){const n=new yr;return n.source=this,n}}return e.create=(t,n)=>new XO(t,n),e})();class XO extends si{constructor(t,n){super(),this.destination=t,this.source=n}next(t){var n,r;null===(r=null===(n=this.destination)||void 0===n?void 0:n.next)||void 0===r||r.call(n,t)}error(t){var n,r;null===(r=null===(n=this.destination)||void 0===n?void 0:n.error)||void 0===r||r.call(n,t)}complete(){var t,n;null===(n=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===n||n.call(t)}_subscribe(t){var n,r;return null!==(r=null===(n=this.source)||void 0===n?void 0:n.subscribe(t))&&void 0!==r?r:WO}}class oi extends si{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const n=super._subscribe(t);return!n.closed&&t.next(this._value),n}getValue(){const{hasError:t,thrownError:n,_value:r}=this;if(t)throw n;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}function ZO(e){return an(e?.lift)}function vr(e){return t=>{if(ZO(t))return t.lift(function(n){try{return e(n,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function ur(e,t,n,r,a){return new eJ(e,t,n,r,a)}class eJ extends iS{constructor(t,n,r,a,i,s){super(t),this.onFinalize=i,this.shouldUnsubscribe=s,this._next=n?function(o){try{n(o)}catch(l){t.error(l)}}:super._next,this._error=a?function(o){try{a(o)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(o){t.error(o)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:n}=this;super.unsubscribe(),!n&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function $t(e,t){return vr((n,r)=>{let a=0;n.subscribe(ur(r,i=>{r.next(e.call(t,i,a++))}))})}typeof navigator<"u"&&navigator,typeof navigator<"u"&&!/Opera/.test(navigator.userAgent)&&navigator,typeof navigator<"u"&&(/MSIE/.test(navigator.userAgent)||navigator),typeof navigator<"u"&&!/Opera|WebKit/.test(navigator.userAgent)&&navigator,typeof navigator<"u"&&navigator;const m$="https://g.co/ng/security#xss";class ce extends Error{constructor(t,n){super(function $d(e,t){return`NG0${Math.abs(e)}${t?": "+t:""}`}(t,n)),this.code=t}}function Ps(e){return{toString:e}.toString()}const Ld="__parameters__";function Bd(e,t,n){return Ps(()=>{const r=function yS(e){return function(...n){if(e){const r=e(...n);for(const a in r)this[a]=r[a]}}}(t);function a(...i){if(this instanceof a)return r.apply(this,i),this;const s=new a(...i);return o.annotation=s,o;function o(l,u,c){const h=l.hasOwnProperty(Ld)?l[Ld]:Object.defineProperty(l,Ld,{value:[]})[Ld];for(;h.length<=c;)h.push(null);return(h[c]=h[c]||[]).push(s),l}}return n&&(a.prototype=Object.create(n.prototype)),a.prototype.ngMetadataName=e,a.annotationCls=a,a})}const sn=globalThis;function Pt(e){for(let t in e)if(e[t]===Pt)return t;throw Error("Could not find renamed property on target object.")}function qn(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(qn).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function vS(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const nee=Pt({__forward_ref__:Pt});function bS(e){return e.__forward_ref__=bS,e.toString=function(){return qn(this())},e}function Le(e){return lb(e)?e():e}function lb(e){return"function"==typeof e&&e.hasOwnProperty(nee)&&e.__forward_ref__===bS}function Ne(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function mm(e){return{providers:e.providers||[],imports:e.imports||[]}}function ub(e){return b$(e,db)||b$(e,w$)}function b$(e,t){return e.hasOwnProperty(t)?e[t]:null}function cb(e){return e&&(e.hasOwnProperty(wS)||e.hasOwnProperty(lee))?e[wS]:null}const db=Pt({\u0275prov:Pt}),wS=Pt({\u0275inj:Pt}),w$=Pt({ngInjectableDef:Pt}),lee=Pt({ngInjectorDef:Pt});class we{constructor(t,n){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof n?this.__NG_ELEMENT_ID__=n:void 0!==n&&(this.\u0275prov=Ne({token:this,providedIn:n.providedIn||"root",factory:n.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function CS(e){return e&&!!e.\u0275providers}const gm=Pt({\u0275cmp:Pt}),ES=Pt({\u0275dir:Pt}),kS=Pt({\u0275pipe:Pt}),I$=Pt({\u0275mod:Pt}),Ls=Pt({\u0275fac:Pt}),ym=Pt({__NG_ELEMENT_ID__:Pt}),S$=Pt({__NG_ENV_ID__:Pt});function Ge(e){return"string"==typeof e?e:null==e?"":String(e)}function NS(e,t){throw new ce(-201,!1)}var pt=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}(pt||{});let TS;function _$(){return TS}function fa(e){const t=TS;return TS=e,t}function C$(e,t,n){const r=ub(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:n&pt.Optional?null:void 0!==t?t:void NS()}const vm={},DS="__NG_DI_FLAG__",hb="ngTempTokenPath",fee=/\n/gm,E$="__source";let Vd;function Eo(e){const t=Vd;return Vd=e,t}function yee(e,t=pt.Default){if(void 0===Vd)throw new ce(-203,!1);return null===Vd?C$(e,void 0,t):Vd.get(e,t&pt.Optional?null:void 0,t)}function ze(e,t=pt.Default){return(_$()||yee)(Le(e),t)}function ie(e,t=pt.Default){return ze(e,pb(t))}function pb(e){return typeof e>"u"||"number"==typeof e?e:(e.optional&&8)|(e.host&&1)|(e.self&&2)|(e.skipSelf&&4)}function AS(e){const t=[];for(let n=0;n<e.length;n++){const r=Le(e[n]);if(Array.isArray(r)){if(0===r.length)throw new ce(900,!1);let a,i=pt.Default;for(let s=0;s<r.length;s++){const o=r[s],l=vee(o);"number"==typeof l?-1===l?a=o.token:i|=l:a=o}t.push(ze(a,i))}else t.push(ze(r))}return t}function bm(e,t){return e[DS]=t,e.prototype[DS]=t,e}function vee(e){return e[DS]}const fb=bm(Bd("Optional"),8),mb=bm(Bd("SkipSelf"),4);function Hl(e,t){return e.hasOwnProperty(Ls)?e[Ls]:null}function Ud(e,t){e.forEach(n=>Array.isArray(n)?Ud(n,t):t(n))}function N$(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function gb(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}const es={},xt=[],_i=new we(""),A$=new we("",-1),FS=new we("");class vb{get(t,n=vm){if(n===vm){const r=new Error(`NullInjectorError: No provider for ${qn(t)}!`);throw r.name="NullInjectorError",r}return n}}var bb=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}(bb||{}),Ci=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}(Ci||{}),ko=function(e){return e[e.None=0]="None",e[e.SignalBased=1]="SignalBased",e[e.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",e}(ko||{});function Cee(e,t,n){let r=e.length;for(;;){const a=e.indexOf(t,n);if(-1===a)return a;if(0===a||e.charCodeAt(a-1)<=32){const i=t.length;if(a+i===r||e.charCodeAt(a+i)<=32)return a}n=a+1}}function OS(e,t,n){let r=0;for(;r<n.length;){const a=n[r];if("number"==typeof a){if(0!==a)break;r++;const i=n[r++],s=n[r++],o=n[r++];e.setAttribute(t,s,o,i)}else{const i=a,s=n[++r];R$(i)?e.setProperty(t,i,s):e.setAttribute(t,i,s),r++}}return r}function M$(e){return 3===e||4===e||6===e}function R$(e){return 64===e.charCodeAt(0)}function wm(e,t){if(null!==t&&0!==t.length)if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){const a=t[r];"number"==typeof a?n=a:0===n||F$(e,n,a,null,-1===n||2===n?t[++r]:null)}}return e}function F$(e,t,n,r,a){let i=0,s=e.length;if(-1===t)s=-1;else for(;i<e.length;){const o=e[i++];if("number"==typeof o){if(o===t){s=-1;break}if(o>t){s=i-1;break}}}for(;i<e.length;){const o=e[i];if("number"==typeof o)break;if(o===n){if(null===r)return void(null!==a&&(e[i+1]=a));if(r===e[i+1])return void(e[i+2]=a)}i++,null!==r&&i++,null!==a&&i++}-1!==s&&(e.splice(s,0,t),i=s+1),e.splice(i++,0,n),null!==r&&e.splice(i++,0,r),null!==a&&e.splice(i++,0,a)}const O$="ng-template";function Eee(e,t,n,r){let a=0;if(r){for(;a<t.length&&"string"==typeof t[a];a+=2)if("class"===t[a]&&-1!==Cee(t[a+1].toLowerCase(),n,0))return!0}else if($S(e))return!1;if(a=t.indexOf(1,a),a>-1){let i;for(;++a<t.length&&"string"==typeof(i=t[a]);)if(i.toLowerCase()===n)return!0}return!1}function $S(e){return 4===e.type&&e.value!==O$}function kee(e,t,n){return t===(4!==e.type||n?e.value:O$)}function Nee(e,t,n){let r=4;const a=e.attrs,i=null!==a?function Aee(e){for(let t=0;t<e.length;t++)if(M$(e[t]))return t;return e.length}(a):0;let s=!1;for(let o=0;o<t.length;o++){const l=t[o];if("number"!=typeof l){if(!s)if(4&r){if(r=2|1&r,""!==l&&!kee(e,l,n)||""===l&&1===t.length){if(Ei(r))return!1;s=!0}}else if(8&r){if(null===a||!Eee(e,a,l,n)){if(Ei(r))return!1;s=!0}}else{const u=t[++o],c=Tee(l,a,$S(e),n);if(-1===c){if(Ei(r))return!1;s=!0;continue}if(""!==u){let h;if(h=c>i?"":a[c+1].toLowerCase(),2&r&&u!==h){if(Ei(r))return!1;s=!0}}}}else{if(!s&&!Ei(r)&&!Ei(l))return!1;if(s&&Ei(l))continue;s=!1,r=l|1&r}}return Ei(r)||s}function Ei(e){return!(1&e)}function Tee(e,t,n,r){if(null===t)return-1;let a=0;if(r||!n){let i=!1;for(;a<t.length;){const s=t[a];if(s===e)return a;if(3===s||6===s)i=!0;else{if(1===s||2===s){let o=t[++a];for(;"string"==typeof o;)o=t[++a];continue}if(4===s)break;if(0===s){a+=4;continue}}a+=i?1:2}return-1}return function Mee(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const r=e[n];if("number"==typeof r)return-1;if(r===t)return n;n++}return-1}(t,e)}function $$(e,t,n=!1){for(let r=0;r<t.length;r++)if(Nee(e,t[r],n))return!0;return!1}function P$(e,t){return e?":not("+t.trim()+")":t}function Fee(e){let t=e[0],n=1,r=2,a="",i=!1;for(;n<e.length;){let s=e[n];if("string"==typeof s)if(2&r){const o=e[++n];a+="["+s+(o.length>0?'="'+o+'"':"")+"]"}else 8&r?a+="."+s:4&r&&(a+=" "+s);else""!==a&&!Ei(s)&&(t+=P$(i,a),a=""),r=s,i=i||!Ei(r);n++}return""!==a&&(t+=P$(i,a)),t}function jd(e){return Ps(()=>{const t=z$(e),n={...t,decls:e.decls,vars:e.vars,template:e.template,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,onPush:e.changeDetection===bb.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&e.dependencies||null,getStandaloneInjector:null,signals:e.signals??!1,data:e.data||{},encapsulation:e.encapsulation||Ci.Emulated,styles:e.styles||xt,_:null,schemas:e.schemas||null,tView:null,id:""};B$(n);const r=e.dependencies;return n.directiveDefs=xb(r,!1),n.pipeDefs=xb(r,!0),n.id=function Bee(e){let t=0;const n=[e.selectors,e.ngContentSelectors,e.hostVars,e.hostAttrs,e.consts,e.vars,e.decls,e.encapsulation,e.standalone,e.signals,e.exportAs,JSON.stringify(e.inputs),JSON.stringify(e.outputs),Object.getOwnPropertyNames(e.type.prototype),!!e.contentQueries,!!e.viewQuery].join("|");for(const a of n)t=Math.imul(31,t)+a.charCodeAt(0)|0;return t+=2147483648,"c"+t}(n),n})}function Pee(e){return ut(e)||Kn(e)}function Lee(e){return null!==e}function wb(e){return Ps(()=>({type:e.type,bootstrap:e.bootstrap||xt,declarations:e.declarations||xt,imports:e.imports||xt,exports:e.exports||xt,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null}))}function L$(e,t){if(null==e)return es;const n={};for(const r in e)if(e.hasOwnProperty(r)){const a=e[r];let i,s,o=ko.None;Array.isArray(a)?(o=a[0],i=a[1],s=a[2]??i):(i=a,s=a),t?(n[i]=o!==ko.None?[r,o]:r,t[i]=s):n[i]=r}return n}function Gr(e){return Ps(()=>{const t=z$(e);return B$(t),t})}function ut(e){return e[gm]||null}function Kn(e){return e[ES]||null}function br(e){return e[kS]||null}function Nr(e,t){const n=e[I$]||null;if(!n&&!0===t)throw new Error(`Type ${qn(e)} does not have '\u0275mod' property.`);return n}function z$(e){const t={};return{type:e.type,providersResolver:null,factory:null,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputTransforms:null,inputConfig:e.inputs||es,exportAs:e.exportAs||null,standalone:!0===e.standalone,signals:!0===e.signals,selectors:e.selectors||xt,viewQuery:e.viewQuery||null,features:e.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:L$(e.inputs,t),outputs:L$(e.outputs),debugInfo:null}}function B$(e){e.features?.forEach(t=>t(e))}function xb(e,t){if(!e)return null;const n=t?br:Pee;return()=>("function"==typeof e?e():e).map(r=>n(r)).filter(Lee)}function Vee(...e){return{\u0275providers:PS(0,e),\u0275fromNgModule:!0}}function PS(e,...t){const n=[],r=new Set;let a;const i=s=>{n.push(s)};return Ud(t,s=>{const o=s;Ib(o,i,[],r)&&(a||=[],a.push(o))}),void 0!==a&&V$(a,i),n}function V$(e,t){for(let n=0;n<e.length;n++){const{ngModule:r,providers:a}=e[n];LS(a,i=>{t(i,r)})}}function Ib(e,t,n,r){if(!(e=Le(e)))return!1;let a=null,i=cb(e);const s=!i&&ut(e);if(i||s){if(s&&!s.standalone)return!1;a=e}else{const l=e.ngModule;if(i=cb(l),!i)return!1;a=l}const o=r.has(a);if(s){if(o)return!1;if(r.add(a),s.dependencies){const l="function"==typeof s.dependencies?s.dependencies():s.dependencies;for(const u of l)Ib(u,t,n,r)}}else{if(!i)return!1;{if(null!=i.imports&&!o){let u;r.add(a);try{Ud(i.imports,c=>{Ib(c,t,n,r)&&(u||=[],u.push(c))})}finally{}void 0!==u&&V$(u,t)}if(!o){const u=Hl(a)||(()=>new a);t({provide:a,useFactory:u,deps:xt},a),t({provide:FS,useValue:a,multi:!0},a),t({provide:_i,useValue:()=>ze(a),multi:!0},a)}const l=i.providers;if(null!=l&&!o){const u=e;LS(l,c=>{t(c,u)})}}}return a!==e&&void 0!==e.providers}function LS(e,t){for(let n of e)CS(n)&&(n=n.\u0275providers),Array.isArray(n)?LS(n,t):t(n)}const Uee=Pt({provide:String,useValue:Pt});function zS(e){return null!==e&&"object"==typeof e&&Uee in e}function Gl(e){return"function"==typeof e}const BS=new we(""),Sb={},jee={};let VS;function _b(){return void 0===VS&&(VS=new vb),VS}class ya{}class Hd extends ya{get destroyed(){return this._destroyed}constructor(t,n,r,a){super(),this.parent=n,this.source=r,this.scopes=a,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,WS(t,s=>this.processProvider(s)),this.records.set(A$,Gd(void 0,this)),a.has("environment")&&this.records.set(ya,Gd(void 0,this));const i=this.records.get(BS);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(FS,xt,pt.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;const t=st(null);try{for(const r of this._ngOnDestroyHooks)r.ngOnDestroy();const n=this._onDestroyHooks;this._onDestroyHooks=[];for(const r of n)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),st(t)}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();const n=Eo(this),r=fa(void 0);try{return t()}finally{Eo(n),fa(r)}}get(t,n=vm,r=pt.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(S$))return t[S$](this);r=pb(r);const i=Eo(this),s=fa(void 0);try{if(!(r&pt.SkipSelf)){let l=this.records.get(t);if(void 0===l){const u=function Xee(e){return"function"==typeof e||"object"==typeof e&&e instanceof we}(t)&&ub(t);l=u&&this.injectableDefInScope(u)?Gd(US(t),Sb):null,this.records.set(t,l)}if(null!=l)return this.hydrate(t,l)}return(r&pt.Self?_b():this.parent).get(t,n=r&pt.Optional&&n===vm?null:n)}catch(o){if("NullInjectorError"===o.name){if((o[hb]=o[hb]||[]).unshift(qn(t)),i)throw o;return function bee(e,t,n,r){const a=e[hb];throw t[E$]&&a.unshift(t[E$]),e.message=function wee(e,t,n,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.slice(2):e;let a=qn(t);if(Array.isArray(t))a=t.map(qn).join(" -> ");else if("object"==typeof t){let i=[];for(let s in t)if(t.hasOwnProperty(s)){let o=t[s];i.push(s+":"+("string"==typeof o?JSON.stringify(o):qn(o)))}a=`{${i.join(", ")}}`}return`${n}${r?"("+r+")":""}[${a}]: ${e.replace(fee,"\n  ")}`}("\n"+e.message,a,n,r),e.ngTokenPath=a,e[hb]=null,e}(o,t,"R3InjectorError",this.source)}throw o}finally{fa(s),Eo(i)}}resolveInjectorInitializers(){const t=st(null),n=Eo(this),r=fa(void 0);try{const i=this.get(_i,xt,pt.Self);for(const s of i)s()}finally{Eo(n),fa(r),st(t)}}toString(){const t=[],n=this.records;for(const r of n.keys())t.push(qn(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new ce(205,!1)}processProvider(t){let n=Gl(t=Le(t))?t:Le(t&&t.provide);const r=function Gee(e){return zS(e)?Gd(void 0,e.useValue):Gd(function j$(e,t,n){let r;if(Gl(e)){const a=Le(e);return Hl(a)||US(a)}if(zS(e))r=()=>Le(e.useValue);else if(function W$(e){return!(!e||!e.useFactory)}(e))r=()=>e.useFactory(...AS(e.deps||[]));else if(function U$(e){return!(!e||!e.useExisting)}(e))r=()=>ze(Le(e.useExisting));else{const a=Le(e&&(e.useClass||e.provide));if(!function qee(e){return!!e.deps}(e))return Hl(a)||US(a);r=()=>new a(...AS(e.deps))}return r}(e),Sb)}(t);if(!Gl(t)&&!0===t.multi){let a=this.records.get(n);a||(a=Gd(void 0,Sb,!0),a.factory=()=>AS(a.multi),this.records.set(n,a)),n=t,a.multi.push(t)}this.records.set(n,r)}hydrate(t,n){const r=st(null);try{return n.value===Sb&&(n.value=jee,n.value=n.factory()),"object"==typeof n.value&&n.value&&function Kee(e){return null!==e&&"object"==typeof e&&"function"==typeof e.ngOnDestroy}(n.value)&&this._ngOnDestroyHooks.add(n.value),n.value}finally{st(r)}}injectableDefInScope(t){if(!t.providedIn)return!1;const n=Le(t.providedIn);return"string"==typeof n?"any"===n||this.scopes.has(n):this.injectorDefTypes.has(n)}removeOnDestroy(t){const n=this._onDestroyHooks.indexOf(t);-1!==n&&this._onDestroyHooks.splice(n,1)}}function US(e){const t=ub(e),n=null!==t?t.factory:Hl(e);if(null!==n)return n;if(e instanceof we)throw new ce(204,!1);if(e instanceof Function)return function Hee(e){if(e.length>0)throw new ce(204,!1);const n=function oee(e){return e&&(e[db]||e[w$])||null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new ce(204,!1)}function Gd(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function WS(e,t){for(const n of e)Array.isArray(n)?WS(n,t):n&&CS(n)?WS(n.\u0275providers,t):t(n)}function ts(e,t){e instanceof Hd&&e.assertNotDestroyed();const r=Eo(e),a=fa(void 0);try{return t()}finally{Eo(r),fa(a)}}function H$(){return void 0!==_$()||null!=function gee(){return Vd}()}const dn=0,he=1,Ae=2,On=3,ki=4,wr=5,qr=6,Kd=7,en=8,$n=9,ns=10,Be=11,Sm=12,q$=13,Xd=14,hn=15,ql=16,Zd=17,zs=18,Yd=19,K$=20,To=21,kb=22,li=23,Ee=25,HS=1,rs=7,Qd=9,xn=10;var Tb=function(e){return e[e.None=0]="None",e[e.HasTransplantedViews=2]="HasTransplantedViews",e}(Tb||{});function cr(e){return Array.isArray(e)&&"object"==typeof e[HS]}function Tr(e){return Array.isArray(e)&&!0===e[HS]}function GS(e){return!!(4&e.flags)}function Kl(e){return e.componentOffset>-1}function Db(e){return!(1&~e.flags)}function Ni(e){return!!e.template}function Cm(e){return!!(512&e[Ae])}class lte{constructor(t,n,r){this.previousValue=t,this.currentValue=n,this.firstChange=r}isFirstChange(){return this.firstChange}}function Q$(e,t,n,r){null!==t?t.applyValueToInputSignal(t,r):e[n]=r}function Xl(){return J$}function J$(e){return e.type.prototype.ngOnChanges&&(e.setInput=cte),ute}function ute(){const e=tP(this),t=e?.current;if(t){const n=e.previous;if(n===es)e.previous=t;else for(let r in t)n[r]=t[r];e.current=null,this.ngOnChanges(t)}}function cte(e,t,n,r,a){const i=this.declaredInputs[r],s=tP(e)||function dte(e,t){return e[eP]=t}(e,{previous:es,current:null}),o=s.current||(s.current={}),l=s.previous,u=l[i];o[i]=new lte(u&&u.currentValue,n,l===es),Q$(e,t,a,n)}Xl.ngInherit=!0;const eP="__ngSimpleChanges__";function tP(e){return e[eP]||null}const as=function(e,t,n){},nP="svg";function It(e){for(;Array.isArray(e);)e=e[dn];return e}function Kr(e,t){return It(t[e.index])}function km(e,t){return e.data[t]}function Ba(e,t){const n=t[e];return cr(n)?n:n[dn]}function YS(e){return!(128&~e[Ae])}function ui(e,t){return null==t?null:e[t]}function aP(e){e[Zd]=0}function iP(e){1024&e[Ae]||(e[Ae]|=1024,YS(e)&&Ab(e))}function Nm(e){return!!(9216&e[Ae]||e[li]?.dirty)}function QS(e){e[ns].changeDetectionScheduler?.notify(7),64&e[Ae]&&(e[Ae]|=1024),Nm(e)&&Ab(e)}function Ab(e){e[ns].changeDetectionScheduler?.notify(0);let t=Bs(e);for(;null!==t&&!(8192&t[Ae])&&(t[Ae]|=8192,YS(t));)t=Bs(t)}function Mb(e,t){if(!(256&~e[Ae]))throw new ce(911,!1);null===e[To]&&(e[To]=[]),e[To].push(t)}function Bs(e){const t=e[On];return Tr(t)?t[On]:t}const Ve={lFrame:wP(null),bindingsEnabled:!0,skipHydrationRootTNode:null};let oP=!1;function lP(){return Ve.bindingsEnabled}function ne(){return Ve.lFrame.lView}function ot(){return Ve.lFrame.tView}function Lt(){let e=dP();for(;null!==e&&64===e.type;)e=e.parent;return e}function dP(){return Ve.lFrame.currentTNode}function Ti(e,t){const n=Ve.lFrame;n.currentTNode=e,n.isParent=t}function t_(){return Ve.lFrame.isParent}function fP(){return oP}function mP(e){oP=e}function Di(){return Ve.lFrame.bindingIndex++}function Cte(e,t){const n=Ve.lFrame;n.bindingIndex=n.bindingRootIndex=e,r_(t)}function r_(e){Ve.lFrame.currentDirectiveIndex=e}function i_(){return Ve.lFrame.currentQueryIndex}function Fb(e){Ve.lFrame.currentQueryIndex=e}function kte(e){const t=e[he];return 2===t.type?t.declTNode:1===t.type?e[wr]:null}function vP(e,t,n){if(n&pt.SkipSelf){let a=t,i=e;for(;!(a=a.parent,null!==a||n&pt.Host||(a=kte(i),null===a||(i=i[Xd],10&a.type))););if(null===a)return!1;t=a,e=i}const r=Ve.lFrame=bP();return r.currentTNode=t,r.lView=e,!0}function s_(e){const t=bP(),n=e[he];Ve.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function bP(){const e=Ve.lFrame,t=null===e?null:e.child;return null===t?wP(e):t}function wP(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function xP(){const e=Ve.lFrame;return Ve.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const IP=xP;function o_(){const e=xP();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function xr(){return Ve.lFrame.selectedIndex}function Ql(e){Ve.lFrame.selectedIndex=e}function tn(){const e=Ve.lFrame;return km(e.tView,e.selectedIndex)}function l_(){Ve.lFrame.currentNamespace=nP}let _P=!0;function Dm(){return _P}function is(e){_P=e}function Ob(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){const i=e.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:o,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=i;s&&(e.contentHooks??=[]).push(-n,s),o&&((e.contentHooks??=[]).push(n,o),(e.contentCheckHooks??=[]).push(n,o)),l&&(e.viewHooks??=[]).push(-n,l),u&&((e.viewHooks??=[]).push(n,u),(e.viewCheckHooks??=[]).push(n,u)),null!=c&&(e.destroyHooks??=[]).push(n,c)}}function $b(e,t,n){CP(e,t,3,n)}function Pb(e,t,n,r){(3&e[Ae])===n&&CP(e,t,n,r)}function u_(e,t){let n=e[Ae];(3&n)===t&&(n&=16383,n+=1,e[Ae]=n)}function CP(e,t,n,r){const i=r??-1,s=t.length-1;let o=0;for(let l=void 0!==r?65535&e[Zd]:0;l<s;l++)if("number"==typeof t[l+1]){if(o=t[l],null!=r&&o>=r)break}else t[l]<0&&(e[Zd]+=65536),(o<i||-1==i)&&(Rte(e,n,t,l),e[Zd]=(4294901760&e[Zd])+l+2),l++}function EP(e,t){as(4,e,t);const n=st(null);try{t.call(e)}finally{st(n),as(5,e,t)}}function Rte(e,t,n,r){const a=n[r]<0,i=n[r+1],o=e[a?-n[r]:n[r]];a?e[Ae]>>14<e[Zd]>>16&&(3&e[Ae])===t&&(e[Ae]+=16384,EP(o,i)):EP(o,i)}const Jd=-1;class Am{constructor(t,n,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=n,this.injectImpl=r}}const d_={};class Jl{constructor(t,n){this.injector=t,this.parentInjector=n}get(t,n,r){r=pb(r);const a=this.injector.get(t,d_,r);return a!==d_||n===d_?a:this.parentInjector.get(t,n,r)}}function h_(e){return e!==Jd}function Mm(e){return 32767&e}function Rm(e,t){let n=function Pte(e){return e>>16}(e),r=t;for(;n>0;)r=r[Xd],n--;return r}let p_=!0;function Lb(e){const t=p_;return p_=e,t}const NP=255,TP=5;let zte=0;const ss={};function zb(e,t){const n=DP(e,t);if(-1!==n)return n;const r=t[he];r.firstCreatePass&&(e.injectorIndex=t.length,f_(r.data,e),f_(t,null),f_(r.blueprint,null));const a=Bb(e,t),i=e.injectorIndex;if(h_(a)){const s=Mm(a),o=Rm(a,t),l=o[he].data;for(let u=0;u<8;u++)t[i+u]=o[s+u]|l[s+u]}return t[i+8]=a,i}function f_(e,t){e.push(0,0,0,0,0,0,0,0,t)}function DP(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function Bb(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,r=null,a=t;for(;null!==a;){if(r=PP(a),null===r)return Jd;if(n++,a=a[Xd],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return Jd}function m_(e,t,n){!function Bte(e,t,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(ym)&&(r=n[ym]),null==r&&(r=n[ym]=zte++);const a=r&NP;t.data[e+(a>>TP)]|=1<<a}(e,t,n)}function AP(e,t,n){if(n&pt.Optional||void 0!==e)return e;NS()}function MP(e,t,n,r){if(n&pt.Optional&&void 0===r&&(r=null),!(n&(pt.Self|pt.Host))){const a=e[$n],i=fa(void 0);try{return a?a.get(t,r,n&pt.Optional):C$(t,r,n&pt.Optional)}finally{fa(i)}}return AP(r,0,n)}function RP(e,t,n,r=pt.Default,a){if(null!==e){if(2048&t[Ae]&&!(r&pt.Self)){const s=function Hte(e,t,n,r,a){let i=e,s=t;for(;null!==i&&null!==s&&2048&s[Ae]&&!(512&s[Ae]);){const o=FP(i,s,n,r|pt.Self,ss);if(o!==ss)return o;let l=i.parent;if(!l){const u=s[K$];if(u){const c=u.get(n,ss,r);if(c!==ss)return c}l=PP(s),s=s[Xd]}i=l}return a}(e,t,n,r,ss);if(s!==ss)return s}const i=FP(e,t,n,r,ss);if(i!==ss)return i}return MP(t,n,r,a)}function FP(e,t,n,r,a){const i=function Wte(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(ym)?e[ym]:void 0;return"number"==typeof t?t>=0?t&NP:jte:t}(n);if("function"==typeof i){if(!vP(t,e,r))return r&pt.Host?AP(a,0,r):MP(t,n,r,a);try{let s;if(s=i(r),null!=s||r&pt.Optional)return s;NS()}finally{IP()}}else if("number"==typeof i){let s=null,o=DP(e,t),l=Jd,u=r&pt.Host?t[hn][wr]:null;for((-1===o||r&pt.SkipSelf)&&(l=-1===o?Bb(e,t):t[o+8],l!==Jd&&$P(r,!1)?(s=t[he],o=Mm(l),t=Rm(l,t)):o=-1);-1!==o;){const c=t[he];if(OP(i,o,c.data)){const h=Ute(o,t,n,s,r,u);if(h!==ss)return h}l=t[o+8],l!==Jd&&$P(r,t[he].data[o+8]===u)&&OP(i,o,t)?(s=c,o=Mm(l),t=Rm(l,t)):o=-1}}return a}function Ute(e,t,n,r,a,i){const s=t[he],o=s.data[e+8],c=Vb(o,s,n,null==r?Kl(o)&&p_:r!=s&&!!(3&o.type),a&pt.Host&&i===o);return null!==c?eu(t,s,c,o):ss}function Vb(e,t,n,r,a){const i=e.providerIndexes,s=t.data,o=1048575&i,l=e.directiveStart,c=i>>20,d=a?o+c:e.directiveEnd;for(let p=r?o:o+c;p<d;p++){const f=s[p];if(p<l&&n===f||p>=l&&f.type===n)return p}if(a){const p=s[l];if(p&&Ni(p)&&p.type===n)return l}return null}function eu(e,t,n,r){let a=e[n];const i=t.data;if(function Fte(e){return e instanceof Am}(a)){const s=a;s.resolving&&function dee(e,t){throw t&&t.join(" > "),new ce(-200,e)}(function Ct(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():Ge(e)}(i[n]));const o=Lb(s.canSeeViewProviders);s.resolving=!0;const u=s.injectImpl?fa(s.injectImpl):null;vP(e,r,pt.Default);try{a=e[n]=s.factory(void 0,i,e,r),t.firstCreatePass&&n>=r.directiveStart&&function Mte(e,t,n){const{ngOnChanges:r,ngOnInit:a,ngDoCheck:i}=t.type.prototype;if(r){const s=J$(t);(n.preOrderHooks??=[]).push(e,s),(n.preOrderCheckHooks??=[]).push(e,s)}a&&(n.preOrderHooks??=[]).push(0-e,a),i&&((n.preOrderHooks??=[]).push(e,i),(n.preOrderCheckHooks??=[]).push(e,i))}(n,i[n],t)}finally{null!==u&&fa(u),Lb(o),s.resolving=!1,IP()}}return a}function OP(e,t,n){return!!(n[t+(e>>TP)]&1<<e)}function $P(e,t){return!(e&pt.Self||e&pt.Host&&t)}class Zn{constructor(t,n){this._tNode=t,this._lView=n}get(t,n,r){return RP(this._tNode,this._lView,t,pb(r),n)}}function jte(){return new Zn(Lt(),ne())}function g_(e){return Ps(()=>{const t=e.prototype.constructor,n=t[Ls]||y_(t),r=Object.prototype;let a=Object.getPrototypeOf(e.prototype).constructor;for(;a&&a!==r;){const i=a[Ls]||y_(a);if(i&&i!==n)return i;a=Object.getPrototypeOf(a)}return i=>new i})}function y_(e){return lb(e)?()=>{const t=y_(Le(e));return t&&t()}:Hl(e)}function PP(e){const t=e[he],n=t.type;return 2===n?t.declTNode:1===n?e[wr]:null}function UP(e,t=null,n=null,r){const a=WP(e,t,n,r);return a.resolveInjectorInitializers(),a}function WP(e,t=null,n=null,r,a=new Set){const i=[n||xt,Vee(e)];return r=r||("object"==typeof e?void 0:qn(e)),new Hd(i,t||_b(),r||null,a)}class Pn{static#e=this.THROW_IF_NOT_FOUND=vm;static#t=this.NULL=new vb;static create(t,n){if(Array.isArray(t))return UP({name:""},n,t,"");{const r=t.name??"";return UP({name:r},t.parent,t.providers,r)}}static#n=this.\u0275prov=Ne({token:Pn,providedIn:"any",factory:()=>ze(A$)});static#r=this.__NG_ELEMENT_ID__=-1}new we("").__NG_ELEMENT_ID__=e=>{const t=Lt();if(null===t)throw new ce(204,!1);if(2&t.type)return t.value;if(e&pt.Optional)return null;throw new ce(204,!1)};function b_(e){return e.ngOriginalError}let Om=(()=>{class e{static#e=this.__NG_ELEMENT_ID__=tne;static#t=this.__NG_ENV_ID__=n=>n}return e})();class ene extends Om{constructor(t){super(),this._lView=t}onDestroy(t){return Mb(this._lView,t),()=>function JS(e,t){if(null===e[To])return;const n=e[To].indexOf(t);-1!==n&&e[To].splice(n,1)}(this._lView,t)}}function tne(){return new ene(ne())}let tu=(()=>{class e{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new oi(!1)}get _hasPendingTasks(){return this.hasPendingTasks.value}add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);const n=this.taskId++;return this.pendingTasks.add(n),n}remove(n){this.pendingTasks.delete(n),0===this.pendingTasks.size&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}static#e=this.\u0275prov=Ne({token:e,providedIn:"root",factory:()=>new e})}return e})();const Zr=class nne extends si{constructor(t=!1){super(),this.destroyRef=void 0,this.pendingTasks=void 0,this.__isAsync=t,H$()&&(this.destroyRef=ie(Om,{optional:!0})??void 0,this.pendingTasks=ie(tu,{optional:!0})??void 0)}emit(t){const n=st(null);try{super.next(t)}finally{st(n)}}subscribe(t,n,r){let a=t,i=n||(()=>null),s=r;if(t&&"object"==typeof t){const l=t;a=l.next?.bind(l),i=l.error?.bind(l),s=l.complete?.bind(l)}this.__isAsync&&(i=this.wrapInTimeout(i),a&&(a=this.wrapInTimeout(a)),s&&(s=this.wrapInTimeout(s)));const o=super.subscribe({next:a,error:i,complete:s});return t instanceof Hr&&t.add(o),o}wrapInTimeout(t){return n=>{const r=this.pendingTasks?.add();setTimeout(()=>{t(n),void 0!==r&&this.pendingTasks?.remove(r)})}}};function Wb(...e){}function HP(e){let t,n;function r(){e=Wb;try{void 0!==n&&"function"==typeof cancelAnimationFrame&&cancelAnimationFrame(n),void 0!==t&&clearTimeout(t)}catch{}}return t=setTimeout(()=>{e(),r()}),"function"==typeof requestAnimationFrame&&(n=requestAnimationFrame(()=>{e(),r()})),()=>r()}function GP(e){return queueMicrotask(()=>e()),()=>{e=Wb}}class Et{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:n=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Zr(!1),this.onMicrotaskEmpty=new Zr(!1),this.onStable=new Zr(!1),this.onError=new Zr(!1),typeof Zone>"u")throw new ce(908,!1);Zone.assertZonePatched();const a=this;a._nesting=0,a._outer=a._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(a._inner=a._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(a._inner=a._inner.fork(Zone.longStackTraceZoneSpec)),a.shouldCoalesceEventChangeDetection=!r&&n,a.shouldCoalesceRunChangeDetection=r,a.callbackScheduled=!1,function ine(e){const t=()=>{!function ane(e){e.isCheckStableRunning||e.callbackScheduled||(e.callbackScheduled=!0,Zone.root.run(()=>{HP(()=>{e.callbackScheduled=!1,x_(e),e.isCheckStableRunning=!0,w_(e),e.isCheckStableRunning=!1})}),x_(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,a,i,s,o)=>{if(function sne(e){return XP(e,"__ignore_ng_zone__")}(o))return n.invokeTask(a,i,s,o);try{return qP(e),n.invokeTask(a,i,s,o)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||e.shouldCoalesceRunChangeDetection)&&t(),KP(e)}},onInvoke:(n,r,a,i,s,o,l)=>{try{return qP(e),n.invoke(a,i,s,o,l)}finally{e.shouldCoalesceRunChangeDetection&&!e.callbackScheduled&&!function one(e){return XP(e,"__scheduler_tick__")}(o)&&t(),KP(e)}},onHasTask:(n,r,a,i)=>{n.hasTask(a,i),r===a&&("microTask"==i.change?(e._hasPendingMicrotasks=i.microTask,x_(e),w_(e)):"macroTask"==i.change&&(e.hasPendingMacrotasks=i.macroTask))},onHandleError:(n,r,a,i)=>(n.handleError(a,i),e.runOutsideAngular(()=>e.onError.emit(i)),!1)})}(a)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Et.isInAngularZone())throw new ce(909,!1)}static assertNotInAngularZone(){if(Et.isInAngularZone())throw new ce(909,!1)}run(t,n,r){return this._inner.run(t,n,r)}runTask(t,n,r,a){const i=this._inner,s=i.scheduleEventTask("NgZoneEvent: "+a,t,rne,Wb,Wb);try{return i.runTask(s,n,r)}finally{i.cancelTask(s)}}runGuarded(t,n,r){return this._inner.runGuarded(t,n,r)}runOutsideAngular(t){return this._outer.run(t)}}const rne={};function w_(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function x_(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&!0===e.callbackScheduled)}function qP(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function KP(e){e._nesting--,w_(e)}class I_{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Zr,this.onMicrotaskEmpty=new Zr,this.onStable=new Zr,this.onError=new Zr}run(t,n,r){return t.apply(n,r)}runGuarded(t,n,r){return t.apply(n,r)}runOutsideAngular(t){return t()}runTask(t,n,r,a){return t.apply(n,r)}}function XP(e,t){return!(!Array.isArray(e)||1!==e.length)&&!0===e[0]?.data?.[t]}class Ai{constructor(){this._console=console}handleError(t){const n=this._findOriginalError(t);this._console.error("ERROR",t),n&&this._console.error("ORIGINAL ERROR",n)}_findOriginalError(t){let n=t&&b_(t);for(;n&&b_(n);)n=b_(n);return n||null}}const une=new we("",{providedIn:"root",factory:()=>{const e=ie(Et),t=ie(Ai);return n=>e.runOutsideAngular(()=>t.handleError(n))}});function cne(){return nh(Lt(),ne())}function nh(e,t){return new Do(Kr(e,t))}let Do=(()=>{class e{constructor(n){this.nativeElement=n}static#e=this.__NG_ELEMENT_ID__=cne}return e})();function YP(e){return e instanceof Do?e.nativeElement:e}function dne(){return this._results[Symbol.iterator]()}class S_{static#e=Symbol.iterator;get changes(){return this._changes??=new Zr}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._onDirty=void 0,this._results=[],this._changesDetected=!1,this._changes=void 0,this.length=0,this.first=void 0,this.last=void 0;const n=S_.prototype;n[Symbol.iterator]||(n[Symbol.iterator]=dne)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,n){return this._results.reduce(t,n)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,n){this.dirty=!1;const r=function ma(e){return e.flat(Number.POSITIVE_INFINITY)}(t);(this._changesDetected=!function _ee(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let a=e[r],i=t[r];if(n&&(a=n(a),i=n(i)),i!==a)return!1}return!0}(this._results,r,n))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){void 0!==this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}onDirty(t){this._onDirty=t}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){void 0!==this._changes&&(this._changes.complete(),this._changes.unsubscribe())}}function jb(e){return!(128&~e.flags)}const __=new Map;let pne=0;const Gb="__ngContext__";function Dr(e,t){cr(t)?(e[Gb]=t[Yd],function mne(e){__.set(e[Yd],e)}(t)):e[Gb]=t}function oL(e){return uL(e[Sm])}function lL(e){return uL(e[ki])}function uL(e){for(;null!==e&&!Tr(e);)e=e[ki];return e}let E_;const Pm=new we("",{providedIn:"root",factory:()=>Rne}),Rne="ng",yL=new we(""),nu=new we("",{providedIn:"platform",factory:()=>"unknown"}),vL=new we("",{providedIn:"root",factory:()=>function Ao(){if(void 0!==E_)return E_;if(typeof document<"u")return document;throw new ce(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let bL=()=>null;function R_(e,t,n=!1){return bL(e,t,n)}const kL=new we("",{providedIn:"root",factory:()=>!1});let nw;function ML(e){return function z_(){if(void 0===nw&&(nw=null,sn.trustedTypes))try{nw=sn.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:e=>e,createScript:e=>e,createScriptURL:e=>e})}catch{}return nw}()?.createScriptURL(e)||e}class RL{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${m$})`}}function Mo(e){return e instanceof RL?e.changingThisBreaksApplicationSecurity:e}function jm(e,t){const n=function Qne(e){return e instanceof RL&&e.getTypeName()||null}(e);if(null!=n&&n!==t){if("ResourceURL"===n&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${n} (see ${m$})`)}return n===t}const nre=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;var oh=function(e){return e[e.NONE=0]="NONE",e[e.HTML=1]="HTML",e[e.STYLE=2]="STYLE",e[e.SCRIPT=3]="SCRIPT",e[e.URL=4]="URL",e[e.RESOURCE_URL=5]="RESOURCE_URL",e}(oh||{});function UL(e){const t=Gm();return t?t.sanitize(oh.URL,e)||"":jm(e,"URL")?Mo(e):function B_(e){return(e=String(e)).match(nre)?e:"unsafe:"+e}(Ge(e))}function WL(e){const t=Gm();if(t)return ML(t.sanitize(oh.RESOURCE_URL,e)||"");if(jm(e,"ResourceURL"))return ML(Mo(e));throw new ce(904,!1)}function Gm(){const e=ne();return e&&e[ns].sanitizer}function Va(e){return e instanceof Function?e():e}var Ro=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}(Ro||{});let G_;function q_(e,t){return G_(e,t)}function uh(e,t,n,r,a){if(null!=r){let i,s=!1;Tr(r)?i=r:cr(r)&&(s=!0,r=r[dn]);const o=It(r);0===e&&null!==n?null==a?r3(t,n,o):ru(t,n,o,a||null,!0):1===e&&null!==n?ru(t,n,o,a||null,!0):2===e?function Km(e,t,n){e.removeChild(null,t,n)}(t,o,s):3===e&&t.destroyNode(o),null!=i&&function Bre(e,t,n,r,a){const i=n[rs];i!==It(n)&&uh(t,e,r,i,a);for(let o=xn;o<n.length;o++){const l=n[o];uw(l[he],l,e,t,r,i)}}(t,e,i,n,a)}}function sw(e,t,n){return e.createElement(t,n)}function e3(e,t){t[ns].changeDetectionScheduler?.notify(8),uw(e,t,t[Be],2,null,null)}function t3(e,t){const n=e[Qd],r=t[On];(cr(r)||t[hn]!==r[On][hn])&&(e[Ae]|=Tb.HasTransplantedViews),null===n?e[Qd]=[t]:n.push(t)}function Z_(e,t){const n=e[Qd],r=n.indexOf(t);n.splice(r,1)}function qm(e,t){if(e.length<=xn)return;const n=xn+t,r=e[n];if(r){const a=r[ql];null!==a&&a!==e&&Z_(a,r),t>0&&(e[n-1][ki]=r[ki]);const i=gb(e,xn+t);!function Mre(e,t){e3(e,t),t[dn]=null,t[wr]=null}(r[he],r);const s=i[zs];null!==s&&s.detachView(i[he]),r[On]=null,r[ki]=null,r[Ae]&=-129}return r}function ow(e,t){if(!(256&t[Ae])){const n=t[Be];n.destroyNode&&uw(e,t,n,3,null,null),function Fre(e){let t=e[Sm];if(!t)return Y_(e[he],e);for(;t;){let n=null;if(cr(t))n=t[Sm];else{const r=t[xn];r&&(n=r)}if(!n){for(;t&&!t[ki]&&t!==e;)cr(t)&&Y_(t[he],t),t=t[On];null===t&&(t=e),cr(t)&&Y_(t[he],t),n=t&&t[ki]}t=n}}(t)}}function Y_(e,t){if(256&t[Ae])return;const n=st(null);try{t[Ae]&=-129,t[Ae]|=256,t[li]&&J1(t[li]),function Pre(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let r=0;r<n.length;r+=2){const a=t[n[r]];if(!(a instanceof Am)){const i=n[r+1];if(Array.isArray(i))for(let s=0;s<i.length;s+=2){const o=a[i[s]],l=i[s+1];as(4,o,l);try{l.call(o)}finally{as(5,o,l)}}else{as(4,a,i);try{i.call(a)}finally{as(5,a,i)}}}}}(e,t),function $re(e,t){const n=e.cleanup,r=t[Kd];if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const s=n[i+3];s>=0?r[s]():r[-s].unsubscribe(),i+=2}else n[i].call(r[n[i+1]]);null!==r&&(t[Kd]=null);const a=t[To];if(null!==a){t[To]=null;for(let i=0;i<a.length;i++)(0,a[i])()}}(e,t),1===t[he].type&&t[Be].destroy();const r=t[ql];if(null!==r&&Tr(t[On])){r!==t[On]&&Z_(r,t);const a=t[zs];null!==a&&a.detachView(e)}!function gne(e){__.delete(e[Yd])}(t)}finally{st(n)}}function Q_(e,t,n){return function n3(e,t,n){let r=t;for(;null!==r&&168&r.type;)r=(t=r).parent;if(null===r)return n[dn];{const{componentOffset:a}=r;if(a>-1){const{encapsulation:i}=e.data[r.directiveStart+a];if(i===Ci.None||i===Ci.Emulated)return null}return Kr(r,n)}}(e,t.parent,n)}function ru(e,t,n,r,a){e.insertBefore(t,n,r,a)}function r3(e,t,n){e.appendChild(t,n)}function a3(e,t,n,r,a){null!==r?ru(e,t,n,r,a):r3(e,t,n)}function J_(e,t){return e.parentNode(t)}let eC,o3=function s3(e,t,n){return 40&e.type?Kr(e,n):null};function lw(e,t,n,r){const a=Q_(e,r,t),i=t[Be],o=function i3(e,t,n){return o3(e,t,n)}(r.parent||t[wr],r,t);if(null!=a)if(Array.isArray(n))for(let l=0;l<n.length;l++)a3(i,a,n[l],o,!1);else a3(i,a,n,o,!1);void 0!==eC&&eC(i,r,t,n,a)}function au(e,t){if(null!==t){const n=t.type;if(3&n)return Kr(t,e);if(4&n)return tC(-1,e[t.index]);if(8&n){const r=t.child;if(null!==r)return au(e,r);{const a=e[t.index];return Tr(a)?tC(-1,a):It(a)}}if(128&n)return au(e,t.next);if(32&n)return q_(t,e)()||It(e[t.index]);{const r=u3(e,t);return null!==r?Array.isArray(r)?r[0]:au(Bs(e[hn]),r):au(e,t.next)}}return null}function u3(e,t){return null!==t?e[hn][wr].projection[t.projection]:null}function tC(e,t){const n=xn+e+1;if(n<t.length){const r=t[n],a=r[he].firstChild;if(null!==a)return au(r,a)}return t[rs]}function nC(e,t,n,r,a,i,s){for(;null!=n;){if(128===n.type){n=n.next;continue}const o=r[n.index],l=n.type;if(s&&0===t&&(o&&Dr(It(o),r),n.flags|=2),32&~n.flags)if(8&l)nC(e,t,n.child,r,a,i,!1),uh(t,e,a,o,i);else if(32&l){const u=q_(n,r);let c;for(;c=u();)uh(t,e,a,c,i);uh(t,e,a,o,i)}else 16&l?d3(e,t,r,n,a,i):uh(t,e,a,o,i);n=s?n.projectionNext:n.next}}function uw(e,t,n,r,a,i){nC(n,r,e.firstChild,t,a,i,!1)}function d3(e,t,n,r,a,i){const s=n[hn],l=s[wr].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)uh(t,e,a,l[u],i);else{let u=l;const c=s[On];jb(r)&&(u.flags|=128),nC(e,t,u,c,a,i,!0)}}function h3(e,t,n){""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n)}function p3(e,t,n){const{mergedAttrs:r,classes:a,styles:i}=n;null!==r&&OS(e,t,r),null!==a&&h3(e,t,a),null!==i&&function Ure(e,t,n){e.setAttribute(t,"style",n)}(e,t,i)}const qe={};function rC(e=1){f3(ot(),ne(),xr()+e,!1)}function f3(e,t,n,r){if(!r)if(3&~t[Ae]){const i=e.preOrderHooks;null!==i&&Pb(t,i,0,n)}else{const i=e.preOrderCheckHooks;null!==i&&$b(t,i,n)}Ql(n)}function Ue(e,t=pt.Default){const n=ne();return null===n?ze(e,t):RP(Lt(),n,Le(e),t)}function g3(e,t,n,r,a,i){const s=st(null);try{let o=null;a&ko.SignalBased&&(o=t[r][Bl]),null!==o&&void 0!==o.transformFn&&(i=o.transformFn(i)),a&ko.HasDecoratorInputTransform&&(i=e.inputTransforms[r].call(t,i)),null!==e.setInput?e.setInput(t,o,i,n,r):Q$(t,o,r,i)}finally{st(s)}}function cw(e,t,n,r,a,i,s,o,l,u,c){const h=t.blueprint.slice();return h[dn]=a,h[Ae]=204|r,(null!==u||e&&2048&e[Ae])&&(h[Ae]|=2048),aP(h),h[On]=h[Xd]=e,h[en]=n,h[ns]=s||e&&e[ns],h[Be]=o||e&&e[Be],h[$n]=l||e&&e[$n]||null,h[wr]=i,h[Yd]=function fne(){return pne++}(),h[qr]=c,h[K$]=u,h[hn]=2==t.type?e[hn]:h,h}function iu(e,t,n,r,a){let i=e.data[t];if(null===i)i=function aC(e,t,n,r,a){const i=dP(),s=t_(),l=e.data[t]=function Zre(e,t,n,r,a,i){let s=t?t.injectorIndex:-1,o=0;return function Yl(){return null!==Ve.skipHydrationRootTNode}()&&(o|=128),{type:n,index:r,insertBeforeIndex:null,injectorIndex:s,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:o,providerIndexes:0,value:a,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,s?i:i&&i.parent,n,t,r,a);return null===e.firstChild&&(e.firstChild=l),null!==i&&(s?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l,l.prev=i)),l}(e,t,n,r,a),function _te(){return Ve.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=n,i.value=r,i.attrs=a;const s=function Tm(){const e=Ve.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();i.injectorIndex=null===s?-1:s.injectorIndex}return Ti(i,!0),i}function Xm(e,t,n,r){if(0===n)return-1;const a=t.length;for(let i=0;i<n;i++)t.push(r),e.blueprint.push(r),e.data.push(null);return a}function y3(e,t,n,r,a){const i=xr(),s=2&r;try{Ql(-1),s&&t.length>Ee&&f3(e,t,Ee,!1),as(s?2:0,a),n(r,a)}finally{Ql(i),as(s?3:1,a)}}function iC(e,t,n){if(GS(t)){const r=st(null);try{const i=t.directiveEnd;for(let s=t.directiveStart;s<i;s++){const o=e.data[s];o.contentQueries&&o.contentQueries(1,n[s],s)}}finally{st(r)}}}function sC(e,t,n){lP()&&(function rae(e,t,n,r){const a=n.directiveStart,i=n.directiveEnd;Kl(n)&&function cae(e,t,n){const r=Kr(t,e),a=v3(n);let s=16;n.signals?s=4096:n.onPush&&(s=64);const o=dw(e,cw(e,a,null,s,r,t,null,e[ns].rendererFactory.createRenderer(r,n),null,null,null));e[t.index]=o}(t,n,e.data[a+n.componentOffset]),e.firstCreatePass||zb(n,t),Dr(r,t);const s=n.initialInputs;for(let o=a;o<i;o++){const l=e.data[o],u=eu(t,e,o,n);Dr(u,t),null!==s&&dae(0,o-a,u,l,0,s),Ni(l)&&(Ba(n.index,t)[en]=eu(t,e,o,n))}}(e,t,n,Kr(n,t)),!(64&~n.flags)&&S3(e,t,n))}function oC(e,t,n=Kr){const r=t.localNames;if(null!==r){let a=t.index+1;for(let i=0;i<r.length;i+=2){const s=r[i+1],o=-1===s?n(t,e):e[s];e[a++]=o}}}function v3(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=lC(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts,e.id):t}function lC(e,t,n,r,a,i,s,o,l,u,c){const h=Ee+r,d=h+a,p=function jre(e,t){const n=[];for(let r=0;r<t;r++)n.push(r<e?null:qe);return n}(h,d),f="function"==typeof u?u():u;return p[he]={type:e,blueprint:p,template:n,queries:null,viewQuery:o,declTNode:t,data:p.slice().fill(null,h),bindingStartIndex:h,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof s?s():s,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1,ssrId:c}}let b3=()=>null;function w3(e,t,n,r,a){for(let i in t){if(!t.hasOwnProperty(i))continue;const s=t[i];if(void 0===s)continue;r??={};let o,l=ko.None;Array.isArray(s)?(o=s[0],l=s[1]):o=s;let u=i;if(null!==a){if(!a.hasOwnProperty(i))continue;u=a[i]}0===e?x3(r,n,u,o,l):x3(r,n,u,o)}return r}function x3(e,t,n,r,a){let i;e.hasOwnProperty(n)?(i=e[n]).push(t,r):i=e[n]=[t,r],void 0!==a&&i.push(a)}function uC(e,t,n,r){if(lP()){const a=null===r?null:{"":-1},i=function iae(e,t){const n=e.directiveRegistry;let r=null,a=null;if(n)for(let i=0;i<n.length;i++){const s=n[i];if($$(t,s.selectors,!1))if(r||(r=[]),Ni(s))if(null!==s.findHostDirectiveDefs){const o=[];a=a||new Map,s.findHostDirectiveDefs(s,o,a),r.unshift(...o,s),cC(e,t,o.length)}else r.unshift(s),cC(e,t,0);else a=a||new Map,s.findHostDirectiveDefs?.(s,r,a),r.push(s)}return null===r?null:[r,a]}(e,n);let s,o;null===i?s=o=null:[s,o]=i,null!==s&&I3(e,t,n,s,a,o),a&&function sae(e,t,n){if(t){const r=e.localNames=[];for(let a=0;a<t.length;a+=2){const i=n[t[a+1]];if(null==i)throw new ce(-301,!1);r.push(t[a],i)}}}(n,r,a)}n.mergedAttrs=wm(n.mergedAttrs,n.attrs)}function I3(e,t,n,r,a,i){for(let u=0;u<r.length;u++)m_(zb(n,t),e,r[u].type);!function lae(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}(n,e.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let s=!1,o=!1,l=Xm(e,t,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];n.mergedAttrs=wm(n.mergedAttrs,c.hostAttrs),uae(e,n,t,l,c),oae(l,c,a),null!==c.contentQueries&&(n.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(n.flags|=64);const h=c.type.prototype;!s&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((e.preOrderHooks??=[]).push(n.index),s=!0),!o&&(h.ngOnChanges||h.ngDoCheck)&&((e.preOrderCheckHooks??=[]).push(n.index),o=!0),l++}!function Yre(e,t,n){const a=t.directiveEnd,i=e.data,s=t.attrs,o=[];let l=null,u=null;for(let c=t.directiveStart;c<a;c++){const h=i[c],d=n?n.get(h):null,f=d?d.outputs:null;l=w3(0,h.inputs,c,l,d?d.inputs:null),u=w3(1,h.outputs,c,u,f);const m=null===l||null===s||$S(t)?null:hae(l,c,s);o.push(m)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=o,t.inputs=l,t.outputs=u}(e,n,i)}function S3(e,t,n){const r=n.directiveStart,a=n.directiveEnd,i=n.index,s=function Ete(){return Ve.lFrame.currentDirectiveIndex}();try{Ql(i);for(let o=r;o<a;o++){const l=e.data[o],u=t[o];r_(o),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&aae(l,u)}}finally{Ql(-1),r_(s)}}function aae(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function cC(e,t,n){t.componentOffset=n,(e.components??=[]).push(t.index)}function oae(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;Ni(t)&&(n[""]=e)}}function uae(e,t,n,r,a){e.data[r]=a;const i=a.factory||(a.factory=Hl(a.type)),s=new Am(i,Ni(a),Ue);e.blueprint[r]=s,n[r]=s,function tae(e,t,n,r,a){const i=a.hostBindings;if(i){let s=e.hostBindingOpCodes;null===s&&(s=e.hostBindingOpCodes=[]);const o=~t.index;(function nae(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(s)!=o&&s.push(o),s.push(n,r,i)}}(e,t,r,Xm(e,n,a.hostVars,qe),a)}function os(e,t,n,r,a,i){const s=Kr(e,t);!function dC(e,t,n,r,a,i,s){if(null==i)e.removeAttribute(t,a,n);else{const o=null==s?Ge(i):s(i,r||"",a);e.setAttribute(t,a,o,n)}}(t[Be],s,i,e.value,n,r,a)}function dae(e,t,n,r,a,i){const s=i[t];if(null!==s)for(let o=0;o<s.length;)g3(r,n,s[o++],s[o++],s[o++],s[o++])}function hae(e,t,n){let r=null,a=0;for(;a<n.length;){const i=n[a];if(0!==i)if(5!==i){if("number"==typeof i)break;if(e.hasOwnProperty(i)){null===r&&(r=[]);const s=e[i];for(let o=0;o<s.length;o+=3)if(s[o]===t){r.push(i,s[o+1],s[o+2],n[a+1]);break}}a+=2}else a+=2;else a+=4}return r}function _3(e,t,n,r){return[e,!0,0,t,null,r,null,n,null,null]}function C3(e,t){const n=e.contentQueries;if(null!==n){const r=st(null);try{for(let a=0;a<n.length;a+=2){const s=n[a+1];if(-1!==s){const o=e.data[s];Fb(n[a]),o.contentQueries(2,t[s],s)}}}finally{st(r)}}}function dw(e,t){return e[Sm]?e[q$][ki]=t:e[Sm]=t,e[q$]=t,t}function hC(e,t,n){Fb(0);const r=st(null);try{t(e,n)}finally{st(r)}}function E3(e){return e[Kd]??=[]}function k3(e){return e.cleanup??=[]}function hw(e,t){const n=e[$n],r=n?n.get(Ai,null):null;r&&r.handleError(t)}function pC(e,t,n,r,a){for(let i=0;i<n.length;){const s=n[i++],o=n[i++],l=n[i++];g3(e.data[s],t[s],r,o,l,a)}}function pae(e,t){const n=Ba(t,e),r=n[he];!function fae(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(r,n);const a=n[dn];null!==a&&null===n[qr]&&(n[qr]=R_(a,n[$n])),fC(r,n,n[en])}function fC(e,t,n){s_(t);try{const r=e.viewQuery;null!==r&&hC(1,r,n);const a=e.template;null!==a&&y3(e,t,a,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),t[zs]?.finishViewCreation(e),e.staticContentQueries&&C3(e,t),e.staticViewQueries&&hC(2,e.viewQuery,n);const i=e.components;null!==i&&function mae(e,t){for(let n=0;n<t.length;n++)pae(e,t[n])}(t,i)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0,e.firstCreatePass=!1),r}finally{t[Ae]&=-5,o_()}}function su(e,t){return!t||null===t.firstChild||jb(e)}function Zm(e,t,n,r,a=!1){for(;null!==n;){if(128===n.type){n=a?n.projectionNext:n.next;continue}const i=t[n.index];null!==i&&r.push(It(i)),Tr(i)&&D3(i,r);const s=n.type;if(8&s)Zm(e,t,n.child,r);else if(32&s){const o=q_(n,t);let l;for(;l=o();)r.push(l)}else if(16&s){const o=u3(t,n);if(Array.isArray(o))r.push(...o);else{const l=Bs(t[hn]);Zm(l[he],l,o,r,!0)}}n=a?n.projectionNext:n.next}return r}function D3(e,t){for(let n=xn;n<e.length;n++){const r=e[n],a=r[he].firstChild;null!==a&&Zm(r[he],r,a,t)}e[rs]!==e[dn]&&t.push(e[rs])}let A3=[];const bae={...AO,consumerIsAlwaysLive:!0,consumerMarkedDirty:e=>{Ab(e.lView)},consumerOnSignalRead(){this.lView[li]=this}},xae={...AO,consumerIsAlwaysLive:!0,consumerMarkedDirty:e=>{let t=Bs(e.lView);for(;t&&!M3(t[he]);)t=Bs(t);t&&iP(t)},consumerOnSignalRead(){this.lView[li]=this}};function M3(e){return 2!==e.type}const Iae=100;function pw(e,t=!0,n=0){const r=e[ns],a=r.rendererFactory;a.begin?.();try{!function Sae(e,t){const n=fP();try{mP(!0),gC(e,t);let r=0;for(;Nm(e);){if(r===Iae)throw new ce(103,!1);r++,gC(e,1)}}finally{mP(n)}}(e,n)}catch(s){throw t&&hw(e,s),s}finally{a.end?.(),r.inlineEffectRunner?.flush()}}function _ae(e,t,n,r){const a=t[Ae];if(!(256&~a))return;t[ns].inlineEffectRunner?.flush(),s_(t);let o=!0,l=null,u=null;M3(e)?(u=function gae(e){return e[li]??function yae(e){const t=A3.pop()??Object.create(bae);return t.lView=e,t}(e)}(t),l=Y1(u)):null===function DO(){return Gn}()?(o=!1,u=function wae(e){const t=e[li]??Object.create(xae);return t.lView=e,t}(t),l=Y1(u)):t[li]&&(J1(t[li]),t[li]=null);try{aP(t),function gP(e){return Ve.lFrame.bindingIndex=e}(e.bindingStartIndex),null!==n&&y3(e,t,n,2,r);const c=!(3&~a);if(c){const p=e.preOrderCheckHooks;null!==p&&$b(t,p,null)}else{const p=e.preOrderHooks;null!==p&&Pb(t,p,0,null),u_(t,0)}if(function Cae(e){for(let t=oL(e);null!==t;t=lL(t)){if(!(t[Ae]&Tb.HasTransplantedViews))continue;const n=t[Qd];for(let r=0;r<n.length;r++)iP(n[r])}}(t),F3(t,0),null!==e.contentQueries&&C3(e,t),c){const p=e.contentCheckHooks;null!==p&&$b(t,p)}else{const p=e.contentHooks;null!==p&&Pb(t,p,1),u_(t,1)}!function Wre(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let r=0;r<n.length;r++){const a=n[r];if(a<0)Ql(~a);else{const i=a,s=n[++r],o=n[++r];Cte(s,i),o(2,t[i])}}}finally{Ql(-1)}}(e,t);const h=e.components;null!==h&&$3(t,h,0);const d=e.viewQuery;if(null!==d&&hC(2,d,r),c){const p=e.viewCheckHooks;null!==p&&$b(t,p)}else{const p=e.viewHooks;null!==p&&Pb(t,p,2),u_(t,2)}if(!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),t[kb]){for(const p of t[kb])p();t[kb]=null}t[Ae]&=-73}catch(c){throw Ab(t),c}finally{null!==u&&(function $O(e,t){if(st(t),e&&void 0!==e.producerNode&&void 0!==e.producerIndexOfThis&&void 0!==e.producerLastReadVersion){if(pm(e))for(let n=e.nextProducerIndex;n<e.producerNode.length;n++)Qv(e.producerNode[n],e.producerIndexOfThis[n]);for(;e.producerNode.length>e.nextProducerIndex;)e.producerNode.pop(),e.producerLastReadVersion.pop(),e.producerIndexOfThis.pop()}}(u,l),o&&function vae(e){e.lView[li]!==e&&(e.lView=null,A3.push(e))}(u)),o_()}}function F3(e,t){for(let n=oL(e);null!==n;n=lL(n))for(let r=xn;r<n.length;r++)O3(n[r],t)}function Eae(e,t,n){O3(Ba(t,e),n)}function O3(e,t){YS(e)&&gC(e,t)}function gC(e,t){const r=e[he],a=e[Ae],i=e[li];let s=!!(0===t&&16&a);if(s||=!!(64&a&&0===t),s||=!!(1024&a),s||=!(!i?.dirty||!Q1(i)),s||=!1,i&&(i.dirty=!1),e[Ae]&=-9217,s)_ae(r,e,r.template,e[en]);else if(8192&a){F3(e,1);const o=r.components;null!==o&&$3(e,o,1)}}function $3(e,t,n){for(let r=0;r<t.length;r++)Eae(e,t[r],n)}function Ym(e,t){const n=fP()?64:1088;for(e[ns].changeDetectionScheduler?.notify(t);e;){e[Ae]|=n;const r=Bs(e);if(Cm(e)&&!r)return e;e=r}return null}class Qm{get rootNodes(){const t=this._lView,n=t[he];return Zm(n,t,n.firstChild,[])}constructor(t,n,r=!0){this._lView=t,this._cdRefInjectingView=n,this.notifyErrorHandler=r,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[en]}set context(t){this._lView[en]=t}get destroyed(){return!(256&~this._lView[Ae])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[On];if(Tr(t)){const n=t[8],r=n?n.indexOf(this):-1;r>-1&&(qm(t,r),gb(n,r))}this._attachedToViewContainer=!1}ow(this._lView[he],this._lView)}onDestroy(t){Mb(this._lView,t)}markForCheck(){Ym(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[Ae]&=-129}reattach(){QS(this._lView),this._lView[Ae]|=128}detectChanges(){this._lView[Ae]|=1024,pw(this._lView,this.notifyErrorHandler)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ce(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;const t=Cm(this._lView),n=this._lView[ql];null!==n&&!t&&Z_(n,this._lView),e3(this._lView[he],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new ce(902,!1);this._appRef=t;const n=Cm(this._lView),r=this._lView[ql];null!==r&&!n&&t3(r,this._lView),QS(this._lView)}}let Hs=(()=>{class e{static#e=this.__NG_ELEMENT_ID__=Tae}return e})();const kae=Hs,Nae=class extends kae{constructor(t,n,r){super(),this._declarationLView=t,this._declarationTContainer=n,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,n){return this.createEmbeddedViewImpl(t,n)}createEmbeddedViewImpl(t,n,r){const a=function ch(e,t,n,r){const a=st(null);try{const i=t.tView,l=cw(e,i,n,4096&e[Ae]?4096:16,null,t,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null);l[ql]=e[t.index];const c=e[zs];return null!==c&&(l[zs]=c.createEmbeddedView(i)),fC(i,l,n),l}finally{st(a)}}(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:n,dehydratedView:r});return new Qm(a)}};function Tae(){return fw(Lt(),ne())}function fw(e,t){return 4&e.type?new Nae(t,e,nh(e,t)):null}class ph{}const sg=new we("",{providedIn:"root",factory:()=>!1}),az=new we("");class xie{}class iz{}class Sie{resolveComponentFactory(t){throw function Iie(e){const t=Error(`No component factory found for ${qn(e)}.`);return t.ngComponent=e,t}(t)}}class ww{static#e=this.NULL=new Sie}class kC{}let xw=(()=>{class e{constructor(){this.destroyNode=null}static#e=this.__NG_ELEMENT_ID__=()=>function _ie(){const e=ne(),n=Ba(Lt().index,e);return(cr(n)?n:e)[Be]}()}return e})(),Cie=(()=>{class e{static#e=this.\u0275prov=Ne({token:e,providedIn:"root",factory:()=>null})}return e})();const oz=new Set;function Yr(e){oz.has(e)||(oz.add(e),performance?.mark?.("mark_feature_usage",{detail:{feature:e}}))}var Qr=function(e){return e[e.EarlyRead=0]="EarlyRead",e[e.Write=1]="Write",e[e.MixedReadWrite=2]="MixedReadWrite",e[e.Read=3]="Read",e}(Qr||{});const lz={destroy(){}};function uz(e,t){!t&&function Cb(e){if(!H$())throw new ce(-203,!1)}();const n=t?.injector??ie(Pn);return function ba(e){return"browser"===(e??ie(Pn)).get(nu)}(n)?(Yr("NgAfterNextRender"),function cz(e,t,n,r){const a=function kie(e,t){if(e instanceof Function)switch(t){case Qr.EarlyRead:return{earlyRead:e};case Qr.Write:return{write:e};case Qr.MixedReadWrite:return{mixedReadWrite:e};case Qr.Read:return{read:e}}return e}(e,r),i=t.get(Iw),s=i.handler??=new Tie,o=[],l=[],u=()=>{for(const p of l)s.unregister(p);c()},c=t.get(Om).onDestroy(u);let h=0;const d=(p,f)=>{if(!f)return;const m=n?(...y)=>(h--,h<1&&u(),f(...y)):f,g=ts(t,()=>new Nie(p,o,m));s.register(g),l.push(g),h++};return d(Qr.EarlyRead,a.earlyRead),d(Qr.Write,a.write),d(Qr.MixedReadWrite,a.mixedReadWrite),d(Qr.Read,a.read),{destroy:u}}(e,n,!0,t?.phase??Qr.MixedReadWrite)):lz}class Nie{constructor(t,n,r){this.phase=t,this.pipelinedArgs=n,this.callbackFn=r,this.zone=ie(Et),this.errorHandler=ie(Ai,{optional:!0}),ie(ph,{optional:!0})?.notify(6)}invoke(){try{const t=this.zone.runOutsideAngular(()=>this.callbackFn.apply(null,this.pipelinedArgs));this.pipelinedArgs.splice(0,this.pipelinedArgs.length,t)}catch(t){this.errorHandler?.handleError(t)}}}class Tie{constructor(){this.executingCallbacks=!1,this.buckets={[Qr.EarlyRead]:new Set,[Qr.Write]:new Set,[Qr.MixedReadWrite]:new Set,[Qr.Read]:new Set},this.deferredCallbacks=new Set}register(t){(this.executingCallbacks?this.deferredCallbacks:this.buckets[t.phase]).add(t)}unregister(t){this.buckets[t.phase].delete(t),this.deferredCallbacks.delete(t)}execute(){this.executingCallbacks=!0;for(const t of Object.values(this.buckets))for(const n of t)n.invoke();this.executingCallbacks=!1;for(const t of this.deferredCallbacks)this.buckets[t.phase].add(t);this.deferredCallbacks.clear()}destroy(){for(const t of Object.values(this.buckets))t.clear();this.deferredCallbacks.clear()}}let Iw=(()=>{class e{constructor(){this.handler=null,this.internalCallbacks=[]}execute(){this.executeInternalCallbacks(),this.handler?.execute()}executeInternalCallbacks(){const n=[...this.internalCallbacks];this.internalCallbacks.length=0;for(const r of n)r()}ngOnDestroy(){this.handler?.destroy(),this.handler=null,this.internalCallbacks.length=0}static#e=this.\u0275prov=Ne({token:e,providedIn:"root",factory:()=>new e})}return e})();function _w(e,t,n){let r=n?e.styles:null,a=n?e.classes:null,i=0;if(null!==t)for(let s=0;s<t.length;s++){const o=t[s];"number"==typeof o?i=o:1==i?a=vS(a,o):2==i&&(r=vS(r,o+": "+t[++s]+";"))}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=a:e.classesWithoutHost=a}class pz extends ww{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const n=ut(t);return new ug(n,this.ngModule)}}function fz(e,t){const n=[];for(const r in e){if(!e.hasOwnProperty(r))continue;const a=e[r];if(void 0===a)continue;const i=Array.isArray(a),s=i?a[0]:a;n.push(t?{propName:s,templateName:r,isSignal:!!((i?a[1]:ko.None)&ko.SignalBased)}:{propName:s,templateName:r})}return n}class ug extends iz{get inputs(){const t=this.componentDef,n=t.inputTransforms,r=fz(t.inputs,!0);if(null!==n)for(const a of r)n.hasOwnProperty(a.propName)&&(a.transform=n[a.propName]);return r}get outputs(){return fz(this.componentDef.outputs,!1)}constructor(t,n){super(),this.componentDef=t,this.ngModule=n,this.componentType=t.type,this.selector=function Oee(e){return e.map(Fee).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!n}create(t,n,r,a){const i=st(null);try{let s=(a=a||this.ngModule)instanceof ya?a:a?.injector;s&&null!==this.componentDef.getStandaloneInjector&&(s=this.componentDef.getStandaloneInjector(s)||s);const o=s?new Jl(t,s):t,l=o.get(kC,null);if(null===l)throw new ce(407,!1);const u=o.get(Cie,null),d={rendererFactory:l,sanitizer:u,inlineEffectRunner:null,afterRenderEventManager:o.get(Iw,null),changeDetectionScheduler:o.get(ph,null)},p=l.createRenderer(null,this.componentDef),f=this.componentDef.selectors[0][0]||"div",m=r?function Hre(e,t,n,r){const i=r.get(kL,!1)||n===Ci.ShadowDom,s=e.selectRootElement(t,i);return function Gre(e){b3(e)}(s),s}(p,r,this.componentDef.encapsulation,o):sw(p,f,function Mie(e){const t=e.toLowerCase();return"svg"===t?nP:"math"===t?"math":null}(f));let g=512;this.componentDef.signals?g|=4096:this.componentDef.onPush||(g|=16);let y=null;null!==m&&(y=R_(m,o,!0));const v=lC(0,null,null,1,0,null,null,null,null,null,null),b=cw(null,v,null,g,null,null,d,p,o,null,y);let w,x;s_(b);try{const C=this.componentDef;let k,T=null;C.findHostDirectiveDefs?(k=[],T=new Map,C.findHostDirectiveDefs(C,k,T),k.push(C)):k=[C];const A=function Fie(e,t){const n=e[he],r=Ee;return e[r]=t,iu(n,r,2,"#host",null)}(b,m),R=function Oie(e,t,n,r,a,i,s){const o=a[he];!function $ie(e,t,n,r){for(const a of e)t.mergedAttrs=wm(t.mergedAttrs,a.hostAttrs);null!==t.mergedAttrs&&(_w(t,t.mergedAttrs,!0),null!==n&&p3(r,n,t))}(r,e,t,s);let l=null;null!==t&&(l=R_(t,a[$n]));const u=i.rendererFactory.createRenderer(t,n);let c=16;n.signals?c=4096:n.onPush&&(c=64);const h=cw(a,v3(n),null,c,a[e.index],e,i,u,null,null,l);return o.firstCreatePass&&cC(o,e,r.length-1),dw(a,h),a[e.index]=h}(A,m,C,k,b,d,p);x=km(v,Ee),m&&function Lie(e,t,n,r){if(r)OS(e,n,["ng-version","18.1.4"]);else{const{attrs:a,classes:i}=function $ee(e){const t=[],n=[];let r=1,a=2;for(;r<e.length;){let i=e[r];if("string"==typeof i)2===a?""!==i&&t.push(i,e[++r]):8===a&&n.push(i);else{if(!Ei(a))break;a=i}r++}return{attrs:t,classes:n}}(t.selectors[0]);a&&OS(e,n,a),i&&i.length>0&&h3(e,n,i.join(" "))}}(p,C,m,r),void 0!==n&&function zie(e,t,n){const r=e.projection=[];for(let a=0;a<t.length;a++){const i=n[a];r.push(null!=i?Array.from(i):null)}}(x,this.ngContentSelectors,n),w=function Pie(e,t,n,r,a,i){const s=Lt(),o=a[he],l=Kr(s,a);I3(o,a,s,n,null,r);for(let c=0;c<n.length;c++)Dr(eu(a,o,s.directiveStart+c,s),a);S3(o,a,s),l&&Dr(l,a);const u=eu(a,o,s.directiveStart+s.componentOffset,s);if(e[en]=a[en]=u,null!==i)for(const c of i)c(u,t);return iC(o,s,a),u}(R,C,k,T,b,[Bie]),fC(v,b,null)}finally{o_()}return new Rie(this.componentType,w,nh(x,b),b,x)}finally{st(i)}}}class Rie extends xie{constructor(t,n,r,a,i){super(),this.location=r,this._rootLView=a,this._tNode=i,this.previousInputValues=null,this.instance=n,this.hostView=this.changeDetectorRef=new Qm(a,void 0,!1),this.componentType=t}setInput(t,n){const r=this._tNode.inputs;let a;if(null!==r&&(a=r[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),n))return;const i=this._rootLView;pC(i[he],i,a,t,n),this.previousInputValues.set(t,n),Ym(Ba(this._tNode.index,i),1)}}get injector(){return new Zn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function Bie(){const e=Lt();Ob(ne()[he],e)}let Mi=(()=>{class e{static#e=this.__NG_ELEMENT_ID__=Vie}return e})();function Vie(){return yz(Lt(),ne())}const Uie=Mi,mz=class extends Uie{constructor(t,n,r){super(),this._lContainer=t,this._hostTNode=n,this._hostLView=r}get element(){return nh(this._hostTNode,this._hostLView)}get injector(){return new Zn(this._hostTNode,this._hostLView)}get parentInjector(){const t=Bb(this._hostTNode,this._hostLView);if(h_(t)){const n=Rm(t,this._hostLView),r=Mm(t);return new Zn(n[he].data[r+8],n)}return new Zn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const n=gz(this._lContainer);return null!==n&&n[t]||null}get length(){return this._lContainer.length-xn}createEmbeddedView(t,n,r){let a,i;"number"==typeof r?a=r:null!=r&&(a=r.index,i=r.injector);const o=t.createEmbeddedViewImpl(n||{},i,null);return this.insertImpl(o,a,su(this._hostTNode,null)),o}createComponent(t,n,r,a,i){const s=t&&!function Im(e){return"function"==typeof e}(t);let o;if(s)o=n;else{const f=n||{};o=f.index,r=f.injector,a=f.projectableNodes,i=f.environmentInjector||f.ngModuleRef}const l=s?t:new ug(ut(t)),u=r||this.parentInjector;if(!i&&null==l.ngModule){const m=(s?u:this.parentInjector).get(ya,null);m&&(i=m)}ut(l.componentType??{});const p=l.create(u,a,null,i);return this.insertImpl(p.hostView,o,su(this._hostTNode,null)),p}insert(t,n){return this.insertImpl(t,n,!0)}insertImpl(t,n,r){const a=t._lView;if(function mte(e){return Tr(e[On])}(a)){const o=this.indexOf(t);if(-1!==o)this.detach(o);else{const l=a[On],u=new mz(l,l[wr],l[On]);u.detach(u.indexOf(t))}}const i=this._adjustIndex(n),s=this._lContainer;return function dh(e,t,n,r=!0){const a=t[he];if(function Ore(e,t,n,r){const a=xn+r,i=n.length;r>0&&(n[a-1][ki]=t),r<i-xn?(t[ki]=n[a],N$(n,xn+r,t)):(n.push(t),t[ki]=null),t[On]=n;const s=t[ql];null!==s&&n!==s&&t3(s,t);const o=t[zs];null!==o&&o.insertView(e),QS(t),t[Ae]|=128}(a,t,e,n),r){const s=tC(n,e),o=t[Be],l=J_(o,e[rs]);null!==l&&function Rre(e,t,n,r,a,i){r[dn]=a,r[wr]=t,uw(e,r,n,1,a,i)}(a,e[wr],o,t,l,s)}const i=t[qr];null!==i&&null!==i.firstChild&&(i.firstChild=null)}(s,a,i,r),t.attachToViewContainerRef(),N$(AC(s),i,t),t}move(t,n){return this.insert(t,n)}indexOf(t){const n=gz(this._lContainer);return null!==n?n.indexOf(t):-1}remove(t){const n=this._adjustIndex(t,-1),r=qm(this._lContainer,n);r&&(gb(AC(this._lContainer),n),ow(r[he],r))}detach(t){const n=this._adjustIndex(t,-1),r=qm(this._lContainer,n);return r&&null!=gb(AC(this._lContainer),n)?new Qm(r):null}_adjustIndex(t,n=0){return t??this.length+n}};function gz(e){return e[8]}function AC(e){return e[8]||(e[8]=[])}function yz(e,t){let n;const r=t[e.index];return Tr(r)?n=r:(n=_3(r,t,null,e),t[e.index]=n,dw(t,n)),vz(n,t,e,r),new mz(n,e,t)}let vz=function wz(e,t,n,r){if(e[rs])return;let a;a=8&n.type?It(r):function Wie(e,t){const n=e[Be],r=n.createComment(""),a=Kr(t,e);return ru(n,J_(n,a),r,function Lre(e,t){return e.nextSibling(t)}(n,a),!1),r}(t,n),e[rs]=a},MC=()=>!1;class RC{constructor(t){this.queryList=t,this.matches=null}clone(){return new RC(this.queryList)}setDirty(){this.queryList.setDirty()}}class FC{constructor(t=[]){this.queries=t}createEmbeddedView(t){const n=t.queries;if(null!==n){const r=null!==t.contentQueries?t.contentQueries[0]:n.length,a=[];for(let i=0;i<r;i++){const s=n.getByIndex(i);a.push(this.queries[s.indexInDeclarationView].clone())}return new FC(a)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}finishViewCreation(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let n=0;n<this.queries.length;n++)null!==zC(t,n).matches&&this.queries[n].setDirty()}}class xz{constructor(t,n,r=null){this.flags=n,this.read=r,this.predicate="string"==typeof t?function Yie(e){return e.split(",").map(t=>t.trim())}(t):t}}class OC{constructor(t=[]){this.queries=t}elementStart(t,n){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,n)}elementEnd(t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementEnd(t)}embeddedTView(t){let n=null;for(let r=0;r<this.length;r++){const a=null!==n?n.length:0,i=this.getByIndex(r).embeddedTView(t,a);i&&(i.indexInDeclarationView=r,null!==n?n.push(i):n=[i])}return null!==n?new OC(n):null}template(t,n){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,n)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class $C{constructor(t,n=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=n}elementStart(t,n){this.isApplyingToNode(n)&&this.matchTNode(t,n)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,n){this.elementStart(t,n)}embeddedTView(t,n){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,n),new $C(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1&~this.metadata.flags){const n=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==n;)r=r.parent;return n===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,n){const r=this.metadata.predicate;if(Array.isArray(r))for(let a=0;a<r.length;a++){const i=r[a];this.matchTNodeWithReadOption(t,n,qie(n,i)),this.matchTNodeWithReadOption(t,n,Vb(n,t,i,!1,!1))}else r===Hs?4&n.type&&this.matchTNodeWithReadOption(t,n,-1):this.matchTNodeWithReadOption(t,n,Vb(n,t,r,!1,!1))}matchTNodeWithReadOption(t,n,r){if(null!==r){const a=this.metadata.read;if(null!==a)if(a===Do||a===Mi||a===Hs&&4&n.type)this.addMatch(n.index,-2);else{const i=Vb(n,t,a,!1,!1);null!==i&&this.addMatch(n.index,i)}else this.addMatch(n.index,r)}}addMatch(t,n){null===this.matches?this.matches=[t,n]:this.matches.push(t,n)}}function qie(e,t){const n=e.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1];return null}function Xie(e,t,n,r){return-1===n?function Kie(e,t){return 11&e.type?nh(e,t):4&e.type?fw(e,t):null}(t,e):-2===n?function Zie(e,t,n){return n===Do?nh(t,e):n===Hs?fw(t,e):n===Mi?yz(t,e):void 0}(e,t,r):eu(e,e[he],n,t)}function Iz(e,t,n,r){const a=t[zs].queries[r];if(null===a.matches){const i=e.data,s=n.matches,o=[];for(let l=0;null!==s&&l<s.length;l+=2){const u=s[l];o.push(u<0?null:Xie(t,i[u],s[l+1],n.metadata.read))}a.matches=o}return a.matches}function PC(e,t,n,r){const a=e.queries.getByIndex(n),i=a.matches;if(null!==i){const s=Iz(e,t,a,n);for(let o=0;o<i.length;o+=2){const l=i[o];if(l>0)r.push(s[o/2]);else{const u=i[o+1],c=t[-l];for(let h=xn;h<c.length;h++){const d=c[h];d[ql]===d[On]&&PC(d[he],d,u,r)}if(null!==c[Qd]){const h=c[Qd];for(let d=0;d<h.length;d++){const p=h[d];PC(p[he],p,u,r)}}}}}return r}function _z(e,t,n){const r=ot();return r.firstCreatePass&&(function Ez(e,t,n){null===e.queries&&(e.queries=new OC),e.queries.track(new $C(t,n))}(r,new xz(e,t,n),-1),!(2&~t)&&(r.staticViewQueries=!0)),function Sz(e,t,n){const r=new S_(!(4&~n));return function Xre(e,t,n,r){const a=E3(t);a.push(n),e.firstCreatePass&&k3(e).push(r,a.length-1)}(e,t,r,r.destroy),(t[zs]??=new FC).queries.push(new RC(r))-1}(r,ne(),t)}function zC(e,t){return e.queries.getByIndex(t)}function kz(e,t){const n=e[he],r=zC(n,t);return r.crossesNgTemplate?PC(n,e,t,[]):Iz(n,e,r,t)}function Gz(e){const t=e.inputConfig,n={};for(const r in t)if(t.hasOwnProperty(r)){const a=t[r];Array.isArray(a)&&a[3]&&(n[r]=a[3])}e.inputTransforms=n}class uu{}class qz{}class VC extends uu{constructor(t,n,r){super(),this._parent=n,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new pz(this);const a=Nr(t);this._bootstrapComponents=Va(a.bootstrap),this._r3Injector=WP(t,n,[{provide:uu,useValue:this},{provide:ww,useValue:this.componentFactoryResolver},...r],qn(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(n=>n()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class UC extends qz{constructor(t){super(),this.moduleType=t}create(t){return new VC(this.moduleType,t,[])}}class Kz extends uu{constructor(t){super(),this.componentFactoryResolver=new pz(this),this.instance=null;const n=new Hd([...t.providers,{provide:uu,useValue:this},{provide:ww,useValue:this.componentFactoryResolver}],t.parent||_b(),t.debugName,new Set(["environment"]));this.injector=n,t.runEnvironmentInitializers&&n.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function kw(e,t,n=null){return new Kz({providers:e,parent:t,debugName:n,runEnvironmentInitializers:!0}).injector}function In(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function hg(e,t,n,r,a,i,s,o,l,u){const c=n+Ee,h=t.firstCreatePass?function Cse(e,t,n,r,a,i,s,o,l){const u=t.consts,c=iu(t,e,4,s||null,o||null);uC(t,n,c,ui(u,l)),Ob(t,c);const h=c.tView=lC(2,c,r,a,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u,null);return null!==t.queries&&(t.queries.template(t,c),h.queries=t.queries.embeddedTView(c)),c}(c,t,e,r,a,i,s,o,l):t.data[c];Ti(h,!1);const d=Xz(t,e,h,n);Dm()&&lw(t,e,d,h),Dr(d,e);const p=_3(d,e,d,h);return e[c]=p,dw(e,p),function bz(e,t,n){return MC(e,t,n)}(p,h,e),Db(h)&&sC(t,e,h),null!=l&&oC(e,h,u),h}function jC(e,t,n,r,a,i,s,o){const l=ne(),u=ot();return hg(l,u,e,t,n,r,a,ui(u.consts,i),s,o),jC}let Xz=function Zz(e,t,n,r){return is(!0),t[Be].createComment("")};function tE(e,t,n,r){const a=ne();return In(a,Di(),t)&&(ot(),os(tn(),a,e,t,n,r)),tE}function $w(e,t,n){const r=ne();return In(r,Di(),t)&&function wa(e,t,n,r,a,i,s,o){const l=Kr(t,n);let c,u=t.inputs;!o&&null!=u&&(c=u[r])?(pC(e,n,c,r,a),Kl(t)&&function Jre(e,t){const n=Ba(t,e);16&n[Ae]||(n[Ae]|=64)}(n,t.index)):3&t.type&&(r=function Qre(e){return"class"===e?"className":"for"===e?"htmlFor":"formaction"===e?"formAction":"innerHtml"===e?"innerHTML":"readonly"===e?"readOnly":"tabindex"===e?"tabIndex":e}(r),a=null!=s?s(a,t.value||"",r):a,i.setProperty(l,r,a))}(ot(),tn(),r,e,t,r[Be],n,!1),$w}function iE(e,t,n,r,a){const s=a?"class":"style";pC(e,n,t.inputs[s],s,r)}function Ar(e,t,n,r){const a=ne(),i=ot(),s=Ee+e,o=a[Be],l=i.firstCreatePass?function Xoe(e,t,n,r,a,i){const s=t.consts,l=iu(t,e,2,r,ui(s,a));return uC(t,n,l,ui(s,i)),null!==l.attrs&&_w(l,l.attrs,!1),null!==l.mergedAttrs&&_w(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(s,i,a,t,n,r):i.data[s],u=HB(i,a,l,o,t,e);a[s]=u;const c=Db(l);return Ti(l,!0),p3(o,u,l),!function mh(e){return!(32&~e.flags)}(l)&&Dm()&&lw(i,a,u,l),0===function gte(){return Ve.lFrame.elementDepthCount}()&&Dr(u,a),function yte(){Ve.lFrame.elementDepthCount++}(),c&&(sC(i,a,l),iC(i,l,a)),null!==r&&oC(a,l),Ar}function Mr(){let e=Lt();t_()?function n_(){Ve.lFrame.isParent=!1}():(e=e.parent,Ti(e,!1));const t=e;(function bte(e){return Ve.skipHydrationRootTNode===e})(t)&&function Ste(){Ve.skipHydrationRootTNode=null}(),function vte(){Ve.lFrame.elementDepthCount--}();const n=ot();return n.firstCreatePass&&(Ob(n,e),GS(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function Ote(e){return!!(8&e.flags)}(t)&&iE(n,t,ne(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function $te(e){return!!(16&e.flags)}(t)&&iE(n,t,ne(),t.stylesWithoutHost,!1),Mr}function Oi(e,t,n,r){return Ar(e,t,n,r),Mr(),Oi}let HB=(e,t,n,r,a,i)=>(is(!0),sw(r,a,function SP(){return Ve.lFrame.currentNamespace}()));const Rh="en-US";let JB=Rh;let vV=(e,t,n)=>{};function Uw(e,t,n,r){const a=ne(),i=ot(),s=Lt();return function fE(e,t,n,r,a,i,s){const o=Db(r),u=e.firstCreatePass&&k3(e),c=t[en],h=E3(t);let d=!0;if(3&r.type||s){const m=Kr(r,t),g=s?s(m):m,y=h.length,v=s?w=>s(It(w[r.index])):r.index;let b=null;if(!s&&o&&(b=function jle(e,t,n,r){const a=e.cleanup;if(null!=a)for(let i=0;i<a.length-1;i+=2){const s=a[i];if(s===n&&a[i+1]===r){const o=t[Kd],l=a[i+2];return o.length>l?o[l]:null}"string"==typeof s&&(i+=2)}return null}(e,t,a,r.index)),null!==b)(b.__ngLastListenerFn__||b).__ngNextListenerFn__=i,b.__ngLastListenerFn__=i,d=!1;else{i=IV(r,t,c,i),vV(m,a,i);const w=n.listen(g,a,i);h.push(i,w),u&&u.push(a,v,y,y+1)}}else i=IV(r,t,c,i);const p=r.outputs;let f;if(d&&null!==p&&(f=p[a])){const m=f.length;if(m)for(let g=0;g<m;g+=2){const x=t[f[g]][f[g+1]].subscribe(i),C=h.length;h.push(i,x),u&&u.push(a,r.index,C,-(C+1))}}}(i,a,a[Be],s,e,t,r),Uw}function xV(e,t,n,r){const a=st(null);try{return as(6,t,n),!1!==n(r)}catch(i){return hw(e,i),!1}finally{as(7,t,n),st(a)}}function IV(e,t,n,r){return function a(i){if(i===Function)return r;Ym(e.componentOffset>-1?Ba(e.index,t):t,5);let o=xV(t,n,r,i),l=a.__ngNextListenerFn__;for(;l;)o=xV(t,n,l,i)&&o,l=l.__ngNextListenerFn__;return o}}function gE(e,t,n){_z(e,t,n)}function Ww(e){const t=ne(),n=ot(),r=i_();Fb(r+1);const a=zC(n,r);if(e.dirty&&function fte(e){return!(4&~e[Ae])}(t)===!(2&~a.metadata.flags)){if(null===a.matches)e.reset([]);else{const i=kz(t,r);e.reset(i,YP),e.notifyOnChanges()}return!0}return!1}function jw(){return function LC(e,t){return e[zs].queries[t].queryList}(ne(),i_())}function Fh(e,t=""){const n=ne(),r=ot(),a=e+Ee,i=r.firstCreatePass?iu(r,a,1,t,null):r.data[a],s=UV(r,n,i,t,e);n[a]=s,Dm()&&lw(r,n,s,i),Ti(i,!1)}let UV=(e,t,n,r,a)=>(is(!0),function K_(e,t){return e.createText(t)}(t[Be],r)),bue=(()=>{class e{constructor(n){this._injector=n,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(n){if(!n.standalone)return null;if(!this.cachedInjectors.has(n)){const r=PS(0,n.type),a=r.length>0?kw([r],this._injector,`Standalone[${n.type.name}]`):null;this.cachedInjectors.set(n,a)}return this.cachedInjectors.get(n)}ngOnDestroy(){try{for(const n of this.cachedInjectors.values())null!==n&&n.destroy()}finally{this.cachedInjectors.clear()}}static#e=this.\u0275prov=Ne({token:e,providedIn:"environment",factory:()=>new e(ze(ya))})}return e})();function Oh(e){Yr("NgStandalone"),e.getStandaloneInjector=t=>t.get(bue).getOrCreateStandaloneInjector(e)}function iU(e,t,n,r){return function sU(e,t,n,r,a,i){const s=t+n;return In(e,s,a)?function ls(e,t,n){return e[t]=n}(e,s+1,i?r.call(i,a):r(a)):function Ig(e,t){const n=e[t];return n===qe?void 0:n}(e,s+1)}(ne(),function Xr(){const e=Ve.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}(),e,t,n,r)}let EU=(()=>{class e{log(n){console.log(n)}warn(n){console.warn(n)}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"platform"})}return e})();const AU=new we("");function Yw(e){return!!e&&"function"==typeof e.then}function MU(e){return!!e&&"function"==typeof e.subscribe}const AE=new we("");let ME=(()=>{class e{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((n,r)=>{this.resolve=n,this.reject=r}),this.appInits=ie(AE,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const n=[];for(const a of this.appInits){const i=a();if(Yw(i))n.push(i);else if(MU(i)){const s=new Promise((o,l)=>{i.subscribe({complete:o,error:l})});n.push(s)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(n).then(()=>{r()}).catch(a=>{this.reject(a)}),0===n.length&&r(),this.initialized=!0}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Eg=new we("");let $i=(()=>{class e{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=ie(une),this.afterRenderEffectManager=ie(Iw),this.zonelessEnabled=ie(sg),this.externalTestViews=new Set,this.beforeRender=new si,this.afterTick=new si,this.componentTypes=[],this.components=[],this.isStable=ie(tu).hasPendingTasks.pipe($t(n=>!n)),this._injector=ie(ya)}get allViews(){return[...this.externalTestViews.keys(),...this._views]}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(n,r){const a=n instanceof iz;if(!this._injector.get(ME).done)throw!a&&function No(e){const t=ut(e)||Kn(e)||br(e);return null!==t&&t.standalone}(n),new ce(405,!1);let s;s=a?n:this._injector.get(ww).resolveComponentFactory(n),this.componentTypes.push(s.componentType);const o=function Rce(e){return e.isBoundToModule}(s)?void 0:this._injector.get(uu),u=s.create(Pn.NULL,[],r||s.selector,o),c=u.location.nativeElement,h=u.injector.get(AU,null);return h?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),Qw(this.components,u),h?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){this._tick(!0)}_tick(n){if(this._runningTick)throw new ce(101,!1);const r=st(null);try{this._runningTick=!0,this.detectChangesInAttachedViews(n)}catch(a){this.internalErrorHandler(a)}finally{this._runningTick=!1,st(r),this.afterTick.next()}}detectChangesInAttachedViews(n){let r=null;this._injector.destroyed||(r=this._injector.get(kC,null,{optional:!0}));let a=0;const i=this.afterRenderEffectManager;for(;a<10;){const s=0===a;if(n||!s){this.beforeRender.next(s);for(let{_lView:o,notifyErrorHandler:l}of this._views)Oce(o,l,s,this.zonelessEnabled)}else r?.begin?.(),r?.end?.();if(a++,i.executeInternalCallbacks(),!this.allViews.some(({_lView:o})=>Nm(o))&&(i.execute(),!this.allViews.some(({_lView:o})=>Nm(o))))break}}attachView(n){const r=n;this._views.push(r),r.attachToAppRef(this)}detachView(n){const r=n;Qw(this._views,r),r.detachFromAppRef()}_loadComponent(n){this.attachView(n.hostView),this.tick(),this.components.push(n);const r=this._injector.get(Eg,[]);[...this._bootstrapListeners,...r].forEach(a=>a(n))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(n=>n()),this._views.slice().forEach(n=>n.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(n){return this._destroyListeners.push(n),()=>Qw(this._destroyListeners,n)}destroy(){if(this._destroyed)throw new ce(406,!1);const n=this._injector;n.destroy&&!n.destroyed&&n.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function Qw(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}function Oce(e,t,n,r){(n||Nm(e))&&pw(e,t,n&&!r?0:1)}class $ce{constructor(t,n){this.ngModuleFactory=t,this.componentFactories=n}}let PU=(()=>{class e{compileModuleSync(n){return new UC(n)}compileModuleAsync(n){return Promise.resolve(this.compileModuleSync(n))}compileModuleAndAllComponentsSync(n){const r=this.compileModuleSync(n),i=Va(Nr(n).declarations).reduce((s,o)=>{const l=ut(o);return l&&s.push(new ug(l)),s},[]);return new $ce(r,i)}compileModuleAndAllComponentsAsync(n){return Promise.resolve(this.compileModuleAndAllComponentsSync(n))}clearCache(){}clearCacheFor(n){}getModuleId(n){}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),zce=(()=>{class e{constructor(){this.zone=ie(Et),this.changeDetectionScheduler=ie(ph),this.applicationRef=ie($i)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function RE({ngZoneFactory:e,ignoreChangesOutsideZone:t}){return e??=()=>new Et(function FE(e){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:e?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:e?.runCoalescing??!1}}()),[{provide:Et,useFactory:e},{provide:_i,multi:!0,useFactory:()=>{const n=ie(zce,{optional:!0});return()=>n.initialize()}},{provide:_i,multi:!0,useFactory:()=>{const n=ie(Vce);return()=>{n.initialize()}}},!0===t?{provide:az,useValue:!0}:[]]}let Vce=(()=>{class e{constructor(){this.subscription=new Hr,this.initialized=!1,this.zone=ie(Et),this.pendingTasks=ie(tu)}initialize(){if(this.initialized)return;this.initialized=!0;let n=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(n=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Et.assertNotInAngularZone(),queueMicrotask(()=>{null!==n&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(n),n=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Et.assertInAngularZone(),n??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),kg=(()=>{class e{constructor(){this.appRef=ie($i),this.taskService=ie(tu),this.ngZone=ie(Et),this.zonelessEnabled=ie(sg),this.disableScheduling=ie(az,{optional:!0})??!1,this.zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run,this.schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}],this.subscriptions=new Hr,this.cancelScheduledCallback=null,this.shouldRefreshViews=!1,this.useMicrotaskScheduler=!1,this.runningTick=!1,this.pendingRenderTaskId=null,this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof I_||!this.zoneIsDefined)}notify(n){if(!this.zonelessEnabled&&5===n)return;switch(n){case 3:case 2:case 0:case 4:case 5:case 1:this.shouldRefreshViews=!0}if(!this.shouldScheduleTick())return;const r=this.useMicrotaskScheduler?GP:HP;this.pendingRenderTaskId=this.taskService.add(),this.zoneIsDefined?Zone.root.run(()=>{this.cancelScheduledCallback=r(()=>{this.tick(this.shouldRefreshViews)})}):this.cancelScheduledCallback=r(()=>{this.tick(this.shouldRefreshViews)})}shouldScheduleTick(){return!(this.disableScheduling||null!==this.pendingRenderTaskId||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Et.isInAngularZone())}tick(n){if(this.runningTick||this.appRef.destroyed)return;const r=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick(n)},void 0,this.schedulerTickApplyArgs)}catch(a){throw this.taskService.remove(r),a}finally{this.cleanup()}this.useMicrotaskScheduler=!0,GP(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(r)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.shouldRefreshViews=!1,this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,null!==this.pendingRenderTaskId){const n=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(n)}}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Gs=new we("",{providedIn:"root",factory:()=>ie(Gs,pt.Optional|pt.SkipSelf)||function Uce(){return typeof $localize<"u"&&$localize.locale||Rh}()}),$E=new we("");let Lo=null;let ex=(()=>{class e{static#e=this.__NG_ELEMENT_ID__=Kce}return e})();function Kce(e){return function Xce(e,t,n){if(Kl(e)&&!n){const r=Ba(e.index,t);return new Qm(r,r)}return 175&e.type?new Qm(t[hn],t):null}(Lt(),ne(),!(16&~e))}function xde(e){try{const{rootComponent:t,appProviders:n,platformProviders:r}=e,a=function qce(e=[]){if(Lo)return Lo;const t=function WU(e=[],t){return Pn.create({name:t,providers:[{provide:BS,useValue:"platform"},{provide:$E,useValue:new Set([()=>Lo=null])},...e]})}(e);return Lo=t,function RU(){!function PQ(e){BO=e}(()=>{throw new ce(600,!1)})}(),function jU(e){e.get(yL,null)?.forEach(n=>n())}(t),t}(r),i=[RE({}),{provide:ph,useExisting:kg},...n||[]],o=new Kz({providers:i,parent:a,debugName:"",runEnvironmentInitializers:!1}).injector,l=o.get(Et);return l.run(()=>{o.resolveInjectorInitializers();const u=o.get(Ai,null);let c;l.runOutsideAngular(()=>{c=l.onError.subscribe({next:p=>{u.handleError(p)}})});const h=()=>o.destroy(),d=a.get($E);return d.add(h),o.onDestroy(()=>{c.unsubscribe(),d.delete(h)}),function FU(e,t,n){try{const r=n();return Yw(r)?r.catch(a=>{throw t.runOutsideAngular(()=>e.handleError(a)),a}):r}catch(r){throw t.runOutsideAngular(()=>e.handleError(r)),r}}(u,l,()=>{const p=o.get(ME);return p.runInitializers(),p.donePromise.then(()=>{!function eV(e){"string"==typeof e&&(JB=e.toLowerCase().replace(/_/g,"-"))}(o.get(Gs,Rh)||Rh);const m=o.get($i);return void 0!==t&&m.bootstrap(t),m})})})}catch(t){return Promise.reject(t)}}const yW=new we("");function GE(e){return"boolean"==typeof e?e:null!=e&&"false"!==e}let NW=null;function Lh(){return NW}class Zde{}const Wa=new we("");let qE=(()=>{class e{historyGo(n){throw new Error("")}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(Qde),providedIn:"platform"})}return e})();const Yde=new we("");let Qde=(()=>{class e extends qE{constructor(){super(),this._doc=ie(Wa),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Lh().getBaseHref(this._doc)}onPopState(n){const r=Lh().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",n,!1),()=>r.removeEventListener("popstate",n)}onHashChange(n){const r=Lh().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",n,!1),()=>r.removeEventListener("hashchange",n)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(n){this._location.pathname=n}pushState(n,r,a){this._history.pushState(n,r,a)}replaceState(n,r,a){this._history.replaceState(n,r,a)}forward(){this._history.forward()}back(){this._history.back()}historyGo(n=0){this._history.go(n)}getState(){return this._history.state}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>new e,providedIn:"platform"})}return e})();function KE(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function TW(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function qs(e){return e&&"?"!==e[0]?"?"+e:e}let mu=(()=>{class e{historyGo(n){throw new Error("")}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(AW),providedIn:"root"})}return e})();const DW=new we("");let AW=(()=>{class e extends mu{constructor(n,r){super(),this._platformLocation=n,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??ie(Wa).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(n){this._removeListenerFns.push(this._platformLocation.onPopState(n),this._platformLocation.onHashChange(n))}getBaseHref(){return this._baseHref}prepareExternalUrl(n){return KE(this._baseHref,n)}path(n=!1){const r=this._platformLocation.pathname+qs(this._platformLocation.search),a=this._platformLocation.hash;return a&&n?`${r}${a}`:r}pushState(n,r,a,i){const s=this.prepareExternalUrl(a+qs(i));this._platformLocation.pushState(n,r,s)}replaceState(n,r,a,i){const s=this.prepareExternalUrl(a+qs(i));this._platformLocation.replaceState(n,r,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(n=0){this._platformLocation.historyGo?.(n)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(qE),ze(DW,8))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),Jde=(()=>{class e extends mu{constructor(n,r){super(),this._platformLocation=n,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(n){this._removeListenerFns.push(this._platformLocation.onPopState(n),this._platformLocation.onHashChange(n))}getBaseHref(){return this._baseHref}path(n=!1){const r=this._platformLocation.hash??"#";return r.length>0?r.substring(1):r}prepareExternalUrl(n){const r=KE(this._baseHref,n);return r.length>0?"#"+r:r}pushState(n,r,a,i){let s=this.prepareExternalUrl(a+qs(i));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(n,r,s)}replaceState(n,r,a,i){let s=this.prepareExternalUrl(a+qs(i));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(n,r,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(n=0){this._platformLocation.historyGo?.(n)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(qE),ze(DW,8))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})(),Ag=(()=>{class e{constructor(n){this._subject=new Zr,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=n;const r=this._locationStrategy.getBaseHref();this._basePath=function nhe(e){if(new RegExp("^(https?:)?//").test(e)){const[,n]=e.split(/\/\/[^\/]+/);return n}return e}(TW(MW(r))),this._locationStrategy.onPopState(a=>{this._subject.emit({url:this.path(!0),pop:!0,state:a.state,type:a.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(n=!1){return this.normalize(this._locationStrategy.path(n))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(n,r=""){return this.path()==this.normalize(n+qs(r))}normalize(n){return e.stripTrailingSlash(function the(e,t){if(!e||!t.startsWith(e))return t;const n=t.substring(e.length);return""===n||["/",";","?","#"].includes(n[0])?n:t}(this._basePath,MW(n)))}prepareExternalUrl(n){return n&&"/"!==n[0]&&(n="/"+n),this._locationStrategy.prepareExternalUrl(n)}go(n,r="",a=null){this._locationStrategy.pushState(a,"",n,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+qs(r)),a)}replaceState(n,r="",a=null){this._locationStrategy.replaceState(a,"",n,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(n+qs(r)),a)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(n=0){this._locationStrategy.historyGo?.(n)}onUrlChange(n){return this._urlChangeListeners.push(n),this._urlChangeSubscription??=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}),()=>{const r=this._urlChangeListeners.indexOf(n);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(n="",r){this._urlChangeListeners.forEach(a=>a(n,r))}subscribe(n,r,a){return this._subject.subscribe({next:n,error:r,complete:a})}static#e=this.normalizeQueryParams=qs;static#t=this.joinWithSlash=KE;static#n=this.stripTrailingSlash=TW;static#r=this.\u0275fac=function(r){return new(r||e)(ze(mu))};static#a=this.\u0275prov=Ne({token:e,factory:()=>function ehe(){return new Ag(ze(mu))}(),providedIn:"root"})}return e})();function MW(e){return e.replace(/\/index.html$/,"")}const ak=/\s+/,VW=[];let UW=(()=>{class e{constructor(n,r){this._ngEl=n,this._renderer=r,this.initialClasses=VW,this.stateMap=new Map}set klass(n){this.initialClasses=null!=n?n.trim().split(ak):VW}set ngClass(n){this.rawClass="string"==typeof n?n.trim().split(ak):n}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const n=this.rawClass;if(Array.isArray(n)||n instanceof Set)for(const r of n)this._updateState(r,!0);else if(null!=n)for(const r of Object.keys(n))this._updateState(r,!!n[r]);this._applyStateDiff()}_updateState(n,r){const a=this.stateMap.get(n);void 0!==a?(a.enabled!==r&&(a.changed=!0,a.enabled=r),a.touched=!0):this.stateMap.set(n,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const n of this.stateMap){const r=n[0],a=n[1];a.changed?(this._toggleClass(r,a.enabled),a.changed=!1):a.touched||(a.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),a.touched=!1}}_toggleClass(n,r){(n=n.trim()).length>0&&n.split(ak).forEach(a=>{r?this._renderer.addClass(this._ngEl.nativeElement,a):this._renderer.removeClass(this._ngEl.nativeElement,a)})}static#e=this.\u0275fac=function(r){return new(r||e)(Ue(Do),Ue(xw))};static#t=this.\u0275dir=Gr({type:e,selectors:[["","ngClass",""]],inputs:{klass:[0,"class","klass"],ngClass:"ngClass"},standalone:!0})}return e})(),HW=(()=>{class e{constructor(n,r){this._viewContainer=n,this._context=new jhe,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(n){this._context.$implicit=this._context.ngIf=n,this._updateView()}set ngIfThen(n){GW("ngIfThen",n),this._thenTemplateRef=n,this._thenViewRef=null,this._updateView()}set ngIfElse(n){GW("ngIfElse",n),this._elseTemplateRef=n,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(n,r){return!0}static#e=this.\u0275fac=function(r){return new(r||e)(Ue(Mi),Ue(Hs))};static#t=this.\u0275dir=Gr({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0})}return e})();class jhe{constructor(){this.$implicit=null,this.ngIf=null}}function GW(e,t){if(t&&!t.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${qn(t)}'.`)}let mpe=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275mod=wb({type:e});static#n=this.\u0275inj=mm({})}return e})();const XW="browser";function ZW(e){return"server"===e}let vpe=(()=>{class e{static#e=this.\u0275prov=Ne({token:e,providedIn:"root",factory:()=>function ype(e){return e===XW}(ie(nu))?new bpe(ie(Wa),window):new xpe})}return e})();class bpe{constructor(t,n){this.document=t,this.window=n,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return[this.window.scrollX,this.window.scrollY]}scrollToPosition(t){this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){const n=function wpe(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&"function"==typeof e.body.attachShadow){const r=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let a=r.currentNode;for(;a;){const i=a.shadowRoot;if(i){const s=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(s)return s}a=r.nextNode()}}return null}(this.document,t);n&&(this.scrollToElement(n),n.focus())}setHistoryScrollRestoration(t){this.window.history.scrollRestoration=t}scrollToElement(t){const n=t.getBoundingClientRect(),r=n.left+this.window.pageXOffset,a=n.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],a-i[1])}}class xpe{setOffset(t){}getScrollPosition(){return[0,0]}scrollToPosition(t){}scrollToAnchor(t){}setHistoryScrollRestoration(t){}}class Zpe extends Zde{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class hk extends Zpe{static makeCurrent(){!function Xde(e){NW??=e}(new hk)}onAndCancel(t,n,r){return t.addEventListener(n,r),()=>{t.removeEventListener(n,r)}}dispatchEvent(t,n){t.dispatchEvent(n)}remove(t){t.remove()}createElement(t,n){return(n=n||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,n){return"window"===n?window:"document"===n?t:"body"===n?t.body:null}getBaseHref(t){const n=function Ype(){return Og=Og||document.querySelector("base"),Og?Og.getAttribute("href"):null}();return null==n?null:function Qpe(e){return new URL(e,document.baseURI).pathname}(n)}resetBaseElement(){Og=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function Bhe(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const r=n.indexOf("="),[a,i]=-1==r?[n,""]:[n.slice(0,r),n.slice(r+1)];if(a.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let Og=null,efe=(()=>{class e{build(){return new XMLHttpRequest}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();const _x=new we("");let s4=(()=>{class e{constructor(n,r){this._zone=r,this._eventNameToPlugin=new Map,n.forEach(a=>{a.manager=this}),this._plugins=n.slice().reverse()}addEventListener(n,r,a){return this._findPluginFor(r).addEventListener(n,r,a)}getZone(){return this._zone}_findPluginFor(n){let r=this._eventNameToPlugin.get(n);if(r)return r;if(r=this._plugins.find(i=>i.supports(n)),!r)throw new ce(5101,!1);return this._eventNameToPlugin.set(n,r),r}static#e=this.\u0275fac=function(r){return new(r||e)(ze(_x),ze(Et))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();class pk{constructor(t){this._doc=t}}const fk="ng-app-id";let o4=(()=>{class e{constructor(n,r,a,i={}){this.doc=n,this.appId=r,this.nonce=a,this.platformId=i,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=ZW(i),this.resetHostNodes()}addStyles(n){for(const r of n)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(n){for(const r of n)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const n=this.styleNodesInDOM;n&&(n.forEach(r=>r.remove()),n.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(n){this.hostNodes.add(n);for(const r of this.getAllStyles())this.addStyleToHost(n,r)}removeHost(n){this.hostNodes.delete(n)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(n){for(const r of this.hostNodes)this.addStyleToHost(r,n)}onStyleRemoved(n){const r=this.styleRef;r.get(n)?.elements?.forEach(a=>a.remove()),r.delete(n)}collectServerRenderedStyles(){const n=this.doc.head?.querySelectorAll(`style[${fk}="${this.appId}"]`);if(n?.length){const r=new Map;return n.forEach(a=>{null!=a.textContent&&r.set(a.textContent,a)}),r}return null}changeUsageCount(n,r){const a=this.styleRef;if(a.has(n)){const i=a.get(n);return i.usage+=r,i.usage}return a.set(n,{usage:r,elements:[]}),r}getStyleElement(n,r){const a=this.styleNodesInDOM,i=a?.get(r);if(i?.parentNode===n)return a.delete(r),i.removeAttribute(fk),i;{const s=this.doc.createElement("style");return this.nonce&&s.setAttribute("nonce",this.nonce),s.textContent=r,this.platformIsServer&&s.setAttribute(fk,this.appId),n.appendChild(s),s}}addStyleToHost(n,r){const a=this.getStyleElement(n,r),i=this.styleRef,s=i.get(r)?.elements;s?s.push(a):i.set(r,{elements:[a],usage:1})}resetHostNodes(){const n=this.hostNodes;n.clear(),n.add(this.doc.head)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Wa),ze(Pm),ze(vL,8),ze(nu))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();const mk={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},gk=/%COMP%/g,afe=new we("",{providedIn:"root",factory:()=>!0});function u4(e,t){return t.map(n=>n.replace(gk,e))}let c4=(()=>{class e{constructor(n,r,a,i,s,o,l,u=null){this.eventManager=n,this.sharedStylesHost=r,this.appId=a,this.removeStylesOnCompDestroy=i,this.doc=s,this.platformId=o,this.ngZone=l,this.nonce=u,this.rendererByCompId=new Map,this.platformIsServer=ZW(o),this.defaultRenderer=new yk(n,s,l,this.platformIsServer)}createRenderer(n,r){if(!n||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===Ci.ShadowDom&&(r={...r,encapsulation:Ci.Emulated});const a=this.getOrCreateRenderer(n,r);return a instanceof h4?a.applyToHost(n):a instanceof vk&&a.applyStyles(),a}getOrCreateRenderer(n,r){const a=this.rendererByCompId;let i=a.get(r.id);if(!i){const s=this.doc,o=this.ngZone,l=this.eventManager,u=this.sharedStylesHost,c=this.removeStylesOnCompDestroy,h=this.platformIsServer;switch(r.encapsulation){case Ci.Emulated:i=new h4(l,u,r,this.appId,c,s,o,h);break;case Ci.ShadowDom:return new lfe(l,u,n,r,s,o,this.nonce,h);default:i=new vk(l,u,r,c,s,o,h)}a.set(r.id,i)}return i}ngOnDestroy(){this.rendererByCompId.clear()}static#e=this.\u0275fac=function(r){return new(r||e)(ze(s4),ze(o4),ze(Pm),ze(afe),ze(Wa),ze(nu),ze(Et),ze(vL))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();class yk{constructor(t,n,r,a){this.eventManager=t,this.doc=n,this.ngZone=r,this.platformIsServer=a,this.data=Object.create(null),this.throwOnSyntheticProps=!0,this.destroyNode=null}destroy(){}createElement(t,n){return n?this.doc.createElementNS(mk[n]||n,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,n){(d4(t)?t.content:t).appendChild(n)}insertBefore(t,n,r){t&&(d4(t)?t.content:t).insertBefore(n,r)}removeChild(t,n){n.remove()}selectRootElement(t,n){let r="string"==typeof t?this.doc.querySelector(t):t;if(!r)throw new ce(-5104,!1);return n||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,n,r,a){if(a){n=a+":"+n;const i=mk[a];i?t.setAttributeNS(i,n,r):t.setAttribute(n,r)}else t.setAttribute(n,r)}removeAttribute(t,n,r){if(r){const a=mk[r];a?t.removeAttributeNS(a,n):t.removeAttribute(`${r}:${n}`)}else t.removeAttribute(n)}addClass(t,n){t.classList.add(n)}removeClass(t,n){t.classList.remove(n)}setStyle(t,n,r,a){a&(Ro.DashCase|Ro.Important)?t.style.setProperty(n,r,a&Ro.Important?"important":""):t.style[n]=r}removeStyle(t,n,r){r&Ro.DashCase?t.style.removeProperty(n):t.style[n]=""}setProperty(t,n,r){null!=t&&(t[n]=r)}setValue(t,n){t.nodeValue=n}listen(t,n,r){if("string"==typeof t&&!(t=Lh().getGlobalEventTarget(this.doc,t)))throw new Error(`Unsupported event target ${t} for event ${n}`);return this.eventManager.addEventListener(t,n,this.decoratePreventDefault(r))}decoratePreventDefault(t){return n=>{if("__ngUnwrap__"===n)return t;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>t(n)):t(n))&&n.preventDefault()}}}function d4(e){return"TEMPLATE"===e.tagName&&void 0!==e.content}class lfe extends yk{constructor(t,n,r,a,i,s,o,l){super(t,i,s,l),this.sharedStylesHost=n,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const u=u4(a.id,a.styles);for(const c of u){const h=document.createElement("style");o&&h.setAttribute("nonce",o),h.textContent=c,this.shadowRoot.appendChild(h)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,n){return super.appendChild(this.nodeOrShadowRoot(t),n)}insertBefore(t,n,r){return super.insertBefore(this.nodeOrShadowRoot(t),n,r)}removeChild(t,n){return super.removeChild(null,n)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class vk extends yk{constructor(t,n,r,a,i,s,o,l){super(t,i,s,o),this.sharedStylesHost=n,this.removeStylesOnCompDestroy=a,this.styles=l?u4(l,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}}class h4 extends vk{constructor(t,n,r,a,i,s,o,l){const u=a+"-"+r.id;super(t,n,r,i,s,o,l,u),this.contentAttr=function ife(e){return"_ngcontent-%COMP%".replace(gk,e)}(u),this.hostAttr=function sfe(e){return"_nghost-%COMP%".replace(gk,e)}(u)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,n){const r=super.createElement(t,n);return super.setAttribute(r,this.contentAttr,""),r}}let ufe=(()=>{class e extends pk{constructor(n){super(n)}supports(n){return!0}addEventListener(n,r,a){return n.addEventListener(r,a,!1),()=>this.removeEventListener(n,r,a)}removeEventListener(n,r,a){return n.removeEventListener(r,a)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Wa))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})(),cfe=(()=>{class e extends pk{constructor(n){super(n),this.delegate=ie(yW,{optional:!0})}supports(n){return!!this.delegate&&this.delegate.supports(n)}addEventListener(n,r,a){return this.delegate.addEventListener(n,r,a)}removeEventListener(n,r,a){return this.delegate.removeEventListener(n,r,a)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Wa))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();const p4=["alt","control","meta","shift"],dfe={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},hfe={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let pfe=(()=>{class e extends pk{constructor(n){super(n)}supports(n){return null!=e.parseEventName(n)}addEventListener(n,r,a){const i=e.parseEventName(r),s=e.eventCallback(i.fullKey,a,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Lh().onAndCancel(n,i.domEventName,s))}static parseEventName(n){const r=n.toLowerCase().split("."),a=r.shift();if(0===r.length||"keydown"!==a&&"keyup"!==a)return null;const i=e._normalizeKey(r.pop());let s="",o=r.indexOf("code");if(o>-1&&(r.splice(o,1),s="code."),p4.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),s+=u+".")}),s+=i,0!=r.length||0===i.length)return null;const l={};return l.domEventName=a,l.fullKey=s,l}static matchEventFullKeyCode(n,r){let a=dfe[n.key]||n.key,i="";return r.indexOf("code.")>-1&&(a=n.code,i="code."),!(null==a||!a)&&(a=a.toLowerCase()," "===a?a="space":"."===a&&(a="dot"),p4.forEach(s=>{s!==a&&(0,hfe[s])(n)&&(i+=s+".")}),i+=a,i===r)}static eventCallback(n,r,a){return i=>{e.matchEventFullKeyCode(i,n)&&a.runGuarded(()=>r(i))}}static _normalizeKey(n){return"esc"===n?"escape":n}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Wa))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();function f4(e){return{appProviders:[...wfe,...e?.providers??[]],platformProviders:vfe}}const vfe=[{provide:nu,useValue:XW},{provide:yL,useValue:function mfe(){hk.makeCurrent()},multi:!0},{provide:Wa,useFactory:function yfe(){return function Mne(e){E_=e}(document),document},deps:[]}],wfe=[{provide:BS,useValue:"root"},{provide:Ai,useFactory:function gfe(){return new Ai},deps:[]},{provide:_x,useClass:ufe,multi:!0,deps:[Wa,Et,nu]},{provide:_x,useClass:pfe,multi:!0,deps:[Wa]},{provide:_x,useClass:cfe,multi:!0},c4,o4,s4,{provide:kC,useExisting:c4},{provide:class Ipe{},useClass:efe,deps:[]},[]];let xfe=(()=>{class e{constructor(n){this._doc=n}getTitle(){return this._doc.title}setTitle(n){this._doc.title=n||""}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Wa))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function zo(e){return this instanceof zo?(this.v=e,this):new zo(e)}function w4(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,t=e[Symbol.asyncIterator];return t?t.call(e):(e=function Ik(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),n={},r("next"),r("throw"),r("return"),n[Symbol.asyncIterator]=function(){return this},n);function r(i){n[i]=e[i]&&function(s){return new Promise(function(o,l){!function a(i,s,o,l){Promise.resolve(l).then(function(u){i({value:u,done:o})},s)}(o,l,(s=e[i](s)).done,s.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const x4=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function I4(e){return an(e?.then)}function S4(e){return an(e[uS])}function _4(e){return Symbol.asyncIterator&&an(e?.[Symbol.asyncIterator])}function C4(e){return new TypeError(`You provided ${null!==e&&"object"==typeof e?"an invalid object":`'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const E4=function qfe(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function k4(e){return an(e?.[E4])}function N4(e){return function b4(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var a,r=n.apply(e,t||[]),i=[];return a={},o("next"),o("throw"),o("return",function s(p){return function(f){return Promise.resolve(f).then(p,h)}}),a[Symbol.asyncIterator]=function(){return this},a;function o(p,f){r[p]&&(a[p]=function(m){return new Promise(function(g,y){i.push([p,m,g,y])>1||l(p,m)})},f&&(a[p]=f(a[p])))}function l(p,f){try{!function u(p){p.value instanceof zo?Promise.resolve(p.value.v).then(c,h):d(i[0][2],p)}(r[p](f))}catch(m){d(i[0][3],m)}}function c(p){l("next",p)}function h(p){l("throw",p)}function d(p,f){p(f),i.shift(),i.length&&l(i[0][0],i[0][1])}}(this,arguments,function*(){const n=e.getReader();try{for(;;){const{value:r,done:a}=yield zo(n.read());if(a)return yield zo(void 0);yield yield zo(r)}}finally{n.releaseLock()}})}function T4(e){return an(e?.getReader)}function Zs(e){if(e instanceof yr)return e;if(null!=e){if(S4(e))return function Kfe(e){return new yr(t=>{const n=e[uS]();if(an(n.subscribe))return n.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(e);if(x4(e))return function Xfe(e){return new yr(t=>{for(let n=0;n<e.length&&!t.closed;n++)t.next(e[n]);t.complete()})}(e);if(I4(e))return function Zfe(e){return new yr(t=>{e.then(n=>{t.closed||(t.next(n),t.complete())},n=>t.error(n)).then(null,GO)})}(e);if(_4(e))return D4(e);if(k4(e))return function Yfe(e){return new yr(t=>{for(const n of e)if(t.next(n),t.closed)return;t.complete()})}(e);if(T4(e))return function Qfe(e){return D4(N4(e))}(e)}throw C4(e)}function D4(e){return new yr(t=>{(function Jfe(e,t){var n,r,a,i;return function y4(e,t,n,r){return new(n||(n=Promise))(function(i,s){function o(c){try{u(r.next(c))}catch(h){s(h)}}function l(c){try{u(r.throw(c))}catch(h){s(h)}}function u(c){c.done?i(c.value):function a(i){return i instanceof n?i:new n(function(s){s(i)})}(c.value).then(o,l)}u((r=r.apply(e,t||[])).next())})}(this,void 0,void 0,function*(){try{for(n=w4(e);!(r=yield n.next()).done;)if(t.next(r.value),t.closed)return}catch(s){a={error:s}}finally{try{r&&!r.done&&(i=n.return)&&(yield i.call(n))}finally{if(a)throw a.error}}t.complete()})})(e,t).catch(n=>t.error(n))})}function Ys(e,t,n,r=0,a=!1){const i=t.schedule(function(){n(),a?e.add(this.schedule(null,r)):this.unsubscribe()},r);if(e.add(i),!a)return i}function A4(e,t=0){return vr((n,r)=>{n.subscribe(ur(r,a=>Ys(r,e,()=>r.next(a),t),()=>Ys(r,e,()=>r.complete(),t),a=>Ys(r,e,()=>r.error(a),t)))})}function M4(e,t=0){return vr((n,r)=>{r.add(e.schedule(()=>n.subscribe(r),t))})}function R4(e,t){if(!e)throw new Error("Iterable cannot be null");return new yr(n=>{Ys(n,t,()=>{const r=e[Symbol.asyncIterator]();Ys(n,t,()=>{r.next().then(a=>{a.done?n.complete():n.next(a.value)})},0,!0)})})}function Ir(e,t){return t?function ime(e,t){if(null!=e){if(S4(e))return function eme(e,t){return Zs(e).pipe(M4(t),A4(t))}(e,t);if(x4(e))return function nme(e,t){return new yr(n=>{let r=0;return t.schedule(function(){r===e.length?n.complete():(n.next(e[r++]),n.closed||this.schedule())})})}(e,t);if(I4(e))return function tme(e,t){return Zs(e).pipe(M4(t),A4(t))}(e,t);if(_4(e))return R4(e,t);if(k4(e))return function rme(e,t){return new yr(n=>{let r;return Ys(n,t,()=>{r=e[E4](),Ys(n,t,()=>{let a,i;try{({value:a,done:i}=r.next())}catch(s){return void n.error(s)}i?n.complete():n.next(a)},0,!0)}),()=>an(r?.return)&&r.return()})}(e,t);if(T4(e))return function ame(e,t){return R4(N4(e),t)}(e,t)}throw C4(e)}(e,t):Zs(e)}function Sk(e){return e[e.length-1]}function Ex(e){return function sme(e){return e&&an(e.schedule)}(Sk(e))?e.pop():void 0}function We(...e){return Ir(e,Ex(e))}const{isArray:lme}=Array,{getPrototypeOf:ume,prototype:cme,keys:dme}=Object;const{isArray:fme}=Array;function _k(...e){const t=Ex(e),n=function ome(e){return an(Sk(e))?e.pop():void 0}(e),{args:r,keys:a}=function hme(e){if(1===e.length){const t=e[0];if(lme(t))return{args:t,keys:null};if(function pme(e){return e&&"object"==typeof e&&ume(e)===cme}(t)){const n=dme(t);return{args:n.map(r=>t[r]),keys:n}}}return{args:e,keys:null}}(e);if(0===r.length)return Ir([],t);const i=new yr(function vme(e,t,n=Wl){return r=>{F4(t,()=>{const{length:a}=e,i=new Array(a);let s=a,o=a;for(let l=0;l<a;l++)F4(t,()=>{const u=Ir(e[l],t);let c=!1;u.subscribe(ur(r,h=>{i[l]=h,c||(c=!0,o--),o||r.next(n(i.slice()))},()=>{--s||r.complete()}))},r)},r)}}(r,t,a?s=>function yme(e,t){return e.reduce((n,r,a)=>(n[r]=t[a],n),{})}(a,s):Wl));return n?i.pipe(function gme(e){return $t(t=>function mme(e,t){return fme(t)?e(...t):e(t)}(e,t))}(n)):i}function F4(e,t,n){e?Ys(n,e,t):t()}const kx=eS(e=>function(){e(this),this.name="EmptyError",this.message="no elements in sequence"});function Rr(e,t,n=1/0){return an(t)?Rr((r,a)=>$t((i,s)=>t(r,i,a,s))(Zs(e(r,a))),n):("number"==typeof t&&(n=t),vr((r,a)=>function bme(e,t,n,r,a,i,s,o){const l=[];let u=0,c=0,h=!1;const d=()=>{h&&!l.length&&!u&&t.complete()},p=m=>u<r?f(m):l.push(m),f=m=>{i&&t.next(m),u++;let g=!1;Zs(n(m,c++)).subscribe(ur(t,y=>{a?.(y),i?p(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(u--;l.length&&u<r;){const y=l.shift();s?Ys(t,s,()=>f(y)):f(y)}d()}catch(y){t.error(y)}}))};return e.subscribe(ur(t,p,()=>{h=!0,d()})),()=>{o?.()}}(r,a,e,n)))}function $g(e=1/0){return Rr(Wl,e)}function Ck(...e){return function wme(){return $g(1)}()(Ir(e,Ex(e)))}function O4(e){return new yr(t=>{Zs(e()).subscribe(t)})}function Nx(e,t){const n=an(e)?e:()=>e,r=a=>a.error(n());return new yr(t?a=>t.schedule(r,0,a):r)}const ds=new yr(e=>e.complete());function Ek(){return vr((e,t)=>{let n=null;e._refCount++;const r=ur(t,void 0,void 0,void 0,()=>{if(!e||e._refCount<=0||0<--e._refCount)return void(n=null);const a=e._connection,i=n;n=null,a&&(!i||a===i)&&a.unsubscribe(),t.unsubscribe()});e.subscribe(r),r.closed||(n=e.connect())})}class $4 extends yr{constructor(t,n){super(),this.source=t,this.subjectFactory=n,this._subject=null,this._refCount=0,this._connection=null,ZO(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new Hr;const n=this.getSubject();t.add(this.source.subscribe(ur(n,void 0,()=>{this._teardown(),n.complete()},r=>{this._teardown(),n.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=Hr.EMPTY)}return t}refCount(){return Ek()(this)}}function hs(e,t){return vr((n,r)=>{let a=null,i=0,s=!1;const o=()=>s&&!a&&r.complete();n.subscribe(ur(r,l=>{a?.unsubscribe();let u=0;const c=i++;Zs(e(l,c)).subscribe(a=ur(r,h=>r.next(t?t(l,h,c,u++):h),()=>{a=null,o()}))},()=>{s=!0,o()}))})}function Vh(e){return e<=0?()=>ds:vr((t,n)=>{let r=0;t.subscribe(ur(n,a=>{++r<=e&&(n.next(a),e<=r&&n.complete())}))})}function Bo(e,t){return vr((n,r)=>{let a=0;n.subscribe(ur(r,i=>e.call(t,i,a++)&&r.next(i)))})}function Tx(e){return vr((t,n)=>{let r=!1;t.subscribe(ur(n,a=>{r=!0,n.next(a)},()=>{r||n.next(e),n.complete()}))})}function P4(e=Sme){return vr((t,n)=>{let r=!1;t.subscribe(ur(n,a=>{r=!0,n.next(a)},()=>r?n.complete():n.error(e())))})}function Sme(){return new kx}function yu(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Bo((a,i)=>e(a,i,r)):Wl,Vh(1),n?Tx(t):P4(()=>new kx))}function Pg(e,t){return an(t)?Rr(e,t,1):Rr(e,1)}function na(e,t,n){const r=an(e)||t||n?{next:e,error:t,complete:n}:e;return r?vr((a,i)=>{var s;null===(s=r.subscribe)||void 0===s||s.call(r);let o=!0;a.subscribe(ur(i,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),i.next(l)},()=>{var l;o=!1,null===(l=r.complete)||void 0===l||l.call(r),i.complete()},l=>{var u;o=!1,null===(u=r.error)||void 0===u||u.call(r,l),i.error(l)},()=>{var l,u;o&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):Wl}function Uh(e){return vr((t,n)=>{let i,r=null,a=!1;r=t.subscribe(ur(n,void 0,void 0,s=>{i=Zs(e(s,Uh(e)(t))),r?(r.unsubscribe(),r=null,i.subscribe(n)):a=!0})),a&&(r.unsubscribe(),r=null,i.subscribe(n))})}function kk(e){return e<=0?()=>ds:vr((t,n)=>{let r=[];t.subscribe(ur(n,a=>{r.push(a),e<r.length&&r.shift()},()=>{for(const a of r)n.next(a);n.complete()},void 0,()=>{r=null}))})}function Nk(e){return vr((t,n)=>{try{t.subscribe(n)}finally{n.add(e)}})}const at="primary",Lg=Symbol("RouteTitle");class Tme{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const n=this.params[t];return Array.isArray(n)?n[0]:n}return null}getAll(t){if(this.has(t)){const n=this.params[t];return Array.isArray(n)?n:[n]}return[]}get keys(){return Object.keys(this.params)}}function Wh(e){return new Tme(e)}function Dme(e,t,n){const r=n.path.split("/");if(r.length>e.length||"full"===n.pathMatch&&(t.hasChildren()||r.length<e.length))return null;const a={};for(let i=0;i<r.length;i++){const s=r[i],o=e[i];if(":"===s[0])a[s.substring(1)]=o;else if(s!==o.path)return null}return{consumed:e.slice(0,r.length),posParams:a}}function ps(e,t){const n=e?Tk(e):void 0,r=t?Tk(t):void 0;if(!n||!r||n.length!=r.length)return!1;let a;for(let i=0;i<n.length;i++)if(a=n[i],!L4(e[a],t[a]))return!1;return!0}function Tk(e){return[...Object.keys(e),...Object.getOwnPropertySymbols(e)]}function L4(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),r=[...t].sort();return n.every((a,i)=>r[i]===a)}return e===t}function z4(e){return e.length>0?e[e.length-1]:null}function Vo(e){return function Cfe(e){return!!e&&(e instanceof yr||an(e.lift)&&an(e.subscribe))}(e)?e:Yw(e)?Ir(Promise.resolve(e)):We(e)}const Mme={exact:function U4(e,t,n){if(!bu(e.segments,t.segments)||!Dx(e.segments,t.segments,n)||e.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!e.children[r]||!U4(e.children[r],t.children[r],n))return!1;return!0},subset:W4},B4={exact:function Rme(e,t){return ps(e,t)},subset:function Fme(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>L4(e[n],t[n]))},ignored:()=>!0};function V4(e,t,n){return Mme[n.paths](e.root,t.root,n.matrixParams)&&B4[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function W4(e,t,n){return j4(e,t,t.segments,n)}function j4(e,t,n,r){if(e.segments.length>n.length){const a=e.segments.slice(0,n.length);return!(!bu(a,n)||t.hasChildren()||!Dx(a,n,r))}if(e.segments.length===n.length){if(!bu(e.segments,n)||!Dx(e.segments,n,r))return!1;for(const a in t.children)if(!e.children[a]||!W4(e.children[a],t.children[a],r))return!1;return!0}{const a=n.slice(0,e.segments.length),i=n.slice(e.segments.length);return!!(bu(e.segments,a)&&Dx(e.segments,a,r)&&e.children[at])&&j4(e.children[at],t,i,r)}}function Dx(e,t,n){return t.every((r,a)=>B4[n](e[a].parameters,r.parameters))}class vu{constructor(t=new Ht([],{}),n={},r=null){this.root=t,this.queryParams=n,this.fragment=r}get queryParamMap(){return this._queryParamMap??=Wh(this.queryParams),this._queryParamMap}toString(){return Pme.serialize(this)}}class Ht{constructor(t,n){this.segments=t,this.children=n,this.parent=null,Object.values(n).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Mx(this)}}class zg{constructor(t,n){this.path=t,this.parameters=n}get parameterMap(){return this._parameterMap??=Wh(this.parameters),this._parameterMap}toString(){return q4(this)}}function bu(e,t){return e.length===t.length&&e.every((n,r)=>n.path===t[r].path)}let jh=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>new Ax,providedIn:"root"})}return e})();class Ax{parse(t){const n=new Kme(t);return new vu(n.parseRootSegment(),n.parseQueryParams(),n.parseFragment())}serialize(t){const n=`/${Bg(t.root,!0)}`,r=function Bme(e){const t=Object.entries(e).map(([n,r])=>Array.isArray(r)?r.map(a=>`${Rx(n)}=${Rx(a)}`).join("&"):`${Rx(n)}=${Rx(r)}`).filter(n=>n);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${n}${r}${"string"==typeof t.fragment?`#${function Lme(e){return encodeURI(e)}(t.fragment)}`:""}`}}const Pme=new Ax;function Mx(e){return e.segments.map(t=>q4(t)).join("/")}function Bg(e,t){if(!e.hasChildren())return Mx(e);if(t){const n=e.children[at]?Bg(e.children[at],!1):"",r=[];return Object.entries(e.children).forEach(([a,i])=>{a!==at&&r.push(`${a}:${Bg(i,!1)}`)}),r.length>0?`${n}(${r.join("//")})`:n}{const n=function $me(e,t){let n=[];return Object.entries(e.children).forEach(([r,a])=>{r===at&&(n=n.concat(t(a,r)))}),Object.entries(e.children).forEach(([r,a])=>{r!==at&&(n=n.concat(t(a,r)))}),n}(e,(r,a)=>a===at?[Bg(e.children[at],!1)]:[`${a}:${Bg(r,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children[at]?`${Mx(e)}/${n[0]}`:`${Mx(e)}/(${n.join("//")})`}}function H4(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Rx(e){return H4(e).replace(/%3B/gi,";")}function Dk(e){return H4(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Fx(e){return decodeURIComponent(e)}function G4(e){return Fx(e.replace(/\+/g,"%20"))}function q4(e){return`${Dk(e.path)}${function zme(e){return Object.entries(e).map(([t,n])=>`;${Dk(t)}=${Dk(n)}`).join("")}(e.parameters)}`}const Vme=/^[^\/()?;#]+/;function Ak(e){const t=e.match(Vme);return t?t[0]:""}const Ume=/^[^\/()?;=#]+/,jme=/^[^=?&#]+/,Gme=/^[^&#]+/;class Kme{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Ht([],{}):new Ht([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let n={};this.peekStartsWith("/(")&&(this.capture("/"),n=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(n).length>0)&&(r[at]=new Ht(t,n)),r}parseSegment(){const t=Ak(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new ce(4009,!1);return this.capture(t),new zg(Fx(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const n=function Wme(e){const t=e.match(Ume);return t?t[0]:""}(this.remaining);if(!n)return;this.capture(n);let r="";if(this.consumeOptional("=")){const a=Ak(this.remaining);a&&(r=a,this.capture(r))}t[Fx(n)]=Fx(r)}parseQueryParam(t){const n=function Hme(e){const t=e.match(jme);return t?t[0]:""}(this.remaining);if(!n)return;this.capture(n);let r="";if(this.consumeOptional("=")){const s=function qme(e){const t=e.match(Gme);return t?t[0]:""}(this.remaining);s&&(r=s,this.capture(r))}const a=G4(n),i=G4(r);if(t.hasOwnProperty(a)){let s=t[a];Array.isArray(s)||(s=[s],t[a]=s),s.push(i)}else t[a]=i}parseParens(t){const n={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Ak(this.remaining),a=this.remaining[r.length];if("/"!==a&&")"!==a&&";"!==a)throw new ce(4010,!1);let i;r.indexOf(":")>-1?(i=r.slice(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=at);const s=this.parseChildren();n[i]=1===Object.keys(s).length?s[at]:new Ht([],s),this.consumeOptional("//")}return n}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new ce(4011,!1)}}function K4(e){return e.segments.length>0?new Ht([],{[at]:e}):e}function X4(e){const t={};for(const[r,a]of Object.entries(e.children)){const i=X4(a);if(r===at&&0===i.segments.length&&i.hasChildren())for(const[s,o]of Object.entries(i.children))t[s]=o;else(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function Xme(e){if(1===e.numberOfChildren&&e.children[at]){const t=e.children[at];return new Ht(e.segments.concat(t.segments),t.children)}return e}(new Ht(e.segments,t))}function wu(e){return e instanceof vu}function Z4(e){let t;const a=K4(function n(i){const s={};for(const l of i.children){const u=n(l);s[l.outlet]=u}const o=new Ht(i.url,s);return i===e&&(t=o),o}(e.root));return t??a}function Y4(e,t,n,r){let a=e;for(;a.parent;)a=a.parent;if(0===t.length)return Mk(a,a,a,n,r);const i=function Yme(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new J4(!0,0,e);let t=0,n=!1;const r=e.reduce((a,i,s)=>{if("object"==typeof i&&null!=i){if(i.outlets){const o={};return Object.entries(i.outlets).forEach(([l,u])=>{o[l]="string"==typeof u?u.split("/"):u}),[...a,{outlets:o}]}if(i.segmentPath)return[...a,i.segmentPath]}return"string"!=typeof i?[...a,i]:0===s?(i.split("/").forEach((o,l)=>{0==l&&"."===o||(0==l&&""===o?n=!0:".."===o?t++:""!=o&&a.push(o))}),a):[...a,i]},[]);return new J4(n,t,r)}(t);if(i.toRoot())return Mk(a,a,new Ht([],{}),n,r);const s=function Qme(e,t,n){if(e.isAbsolute)return new $x(t,!0,0);if(!n)return new $x(t,!1,NaN);if(null===n.parent)return new $x(n,!0,0);const r=Ox(e.commands[0])?0:1;return function Jme(e,t,n){let r=e,a=t,i=n;for(;i>a;){if(i-=a,r=r.parent,!r)throw new ce(4005,!1);a=r.segments.length}return new $x(r,!1,a-i)}(n,n.segments.length-1+r,e.numberOfDoubleDots)}(i,a,e),o=s.processChildren?Ug(s.segmentGroup,s.index,i.commands):ej(s.segmentGroup,s.index,i.commands);return Mk(a,s.segmentGroup,o,n,r)}function Ox(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function Vg(e){return"object"==typeof e&&null!=e&&e.outlets}function Mk(e,t,n,r,a){let s,i={};r&&Object.entries(r).forEach(([l,u])=>{i[l]=Array.isArray(u)?u.map(c=>`${c}`):`${u}`}),s=e===t?n:Q4(e,t,n);const o=K4(X4(s));return new vu(o,i,a)}function Q4(e,t,n){const r={};return Object.entries(e.children).forEach(([a,i])=>{r[a]=i===t?n:Q4(i,t,n)}),new Ht(e.segments,r)}class J4{constructor(t,n,r){if(this.isAbsolute=t,this.numberOfDoubleDots=n,this.commands=r,t&&r.length>0&&Ox(r[0]))throw new ce(4003,!1);const a=r.find(Vg);if(a&&a!==z4(r))throw new ce(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class $x{constructor(t,n,r){this.segmentGroup=t,this.processChildren=n,this.index=r}}function ej(e,t,n){if(e??=new Ht([],{}),0===e.segments.length&&e.hasChildren())return Ug(e,t,n);const r=function tge(e,t,n){let r=0,a=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;a<e.segments.length;){if(r>=n.length)return i;const s=e.segments[a],o=n[r];if(Vg(o))break;const l=`${o}`,u=r<n.length-1?n[r+1]:null;if(a>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!nj(l,u,s))return i;r+=2}else{if(!nj(l,{},s))return i;r++}a++}return{match:!0,pathIndex:a,commandIndex:r}}(e,t,n),a=n.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const i=new Ht(e.segments.slice(0,r.pathIndex),{});return i.children[at]=new Ht(e.segments.slice(r.pathIndex),e.children),Ug(i,0,a)}return r.match&&0===a.length?new Ht(e.segments,{}):r.match&&!e.hasChildren()?Rk(e,t,n):r.match?Ug(e,0,a):Rk(e,t,n)}function Ug(e,t,n){if(0===n.length)return new Ht(e.segments,{});{const r=function ege(e){return Vg(e[0])?e[0].outlets:{[at]:e}}(n),a={};if(Object.keys(r).some(i=>i!==at)&&e.children[at]&&1===e.numberOfChildren&&0===e.children[at].segments.length){const i=Ug(e.children[at],t,n);return new Ht(e.segments,i.children)}return Object.entries(r).forEach(([i,s])=>{"string"==typeof s&&(s=[s]),null!==s&&(a[i]=ej(e.children[i],t,s))}),Object.entries(e.children).forEach(([i,s])=>{void 0===r[i]&&(a[i]=s)}),new Ht(e.segments,a)}}function Rk(e,t,n){const r=e.segments.slice(0,t);let a=0;for(;a<n.length;){const i=n[a];if(Vg(i)){const l=nge(i.outlets);return new Ht(r,l)}if(0===a&&Ox(n[0])){r.push(new zg(e.segments[t].path,tj(n[0]))),a++;continue}const s=Vg(i)?i.outlets[at]:`${i}`,o=a<n.length-1?n[a+1]:null;s&&o&&Ox(o)?(r.push(new zg(s,tj(o))),a+=2):(r.push(new zg(s,{})),a++)}return new Ht(r,{})}function nge(e){const t={};return Object.entries(e).forEach(([n,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(t[n]=Rk(new Ht([],{}),0,r))}),t}function tj(e){const t={};return Object.entries(e).forEach(([n,r])=>t[n]=`${r}`),t}function nj(e,t,n){return e==n.path&&ps(t,n.parameters)}const Wg="imperative";var gt=function(e){return e[e.NavigationStart=0]="NavigationStart",e[e.NavigationEnd=1]="NavigationEnd",e[e.NavigationCancel=2]="NavigationCancel",e[e.NavigationError=3]="NavigationError",e[e.RoutesRecognized=4]="RoutesRecognized",e[e.ResolveStart=5]="ResolveStart",e[e.ResolveEnd=6]="ResolveEnd",e[e.GuardsCheckStart=7]="GuardsCheckStart",e[e.GuardsCheckEnd=8]="GuardsCheckEnd",e[e.RouteConfigLoadStart=9]="RouteConfigLoadStart",e[e.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",e[e.ChildActivationStart=11]="ChildActivationStart",e[e.ChildActivationEnd=12]="ChildActivationEnd",e[e.ActivationStart=13]="ActivationStart",e[e.ActivationEnd=14]="ActivationEnd",e[e.Scroll=15]="Scroll",e[e.NavigationSkipped=16]="NavigationSkipped",e}(gt||{});class fs{constructor(t,n){this.id=t,this.url=n}}class Px extends fs{constructor(t,n,r="imperative",a=null){super(t,n),this.type=gt.NavigationStart,this.navigationTrigger=r,this.restoredState=a}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Qs extends fs{constructor(t,n,r){super(t,n),this.urlAfterRedirects=r,this.type=gt.NavigationEnd}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}var Ha=function(e){return e[e.Redirect=0]="Redirect",e[e.SupersededByNewNavigation=1]="SupersededByNewNavigation",e[e.NoDataFromResolver=2]="NoDataFromResolver",e[e.GuardRejected=3]="GuardRejected",e}(Ha||{}),Lx=function(e){return e[e.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",e[e.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",e}(Lx||{});class xu extends fs{constructor(t,n,r,a){super(t,n),this.reason=r,this.code=a,this.type=gt.NavigationCancel}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Hh extends fs{constructor(t,n,r,a){super(t,n),this.reason=r,this.code=a,this.type=gt.NavigationSkipped}}class Fk extends fs{constructor(t,n,r,a){super(t,n),this.error=r,this.target=a,this.type=gt.NavigationError}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class rj extends fs{constructor(t,n,r,a){super(t,n),this.urlAfterRedirects=r,this.state=a,this.type=gt.RoutesRecognized}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class rge extends fs{constructor(t,n,r,a){super(t,n),this.urlAfterRedirects=r,this.state=a,this.type=gt.GuardsCheckStart}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class age extends fs{constructor(t,n,r,a,i){super(t,n),this.urlAfterRedirects=r,this.state=a,this.shouldActivate=i,this.type=gt.GuardsCheckEnd}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class ige extends fs{constructor(t,n,r,a){super(t,n),this.urlAfterRedirects=r,this.state=a,this.type=gt.ResolveStart}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class sge extends fs{constructor(t,n,r,a){super(t,n),this.urlAfterRedirects=r,this.state=a,this.type=gt.ResolveEnd}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class oge{constructor(t){this.route=t,this.type=gt.RouteConfigLoadStart}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class lge{constructor(t){this.route=t,this.type=gt.RouteConfigLoadEnd}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class uge{constructor(t){this.snapshot=t,this.type=gt.ChildActivationStart}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class cge{constructor(t){this.snapshot=t,this.type=gt.ChildActivationEnd}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class dge{constructor(t){this.snapshot=t,this.type=gt.ActivationStart}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class hge{constructor(t){this.snapshot=t,this.type=gt.ActivationEnd}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class aj{constructor(t,n,r){this.routerEvent=t,this.position=n,this.anchor=r,this.type=gt.Scroll}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class Ok{}class zx{constructor(t,n){this.url=t,this.navigationBehaviorOptions=n}}function zi(e){return e.outlet||at}function jg(e){if(!e)return null;if(e.routeConfig?._injector)return e.routeConfig._injector;for(let t=e.parent;t;t=t.parent){const n=t.routeConfig;if(n?._loadedInjector)return n._loadedInjector;if(n?._injector)return n._injector}return null}class vge{get injector(){return jg(this.route?.snapshot)??this.rootInjector}set injector(t){}constructor(t){this.rootInjector=t,this.outlet=null,this.route=null,this.children=new Hg(this.rootInjector),this.attachRef=null}}let Hg=(()=>{class e{constructor(n){this.rootInjector=n,this.contexts=new Map}onChildOutletCreated(n,r){const a=this.getOrCreateContext(n);a.outlet=r,this.contexts.set(n,a)}onChildOutletDestroyed(n){const r=this.getContext(n);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const n=this.contexts;return this.contexts=new Map,n}onOutletReAttached(n){this.contexts=n}getOrCreateContext(n){let r=this.getContext(n);return r||(r=new vge(this.rootInjector),this.contexts.set(n,r)),r}getContext(n){return this.contexts.get(n)||null}static#e=this.\u0275fac=function(r){return new(r||e)(ze(ya))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();class ij{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const n=this.pathFromRoot(t);return n.length>1?n[n.length-2]:null}children(t){const n=$k(t,this._root);return n?n.children.map(r=>r.value):[]}firstChild(t){const n=$k(t,this._root);return n&&n.children.length>0?n.children[0].value:null}siblings(t){const n=Pk(t,this._root);return n.length<2?[]:n[n.length-2].children.map(a=>a.value).filter(a=>a!==t)}pathFromRoot(t){return Pk(t,this._root).map(n=>n.value)}}function $k(e,t){if(e===t.value)return t;for(const n of t.children){const r=$k(e,n);if(r)return r}return null}function Pk(e,t){if(e===t.value)return[t];for(const n of t.children){const r=Pk(e,n);if(r.length)return r.unshift(t),r}return[]}class Bi{constructor(t,n){this.value=t,this.children=n}toString(){return`TreeNode(${this.value})`}}function Gh(e){const t={};return e&&e.children.forEach(n=>t[n.value.outlet]=n),t}class sj extends ij{constructor(t,n){super(t),this.snapshot=n,Lk(this,t)}toString(){return this.snapshot.toString()}}function oj(e){const t=function bge(e){const i=new Vx([],{},{},"",{},at,e,null,{});return new lj("",new Bi(i,[]))}(e),n=new oi([new zg("",{})]),r=new oi({}),a=new oi({}),i=new oi({}),s=new oi(""),o=new qh(n,r,i,s,a,at,e,t.root);return o.snapshot=t.root,new sj(new Bi(o,[]),t)}class qh{constructor(t,n,r,a,i,s,o,l){this.urlSubject=t,this.paramsSubject=n,this.queryParamsSubject=r,this.fragmentSubject=a,this.dataSubject=i,this.outlet=s,this.component=o,this._futureSnapshot=l,this.title=this.dataSubject?.pipe($t(u=>u[Lg]))??We(void 0),this.url=t,this.params=n,this.queryParams=r,this.fragment=a,this.data=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe($t(t=>Wh(t))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe($t(t=>Wh(t))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Bx(e,t,n="emptyOnly"){let r;const{routeConfig:a}=e;return r=null===t||"always"!==n&&""!==a?.path&&(t.component||t.routeConfig?.loadComponent)?{params:{...e.params},data:{...e.data},resolve:{...e.data,...e._resolvedData??{}}}:{params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.data,...a?.data,...e._resolvedData}},a&&cj(a)&&(r.resolve[Lg]=a.title),r}class Vx{get title(){return this.data?.[Lg]}constructor(t,n,r,a,i,s,o,l,u){this.url=t,this.params=n,this.queryParams=r,this.fragment=a,this.data=i,this.outlet=s,this.component=o,this.routeConfig=l,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=Wh(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=Wh(this.queryParams),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class lj extends ij{constructor(t,n){super(n),this.url=t,Lk(this,n)}toString(){return uj(this._root)}}function Lk(e,t){t.value._routerState=e,t.children.forEach(n=>Lk(e,n))}function uj(e){const t=e.children.length>0?` { ${e.children.map(uj).join(", ")} } `:"";return`${e.value}${t}`}function zk(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,ps(t.queryParams,n.queryParams)||e.queryParamsSubject.next(n.queryParams),t.fragment!==n.fragment&&e.fragmentSubject.next(n.fragment),ps(t.params,n.params)||e.paramsSubject.next(n.params),function Ame(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!ps(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.urlSubject.next(n.url),ps(t.data,n.data)||e.dataSubject.next(n.data)}else e.snapshot=e._futureSnapshot,e.dataSubject.next(e._futureSnapshot.data)}function Bk(e,t){const n=ps(e.params,t.params)&&function Ome(e,t){return bu(e,t)&&e.every((n,r)=>ps(n.parameters,t[r].parameters))}(e.url,t.url);return n&&!(!e.parent!=!t.parent)&&(!e.parent||Bk(e.parent,t.parent))}function cj(e){return"string"==typeof e.title||null===e.title}let Vk=(()=>{class e{constructor(){this.activated=null,this._activatedRoute=null,this.name=at,this.activateEvents=new Zr,this.deactivateEvents=new Zr,this.attachEvents=new Zr,this.detachEvents=new Zr,this.parentContexts=ie(Hg),this.location=ie(Mi),this.changeDetector=ie(ex),this.inputBinder=ie(Ux,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(n){if(n.name){const{firstChange:r,previousValue:a}=n.name;if(r)return;this.isTrackedInParentContexts(a)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(a)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(n){return this.parentContexts.getContext(n)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const n=this.parentContexts.getContext(this.name);n?.route&&(n.attachRef?this.attach(n.attachRef,n.route):this.activateWith(n.route,n.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new ce(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new ce(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new ce(4012,!1);this.location.detach();const n=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(n.instance),n}attach(n,r){this.activated=n,this._activatedRoute=r,this.location.insert(n.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(n.instance)}deactivate(){if(this.activated){const n=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(n)}}activateWith(n,r){if(this.isActivated)throw new ce(4013,!1);this._activatedRoute=n;const a=this.location,s=n.snapshot.component,o=this.parentContexts.getOrCreateContext(this.name).children,l=new Uk(n,o,a.injector);this.activated=a.createComponent(s,{index:a.length,injector:l,environmentInjector:r}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275dir=Gr({type:e,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Xl]})}return e})();class Uk{__ngOutletInjector(t){return new Uk(this.route,this.childContexts,t)}constructor(t,n,r){this.route=t,this.childContexts=n,this.parent=r}get(t,n){return t===qh?this.route:t===Hg?this.childContexts:this.parent.get(t,n)}}const Ux=new we("");let dj=(()=>{class e{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(n){this.unsubscribeFromRouteData(n),this.subscribeToRouteData(n)}unsubscribeFromRouteData(n){this.outletDataSubscriptions.get(n)?.unsubscribe(),this.outletDataSubscriptions.delete(n)}subscribeToRouteData(n){const{activatedRoute:r}=n,a=_k([r.queryParams,r.params,r.data]).pipe(hs(([i,s,o],l)=>(o={...i,...s,...o},0===l?We(o):Promise.resolve(o)))).subscribe(i=>{if(!n.isActivated||!n.activatedComponentRef||n.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(n);const s=function Kde(e){const t=ut(e);if(!t)return null;const n=new ug(t);return{get selector(){return n.selector},get type(){return n.componentType},get inputs(){return n.inputs},get outputs(){return n.outputs},get ngContentSelectors(){return n.ngContentSelectors},get isStandalone(){return t.standalone},get isSignal(){return t.signals}}}(r.component);if(s)for(const{templateName:o}of s.inputs)n.activatedComponentRef.setInput(o,i[o]);else this.unsubscribeFromRouteData(n)});this.outletDataSubscriptions.set(n,a)}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();function Gg(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const r=n.value;r._futureSnapshot=t.value;const a=function xge(e,t,n){return t.children.map(r=>{for(const a of n.children)if(e.shouldReuseRoute(r.value,a.value.snapshot))return Gg(e,r,a);return Gg(e,r)})}(e,t,n);return new Bi(r,a)}{if(e.shouldAttach(t.value)){const i=e.retrieve(t.value);if(null!==i){const s=i.route;return s.value._futureSnapshot=t.value,s.children=t.children.map(o=>Gg(e,o)),s}}const r=function Ige(e){return new qh(new oi(e.url),new oi(e.params),new oi(e.queryParams),new oi(e.fragment),new oi(e.data),e.outlet,e.component,e)}(t.value),a=t.children.map(i=>Gg(e,i));return new Bi(r,a)}}class Wk{constructor(t,n){this.redirectTo=t,this.navigationBehaviorOptions=n}}const hj="ngNavigationCancelingError";function Wx(e,t){const{redirectTo:n,navigationBehaviorOptions:r}=wu(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,a=pj(!1,Ha.Redirect);return a.url=n,a.navigationBehaviorOptions=r,a}function pj(e,t){const n=new Error(`NavigationCancelingError: ${e||""}`);return n[hj]=!0,n.cancellationCode=t,n}function fj(e){return!!e&&e[hj]}class Cge{constructor(t,n,r,a,i){this.routeReuseStrategy=t,this.futureState=n,this.currState=r,this.forwardEvent=a,this.inputBindingEnabled=i}activate(t){const n=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(n,r,t),zk(this.futureState.root),this.activateChildRoutes(n,r,t)}deactivateChildRoutes(t,n,r){const a=Gh(n);t.children.forEach(i=>{const s=i.value.outlet;this.deactivateRoutes(i,a[s],r),delete a[s]}),Object.values(a).forEach(i=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,n,r){const a=t.value,i=n?n.value:null;if(a===i)if(a.component){const s=r.getContext(a.outlet);s&&this.deactivateChildRoutes(t,n,s.children)}else this.deactivateChildRoutes(t,n,r);else i&&this.deactivateRouteAndItsChildren(n,r)}deactivateRouteAndItsChildren(t,n){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,n):this.deactivateRouteAndOutlet(t,n)}detachAndStoreRouteSubtree(t,n){const r=n.getContext(t.value.outlet),a=r&&t.value.component?r.children:n,i=Gh(t);for(const s of Object.values(i))this.deactivateRouteAndItsChildren(s,a);if(r&&r.outlet){const s=r.outlet.detach(),o=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:s,route:t,contexts:o})}}deactivateRouteAndOutlet(t,n){const r=n.getContext(t.value.outlet),a=r&&t.value.component?r.children:n,i=Gh(t);for(const s of Object.values(i))this.deactivateRouteAndItsChildren(s,a);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(t,n,r){const a=Gh(n);t.children.forEach(i=>{this.activateRoutes(i,a[i.value.outlet],r),this.forwardEvent(new hge(i.value.snapshot))}),t.children.length&&this.forwardEvent(new cge(t.value.snapshot))}activateRoutes(t,n,r){const a=t.value,i=n?n.value:null;if(zk(a),a===i)if(a.component){const s=r.getOrCreateContext(a.outlet);this.activateChildRoutes(t,n,s.children)}else this.activateChildRoutes(t,n,r);else if(a.component){const s=r.getOrCreateContext(a.outlet);if(this.routeReuseStrategy.shouldAttach(a.snapshot)){const o=this.routeReuseStrategy.retrieve(a.snapshot);this.routeReuseStrategy.store(a.snapshot,null),s.children.onOutletReAttached(o.contexts),s.attachRef=o.componentRef,s.route=o.route.value,s.outlet&&s.outlet.attach(o.componentRef,o.route.value),zk(o.route.value),this.activateChildRoutes(t,null,s.children)}else s.attachRef=null,s.route=a,s.outlet&&s.outlet.activateWith(a,s.injector),this.activateChildRoutes(t,null,s.children)}else this.activateChildRoutes(t,null,r)}}class mj{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class jx{constructor(t,n){this.component=t,this.route=n}}function Ege(e,t,n){const r=e._root;return qg(r,t?t._root:null,n,[r.value])}function Kh(e,t){const n=Symbol(),r=t.get(e,n);return r===n?"function"!=typeof e||function see(e){return null!==ub(e)}(e)?t.get(e):e:r}function qg(e,t,n,r,a={canDeactivateChecks:[],canActivateChecks:[]}){const i=Gh(t);return e.children.forEach(s=>{(function Nge(e,t,n,r,a={canDeactivateChecks:[],canActivateChecks:[]}){const i=e.value,s=t?t.value:null,o=n?n.getContext(e.value.outlet):null;if(s&&i.routeConfig===s.routeConfig){const l=function Tge(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!bu(e.url,t.url);case"pathParamsOrQueryParamsChange":return!bu(e.url,t.url)||!ps(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Bk(e,t)||!ps(e.queryParams,t.queryParams);default:return!Bk(e,t)}}(s,i,i.routeConfig.runGuardsAndResolvers);l?a.canActivateChecks.push(new mj(r)):(i.data=s.data,i._resolvedData=s._resolvedData),qg(e,t,i.component?o?o.children:null:n,r,a),l&&o&&o.outlet&&o.outlet.isActivated&&a.canDeactivateChecks.push(new jx(o.outlet.component,s))}else s&&Kg(t,o,a),a.canActivateChecks.push(new mj(r)),qg(e,null,i.component?o?o.children:null:n,r,a)})(s,i[s.value.outlet],n,r.concat([s.value]),a),delete i[s.value.outlet]}),Object.entries(i).forEach(([s,o])=>Kg(o,n.getContext(s),a)),a}function Kg(e,t,n){const r=Gh(e),a=e.value;Object.entries(r).forEach(([i,s])=>{Kg(s,a.component?t?t.children.getContext(i):null:t,n)}),n.canDeactivateChecks.push(new jx(a.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,a))}function Xg(e){return"function"==typeof e}function gj(e){return e instanceof kx||"EmptyError"===e?.name}const Hx=Symbol("INITIAL_VALUE");function Xh(){return hs(e=>_k(e.map(t=>t.pipe(Vh(1),function Ime(...e){const t=Ex(e);return vr((n,r)=>{(t?Ck(e,n,t):Ck(e,n)).subscribe(r)})}(Hx)))).pipe($t(t=>{for(const n of t)if(!0!==n){if(n===Hx)return Hx;if(!1===n||$ge(n))return n}return!0}),Bo(t=>t!==Hx),Vh(1)))}function $ge(e){return wu(e)||e instanceof Wk}function yj(e){return function ZQ(...e){return qO(e)}(na(t=>{if("boolean"!=typeof t)throw Wx(0,t)}),$t(t=>!0===t))}class jk{constructor(t){this.segmentGroup=t||null}}class Gx extends Error{constructor(t){super(),this.urlTree=t}}function Zh(e){return Nx(new jk(e))}class Xge{constructor(t,n){this.urlSerializer=t,this.urlTree=n}lineralizeSegments(t,n){let r=[],a=n.root;for(;;){if(r=r.concat(a.segments),0===a.numberOfChildren)return We(r);if(a.numberOfChildren>1||!a.children[at])return Nx(new ce(4e3,!1));a=a.children[at]}}applyRedirectCommands(t,n,r,a,i){if("string"!=typeof n){const o=n,{queryParams:l,fragment:u,routeConfig:c,url:h,outlet:d,params:p,data:f,title:m}=a,g=ts(i,()=>o({params:p,data:f,queryParams:l,fragment:u,routeConfig:c,url:h,outlet:d,title:m}));if(g instanceof vu)throw new Gx(g);n=g}const s=this.applyRedirectCreateUrlTree(n,this.urlSerializer.parse(n),t,r);if("/"===n[0])throw new Gx(s);return s}applyRedirectCreateUrlTree(t,n,r,a){const i=this.createSegmentGroup(t,n.root,r,a);return new vu(i,this.createQueryParams(n.queryParams,this.urlTree.queryParams),n.fragment)}createQueryParams(t,n){const r={};return Object.entries(t).forEach(([a,i])=>{if("string"==typeof i&&":"===i[0]){const o=i.substring(1);r[a]=n[o]}else r[a]=i}),r}createSegmentGroup(t,n,r,a){const i=this.createSegments(t,n.segments,r,a);let s={};return Object.entries(n.children).forEach(([o,l])=>{s[o]=this.createSegmentGroup(t,l,r,a)}),new Ht(i,s)}createSegments(t,n,r,a){return n.map(i=>":"===i.path[0]?this.findPosParam(t,i,a):this.findOrReturn(i,r))}findPosParam(t,n,r){const a=r[n.path.substring(1)];if(!a)throw new ce(4001,!1);return a}findOrReturn(t,n){let r=0;for(const a of n){if(a.path===t.path)return n.splice(r),a;r++}return t}}const Hk={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Zge(e,t,n,r,a){const i=Gk(e,t,n);return i.matched?(r=function pge(e,t){return e.providers&&!e._injector&&(e._injector=kw(e.providers,t,`Route: ${e.path}`)),e._injector??t}(t,r),function Gge(e,t,n,r){const a=t.canMatch;return a&&0!==a.length?We(a.map(s=>{const o=Kh(s,e);return Vo(function Oge(e){return e&&Xg(e.canMatch)}(o)?o.canMatch(t,n):ts(e,()=>o(t,n)))})).pipe(Xh(),yj()):We(!0)}(r,t,n).pipe($t(s=>!0===s?i:{...Hk}))):We(i)}function Gk(e,t,n){if("**"===t.path)return function Yge(e){return{matched:!0,parameters:e.length>0?z4(e).parameters:{},consumedSegments:e,remainingSegments:[],positionalParamSegments:{}}}(n);if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?{...Hk}:{matched:!0,consumedSegments:[],remainingSegments:n,parameters:{},positionalParamSegments:{}};const a=(t.matcher||Dme)(n,e,t);if(!a)return{...Hk};const i={};Object.entries(a.posParams??{}).forEach(([o,l])=>{i[o]=l.path});const s=a.consumed.length>0?{...i,...a.consumed[a.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:a.consumed,remainingSegments:n.slice(a.consumed.length),parameters:s,positionalParamSegments:a.posParams??{}}}function vj(e,t,n,r){return n.length>0&&function eye(e,t,n){return n.some(r=>qx(e,t,r)&&zi(r)!==at)}(e,n,r)?{segmentGroup:new Ht(t,Jge(r,new Ht(n,e.children))),slicedSegments:[]}:0===n.length&&function tye(e,t,n){return n.some(r=>qx(e,t,r))}(e,n,r)?{segmentGroup:new Ht(e.segments,Qge(e,n,r,e.children)),slicedSegments:n}:{segmentGroup:new Ht(e.segments,e.children),slicedSegments:n}}function Qge(e,t,n,r){const a={};for(const i of n)if(qx(e,t,i)&&!r[zi(i)]){const s=new Ht([],{});a[zi(i)]=s}return{...r,...a}}function Jge(e,t){const n={};n[at]=t;for(const r of e)if(""===r.path&&zi(r)!==at){const a=new Ht([],{});n[zi(r)]=a}return n}function qx(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}class aye{}class oye{constructor(t,n,r,a,i,s,o){this.injector=t,this.configLoader=n,this.rootComponentType=r,this.config=a,this.urlTree=i,this.paramsInheritanceStrategy=s,this.urlSerializer=o,this.applyRedirects=new Xge(this.urlSerializer,this.urlTree),this.absoluteRedirectCount=0,this.allowRedirects=!0}noMatchError(t){return new ce(4002,`'${t.segmentGroup}'`)}recognize(){const t=vj(this.urlTree.root,[],[],this.config).segmentGroup;return this.match(t).pipe($t(({children:n,rootSnapshot:r})=>{const a=new Bi(r,n),i=new lj("",a),s=function Zme(e,t,n=null,r=null){return Y4(Z4(e),t,n,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return s.queryParams=this.urlTree.queryParams,i.url=this.urlSerializer.serialize(s),{state:i,tree:s}}))}match(t){const n=new Vx([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,Object.freeze({}),at,this.rootComponentType,null,{});return this.processSegmentGroup(this.injector,this.config,t,at,n).pipe($t(r=>({children:r,rootSnapshot:n})),Uh(r=>{if(r instanceof Gx)return this.urlTree=r.urlTree,this.match(r.urlTree.root);throw r instanceof jk?this.noMatchError(r):r}))}processSegmentGroup(t,n,r,a,i){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,n,r,i):this.processSegment(t,n,r,r.segments,a,!0,i).pipe($t(s=>s instanceof Bi?[s]:[]))}processChildren(t,n,r,a){const i=[];for(const s of Object.keys(r.children))"primary"===s?i.unshift(s):i.push(s);return Ir(i).pipe(Pg(s=>{const o=r.children[s],l=function yge(e,t){const n=e.filter(r=>zi(r)===t);return n.push(...e.filter(r=>zi(r)!==t)),n}(n,s);return this.processSegmentGroup(t,l,o,s,a)}),function Cme(e,t){return vr(function _me(e,t,n,r,a){return(i,s)=>{let o=n,l=t,u=0;i.subscribe(ur(s,c=>{const h=u++;l=o?e(l,c,h):(o=!0,c),r&&s.next(l)},a&&(()=>{o&&s.next(l),s.complete()})))}}(e,t,arguments.length>=2,!0))}((s,o)=>(s.push(...o),s)),Tx(null),function Eme(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Bo((a,i)=>e(a,i,r)):Wl,kk(1),n?Tx(t):P4(()=>new kx))}(),Rr(s=>{if(null===s)return Zh(r);const o=bj(s);return function lye(e){e.sort((t,n)=>t.value.outlet===at?-1:n.value.outlet===at?1:t.value.outlet.localeCompare(n.value.outlet))}(o),We(o)}))}processSegment(t,n,r,a,i,s,o){return Ir(n).pipe(Pg(l=>this.processSegmentAgainstRoute(l._injector??t,n,l,r,a,i,s,o).pipe(Uh(u=>{if(u instanceof jk)return We(null);throw u}))),yu(l=>!!l),Uh(l=>{if(gj(l))return function rye(e,t,n){return 0===t.length&&!e.children[n]}(r,a,i)?We(new aye):Zh(r);throw l}))}processSegmentAgainstRoute(t,n,r,a,i,s,o,l){return function nye(e,t,n,r){return!!(zi(e)===r||r!==at&&qx(t,n,e))&&Gk(t,e,n).matched}(r,a,i,s)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,a,r,i,s,l):this.allowRedirects&&o?this.expandSegmentAgainstRouteUsingRedirect(t,a,n,r,i,s,l):Zh(a):Zh(a)}expandSegmentAgainstRouteUsingRedirect(t,n,r,a,i,s,o){const{matched:l,parameters:u,consumedSegments:c,positionalParamSegments:h,remainingSegments:d}=Gk(n,a,i);if(!l)return Zh(n);"string"==typeof a.redirectTo&&"/"===a.redirectTo[0]&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>31&&(this.allowRedirects=!1));const p=new Vx(i,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,wj(a),zi(a),a.component??a._loadedComponent??null,a,xj(a)),f=Bx(p,o,this.paramsInheritanceStrategy);p.params=Object.freeze(f.params),p.data=Object.freeze(f.data);const m=this.applyRedirects.applyRedirectCommands(c,a.redirectTo,h,p,t);return this.applyRedirects.lineralizeSegments(a,m).pipe(Rr(g=>this.processSegment(t,r,n,g.concat(d),s,!1,o)))}matchSegmentAgainstRoute(t,n,r,a,i,s){const o=Zge(n,r,a,t);return"**"===r.path&&(n.children={}),o.pipe(hs(l=>l.matched?this.getChildConfig(t=r._injector??t,r,a).pipe(hs(({routes:u})=>{const c=r._loadedInjector??t,{parameters:h,consumedSegments:d,remainingSegments:p}=l,f=new Vx(d,h,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,wj(r),zi(r),r.component??r._loadedComponent??null,r,xj(r)),m=Bx(f,s,this.paramsInheritanceStrategy);f.params=Object.freeze(m.params),f.data=Object.freeze(m.data);const{segmentGroup:g,slicedSegments:y}=vj(n,d,p,u);if(0===y.length&&g.hasChildren())return this.processChildren(c,u,g,f).pipe($t(b=>new Bi(f,b)));if(0===u.length&&0===y.length)return We(new Bi(f,[]));const v=zi(r)===i;return this.processSegment(c,u,g,y,v?at:i,!0,f).pipe($t(b=>new Bi(f,b instanceof Bi?[b]:[])))})):Zh(n)))}getChildConfig(t,n,r){return n.children?We({routes:n.children,injector:t}):n.loadChildren?void 0!==n._loadedRoutes?We({routes:n._loadedRoutes,injector:n._loadedInjector}):function Hge(e,t,n,r){const a=t.canLoad;return void 0===a||0===a.length?We(!0):We(a.map(s=>{const o=Kh(s,e);return Vo(function Age(e){return e&&Xg(e.canLoad)}(o)?o.canLoad(t,n):ts(e,()=>o(t,n)))})).pipe(Xh(),yj())}(t,n,r).pipe(Rr(a=>a?this.configLoader.loadChildren(t,n).pipe(na(i=>{n._loadedRoutes=i.routes,n._loadedInjector=i.injector})):function Kge(e){return Nx(pj(!1,Ha.GuardRejected))}())):We({routes:[],injector:t})}}function uye(e){const t=e.value.routeConfig;return t&&""===t.path}function bj(e){const t=[],n=new Set;for(const r of e){if(!uye(r)){t.push(r);continue}const a=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==a?(a.children.push(...r.children),n.add(a)):t.push(r)}for(const r of n){const a=bj(r.children);t.push(new Bi(r.value,a))}return t.filter(r=>!n.has(r))}function wj(e){return e.data||{}}function xj(e){return e.resolve||{}}function Ij(e){const t=e.children.map(n=>Ij(n)).flat();return[e,...t]}function qk(e){return hs(t=>{const n=e(t);return n?Ir(n).pipe($t(()=>t)):We(t)})}let Sj=(()=>{class e{buildTitle(n){let r,a=n.root;for(;void 0!==a;)r=this.getResolvedTitleForRoute(a)??r,a=a.children.find(i=>i.outlet===at);return r}getResolvedTitleForRoute(n){return n.data[Lg]}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(mye),providedIn:"root"})}return e})(),mye=(()=>{class e extends Sj{constructor(n){super(),this.title=n}updateTitle(n){const r=this.buildTitle(n);void 0!==r&&this.title.setTitle(r)}static#e=this.\u0275fac=function(r){return new(r||e)(ze(xfe))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Yh=new we("",{providedIn:"root",factory:()=>({})});let _j=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275cmp=jd({type:e,selectors:[["ng-component"]],standalone:!0,features:[Oh],decls:1,vars:0,template:function(r,a){1&r&&Oi(0,"router-outlet")},dependencies:[Vk],encapsulation:2})}return e})();function Kk(e){const t=e.children&&e.children.map(Kk),n=t?{...e,children:t}:{...e};return!n.component&&!n.loadComponent&&(t||n.loadChildren)&&n.outlet&&n.outlet!==at&&(n.component=_j),n}const Qh=new we("");let Xk=(()=>{class e{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=ie(PU)}loadComponent(n){if(this.componentLoaders.get(n))return this.componentLoaders.get(n);if(n._loadedComponent)return We(n._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(n);const r=Vo(n.loadComponent()).pipe($t(Cj),na(i=>{this.onLoadEndListener&&this.onLoadEndListener(n),n._loadedComponent=i}),Nk(()=>{this.componentLoaders.delete(n)})),a=new $4(r,()=>new si).pipe(Ek());return this.componentLoaders.set(n,a),a}loadChildren(n,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return We({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const i=function gye(e,t,n,r){return Vo(e.loadChildren()).pipe($t(Cj),Rr(a=>a instanceof qz||Array.isArray(a)?We(a):Ir(t.compileModuleAsync(a))),$t(a=>{r&&r(e);let i,s,o=!1;return Array.isArray(a)?(s=a,!0):(i=a.create(n).injector,s=i.get(Qh,[],{optional:!0,self:!0}).flat()),{routes:s.map(Kk),injector:i}}))}(r,this.compiler,n,this.onLoadEndListener).pipe(Nk(()=>{this.childrenLoaders.delete(r)})),s=new $4(i,()=>new si).pipe(Ek());return this.childrenLoaders.set(r,s),s}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function Cj(e){return function yye(e){return e&&"object"==typeof e&&"default"in e}(e)?e.default:e}let Zk=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(vye),providedIn:"root"})}return e})(),vye=(()=>{class e{shouldProcessUrl(n){return!0}extract(n){return n}merge(n,r){return n}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Ej=new we(""),kj=new we("");function bye(e,t,n){const r=e.get(kj),a=e.get(Wa);return e.get(Et).runOutsideAngular(()=>{if(!a.startViewTransition||r.skipNextTransition)return r.skipNextTransition=!1,new Promise(u=>setTimeout(u));let i;const s=new Promise(u=>{i=u}),o=a.startViewTransition(()=>(i(),function wye(e){return new Promise(t=>{uz({read:()=>setTimeout(t)},{injector:e})})}(e))),{onViewTransitionCreated:l}=r;return l&&ts(e,()=>l({transition:o,from:t,to:n})),s})}const Nj=new we("");let Kx=(()=>{class e{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new si,this.transitionAbortSubject=new si,this.configLoader=ie(Xk),this.environmentInjector=ie(ya),this.urlSerializer=ie(jh),this.rootContexts=ie(Hg),this.location=ie(Ag),this.inputBindingEnabled=null!==ie(Ux,{optional:!0}),this.titleStrategy=ie(Sj),this.options=ie(Yh,{optional:!0})||{},this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlHandlingStrategy=ie(Zk),this.createViewTransition=ie(Ej,{optional:!0}),this.navigationErrorHandler=ie(Nj,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>We(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=a=>this.events.next(new lge(a)),this.configLoader.onLoadStartListener=a=>this.events.next(new oge(a))}complete(){this.transitions?.complete()}handleNavigationRequest(n){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...n,id:r})}setupNavigations(n,r,a){return this.transitions=new oi({id:0,currentUrlTree:r,currentRawUrl:r,extractedUrl:this.urlHandlingStrategy.extract(r),urlAfterRedirects:this.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:()=>{},reject:()=>{},promise:Promise.resolve(!0),source:Wg,restoredState:null,currentSnapshot:a.snapshot,targetSnapshot:null,currentRouterState:a,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(Bo(i=>0!==i.id),$t(i=>({...i,extractedUrl:this.urlHandlingStrategy.extract(i.rawUrl)})),hs(i=>{let s=!1,o=!1;return We(i).pipe(hs(l=>{if(this.navigationId>i.id)return this.cancelNavigationTransition(i,"",Ha.SupersededByNewNavigation),ds;this.currentTransition=i,this.currentNavigation={id:l.id,initialUrl:l.rawUrl,extractedUrl:l.extractedUrl,targetBrowserUrl:"string"==typeof l.extras.browserUrl?this.urlSerializer.parse(l.extras.browserUrl):l.extras.browserUrl,trigger:l.source,extras:l.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null};const u=!n.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl();if(!u&&"reload"!==(l.extras.onSameUrlNavigation??n.onSameUrlNavigation)){const h="";return this.events.next(new Hh(l.id,this.urlSerializer.serialize(l.rawUrl),h,Lx.IgnoredSameUrlNavigation)),l.resolve(!1),ds}if(this.urlHandlingStrategy.shouldProcessUrl(l.rawUrl))return We(l).pipe(hs(h=>{const d=this.transitions?.getValue();return this.events.next(new Px(h.id,this.urlSerializer.serialize(h.extractedUrl),h.source,h.restoredState)),d!==this.transitions?.getValue()?ds:Promise.resolve(h)}),function cye(e,t,n,r,a,i){return Rr(s=>function iye(e,t,n,r,a,i,s="emptyOnly"){return new oye(e,t,n,r,a,s,i).recognize()}(e,t,n,r,s.extractedUrl,a,i).pipe($t(({state:o,tree:l})=>({...s,targetSnapshot:o,urlAfterRedirects:l}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,n.config,this.urlSerializer,this.paramsInheritanceStrategy),na(h=>{i.targetSnapshot=h.targetSnapshot,i.urlAfterRedirects=h.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:h.urlAfterRedirects};const d=new rj(h.id,this.urlSerializer.serialize(h.extractedUrl),this.urlSerializer.serialize(h.urlAfterRedirects),h.targetSnapshot);this.events.next(d)}));if(u&&this.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)){const{id:h,extractedUrl:d,source:p,restoredState:f,extras:m}=l,g=new Px(h,this.urlSerializer.serialize(d),p,f);this.events.next(g);const y=oj(this.rootComponentType).snapshot;return this.currentTransition=i={...l,targetSnapshot:y,urlAfterRedirects:d,extras:{...m,skipLocationChange:!1,replaceUrl:!1}},this.currentNavigation.finalUrl=d,We(i)}{const h="";return this.events.next(new Hh(l.id,this.urlSerializer.serialize(l.extractedUrl),h,Lx.IgnoredByUrlHandlingStrategy)),l.resolve(!1),ds}}),na(l=>{const u=new rge(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);this.events.next(u)}),$t(l=>(this.currentTransition=i={...l,guards:Ege(l.targetSnapshot,l.currentSnapshot,this.rootContexts)},i)),function Pge(e,t){return Rr(n=>{const{targetSnapshot:r,currentSnapshot:a,guards:{canActivateChecks:i,canDeactivateChecks:s}}=n;return 0===s.length&&0===i.length?We({...n,guardsResult:!0}):function Lge(e,t,n,r){return Ir(e).pipe(Rr(a=>function jge(e,t,n,r,a){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?We(i.map(o=>{const l=jg(t)??a,u=Kh(o,l);return Vo(function Fge(e){return e&&Xg(e.canDeactivate)}(u)?u.canDeactivate(e,t,n,r):ts(l,()=>u(e,t,n,r))).pipe(yu())})).pipe(Xh()):We(!0)}(a.component,a.route,n,t,r)),yu(a=>!0!==a,!0))}(s,r,a,e).pipe(Rr(o=>o&&function Dge(e){return"boolean"==typeof e}(o)?function zge(e,t,n,r){return Ir(t).pipe(Pg(a=>Ck(function Vge(e,t){return null!==e&&t&&t(new uge(e)),We(!0)}(a.route.parent,r),function Bge(e,t){return null!==e&&t&&t(new dge(e)),We(!0)}(a.route,r),function Wge(e,t,n){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(s=>function kge(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(s)).filter(s=>null!==s).map(s=>O4(()=>We(s.guards.map(l=>{const u=jg(s.node)??n,c=Kh(l,u);return Vo(function Rge(e){return e&&Xg(e.canActivateChild)}(c)?c.canActivateChild(r,e):ts(u,()=>c(r,e))).pipe(yu())})).pipe(Xh())));return We(i).pipe(Xh())}(e,a.path,n),function Uge(e,t,n){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return We(!0);const a=r.map(i=>O4(()=>{const s=jg(t)??n,o=Kh(i,s);return Vo(function Mge(e){return e&&Xg(e.canActivate)}(o)?o.canActivate(t,e):ts(s,()=>o(t,e))).pipe(yu())}));return We(a).pipe(Xh())}(e,a.route,n))),yu(a=>!0!==a,!0))}(r,i,e,t):We(o)),$t(o=>({...n,guardsResult:o})))})}(this.environmentInjector,l=>this.events.next(l)),na(l=>{if(i.guardsResult=l.guardsResult,l.guardsResult&&"boolean"!=typeof l.guardsResult)throw Wx(0,l.guardsResult);const u=new age(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot,!!l.guardsResult);this.events.next(u)}),Bo(l=>!!l.guardsResult||(this.cancelNavigationTransition(l,"",Ha.GuardRejected),!1)),qk(l=>{if(l.guards.canActivateChecks.length)return We(l).pipe(na(u=>{const c=new ige(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),hs(u=>{let c=!1;return We(u).pipe(function dye(e,t){return Rr(n=>{const{targetSnapshot:r,guards:{canActivateChecks:a}}=n;if(!a.length)return We(n);const i=new Set(a.map(l=>l.route)),s=new Set;for(const l of i)if(!s.has(l))for(const u of Ij(l))s.add(u);let o=0;return Ir(s).pipe(Pg(l=>i.has(l)?function hye(e,t,n,r){const a=e.routeConfig,i=e._resolve;return void 0!==a?.title&&!cj(a)&&(i[Lg]=a.title),function pye(e,t,n,r){const a=Tk(e);if(0===a.length)return We({});const i={};return Ir(a).pipe(Rr(s=>function fye(e,t,n,r){const a=jg(t)??r,i=Kh(e,a);return Vo(i.resolve?i.resolve(t,n):ts(a,()=>i(t,n)))}(e[s],t,n,r).pipe(yu(),na(o=>{if(o instanceof Wk)throw Wx(new Ax,o);i[s]=o}))),kk(1),function kme(e){return $t(()=>e)}(i),Uh(s=>gj(s)?ds:Nx(s)))}(i,e,t,r).pipe($t(s=>(e._resolvedData=s,e.data=Bx(e,e.parent,n).resolve,null)))}(l,r,e,t):(l.data=Bx(l,l.parent,e).resolve,We(void 0))),na(()=>o++),kk(1),Rr(l=>o===s.size?We(n):ds))})}(this.paramsInheritanceStrategy,this.environmentInjector),na({next:()=>c=!0,complete:()=>{c||this.cancelNavigationTransition(u,"",Ha.NoDataFromResolver)}}))}),na(u=>{const c=new sge(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}))}),qk(l=>{const u=c=>{const h=[];c.routeConfig?.loadComponent&&!c.routeConfig._loadedComponent&&h.push(this.configLoader.loadComponent(c.routeConfig).pipe(na(d=>{c.component=d}),$t(()=>{})));for(const d of c.children)h.push(...u(d));return h};return _k(u(l.targetSnapshot.root)).pipe(Tx(null),Vh(1))}),qk(()=>this.afterPreactivation()),hs(()=>{const{currentSnapshot:l,targetSnapshot:u}=i,c=this.createViewTransition?.(this.environmentInjector,l.root,u.root);return c?Ir(c).pipe($t(()=>i)):We(i)}),$t(l=>{const u=function wge(e,t,n){const r=Gg(e,t._root,n?n._root:void 0);return new sj(r,t)}(n.routeReuseStrategy,l.targetSnapshot,l.currentRouterState);return this.currentTransition=i={...l,targetRouterState:u},this.currentNavigation.targetRouterState=u,i}),na(()=>{this.events.next(new Ok)}),((e,t,n,r)=>$t(a=>(new Cge(t,a.targetRouterState,a.currentRouterState,n,r).activate(e),a)))(this.rootContexts,n.routeReuseStrategy,l=>this.events.next(l),this.inputBindingEnabled),Vh(1),na({next:l=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Qs(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects))),this.titleStrategy?.updateTitle(l.targetRouterState.snapshot),l.resolve(!0)},complete:()=>{s=!0}}),function Nme(e){return vr((t,n)=>{Zs(e).subscribe(ur(n,()=>n.complete(),rS)),!n.closed&&t.subscribe(n)})}(this.transitionAbortSubject.pipe(na(l=>{throw l}))),Nk(()=>{!s&&!o&&this.cancelNavigationTransition(i,"",Ha.SupersededByNewNavigation),this.currentTransition?.id===i.id&&(this.currentNavigation=null,this.currentTransition=null)}),Uh(l=>{if(o=!0,fj(l))this.events.next(new xu(i.id,this.urlSerializer.serialize(i.extractedUrl),l.message,l.cancellationCode)),function Sge(e){return fj(e)&&wu(e.url)}(l)?this.events.next(new zx(l.url,l.navigationBehaviorOptions)):i.resolve(!1);else{const u=new Fk(i.id,this.urlSerializer.serialize(i.extractedUrl),l,i.targetSnapshot??void 0);try{const c=ts(this.environmentInjector,()=>this.navigationErrorHandler?.(u));if(c instanceof Wk){const{message:h,cancellationCode:d}=Wx(0,c);this.events.next(new xu(i.id,this.urlSerializer.serialize(i.extractedUrl),h,d)),this.events.next(new zx(c.redirectTo,c.navigationBehaviorOptions))}else{this.events.next(u);const h=n.errorHandler(l);i.resolve(!!h)}}catch(c){this.options.resolveNavigationPromiseOnError?i.resolve(!1):i.reject(c)}}return ds}))}))}cancelNavigationTransition(n,r,a){const i=new xu(n.id,this.urlSerializer.serialize(n.extractedUrl),r,a);this.events.next(i),n.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){const n=this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))),r=this.currentNavigation?.targetBrowserUrl??this.currentNavigation?.extractedUrl;return n.toString()!==r?.toString()&&!this.currentNavigation?.extras.skipLocationChange}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function xye(e){return e!==Wg}let Iye=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(_ye),providedIn:"root"})}return e})();class Sye{shouldDetach(t){return!1}store(t,n){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,n){return t.routeConfig===n.routeConfig}}let _ye=(()=>{class e extends Sye{static#e=this.\u0275fac=(()=>{let n;return function(a){return(n||(n=g_(e)))(a||e)}})();static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),Tj=(()=>{class e{static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:()=>ie(Cye),providedIn:"root"})}return e})(),Cye=(()=>{class e extends Tj{constructor(){super(...arguments),this.location=ie(Ag),this.urlSerializer=ie(jh),this.options=ie(Yh,{optional:!0})||{},this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.urlHandlingStrategy=ie(Zk),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.currentUrlTree=new vu,this.rawUrlTree=this.currentUrlTree,this.currentPageId=0,this.lastSuccessfulId=-1,this.routerState=oj(null),this.stateMemento=this.createStateMemento()}getCurrentUrlTree(){return this.currentUrlTree}getRawUrlTree(){return this.rawUrlTree}restoredState(){return this.location.getState()}get browserPageId(){return"computed"!==this.canceledNavigationResolution?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}getRouterState(){return this.routerState}createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}registerNonRouterCurrentEntryChangeListener(n){return this.location.subscribe(r=>{"popstate"===r.type&&n(r.url,r.state)})}handleRouterEvent(n,r){if(n instanceof Px)this.stateMemento=this.createStateMemento();else if(n instanceof Hh)this.rawUrlTree=r.initialUrl;else if(n instanceof rj){if("eager"===this.urlUpdateStrategy&&!r.extras.skipLocationChange){const a=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl);this.setBrowserUrl(r.targetBrowserUrl??a,r)}}else n instanceof Ok?(this.currentUrlTree=r.finalUrl,this.rawUrlTree=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl),this.routerState=r.targetRouterState,"deferred"===this.urlUpdateStrategy&&!r.extras.skipLocationChange&&this.setBrowserUrl(r.targetBrowserUrl??this.rawUrlTree,r)):n instanceof xu&&(n.code===Ha.GuardRejected||n.code===Ha.NoDataFromResolver)?this.restoreHistory(r):n instanceof Fk?this.restoreHistory(r,!0):n instanceof Qs&&(this.lastSuccessfulId=n.id,this.currentPageId=this.browserPageId)}setBrowserUrl(n,r){const a=n instanceof vu?this.urlSerializer.serialize(n):n;if(this.location.isCurrentPathEqualTo(a)||r.extras.replaceUrl){const s={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(a,"",s)}else{const i={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId+1)};this.location.go(a,"",i)}}restoreHistory(n,r=!1){if("computed"===this.canceledNavigationResolution){const i=this.currentPageId-this.browserPageId;0!==i?this.location.historyGo(i):this.currentUrlTree===n.finalUrl&&0===i&&(this.resetState(n),this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(n),this.resetUrlToCurrentUrlTree())}resetState(n){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n.finalUrl??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(n,r){return"computed"===this.canceledNavigationResolution?{navigationId:n,\u0275routerPageId:r}:{navigationId:n}}static#e=this.\u0275fac=(()=>{let n;return function(a){return(n||(n=g_(e)))(a||e)}})();static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();var Zg=function(e){return e[e.COMPLETE=0]="COMPLETE",e[e.FAILED=1]="FAILED",e[e.REDIRECTING=2]="REDIRECTING",e}(Zg||{});function Dj(e,t){e.events.pipe(Bo(n=>n instanceof Qs||n instanceof xu||n instanceof Fk||n instanceof Hh),$t(n=>n instanceof Qs||n instanceof Hh?Zg.COMPLETE:n instanceof xu&&(n.code===Ha.Redirect||n.code===Ha.SupersededByNewNavigation)?Zg.REDIRECTING:Zg.FAILED),Bo(n=>n!==Zg.REDIRECTING),Vh(1)).subscribe(()=>{t()})}function Eye(e){throw e}const kye={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Nye={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let ms=(()=>{class e{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}constructor(){this.disposed=!1,this.console=ie(EU),this.stateManager=ie(Tj),this.options=ie(Yh,{optional:!0})||{},this.pendingTasks=ie(tu),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.navigationTransitions=ie(Kx),this.urlSerializer=ie(jh),this.location=ie(Ag),this.urlHandlingStrategy=ie(Zk),this._events=new si,this.errorHandler=this.options.errorHandler||Eye,this.navigated=!1,this.routeReuseStrategy=ie(Iye),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.config=ie(Qh,{optional:!0})?.flat()??[],this.componentInputBindingEnabled=!!ie(Ux,{optional:!0}),this.eventsSubscription=new Hr,this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe({error:n=>{this.console.warn(n)}}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){const n=this.navigationTransitions.events.subscribe(r=>{try{const a=this.navigationTransitions.currentTransition,i=this.navigationTransitions.currentNavigation;if(null!==a&&null!==i)if(this.stateManager.handleRouterEvent(r,i),r instanceof xu&&r.code!==Ha.Redirect&&r.code!==Ha.SupersededByNewNavigation)this.navigated=!0;else if(r instanceof Qs)this.navigated=!0;else if(r instanceof zx){const s=r.navigationBehaviorOptions,o=this.urlHandlingStrategy.merge(r.url,a.currentRawUrl),l={browserUrl:a.extras.browserUrl,info:a.extras.info,skipLocationChange:a.extras.skipLocationChange,replaceUrl:a.extras.replaceUrl||"eager"===this.urlUpdateStrategy||xye(a.source),...s};this.scheduleNavigation(o,Wg,null,l,{resolve:a.resolve,reject:a.reject,promise:a.promise})}(function Dye(e){return!(e instanceof Ok||e instanceof zx)})(r)&&this._events.next(r)}catch(a){this.navigationTransitions.transitionAbortSubject.next(a)}});this.eventsSubscription.add(n)}resetRootComponentType(n){this.routerState.root.component=n,this.navigationTransitions.rootComponentType=n}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),Wg,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((n,r)=>{setTimeout(()=>{this.navigateToSyncWithBrowser(n,"popstate",r)},0)})}navigateToSyncWithBrowser(n,r,a){const i={replaceUrl:!0},s=a?.navigationId?a:null;if(a){const l={...a};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(i.state=l)}const o=this.parseUrl(n);this.scheduleNavigation(o,r,s,i)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(n){this.config=n.map(Kk),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription&&(this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(n,r={}){const{relativeTo:a,queryParams:i,fragment:s,queryParamsHandling:o,preserveFragment:l}=r,u=l?this.currentUrlTree.fragment:s;let h,c=null;switch(o){case"merge":c={...this.currentUrlTree.queryParams,...i};break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=i||null}null!==c&&(c=this.removeEmptyProps(c));try{h=Z4(a?a.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof n[0]||"/"!==n[0][0])&&(n=[]),h=this.currentUrlTree.root}return Y4(h,n,c,u??null)}navigateByUrl(n,r={skipLocationChange:!1}){const a=wu(n)?n:this.parseUrl(n),i=this.urlHandlingStrategy.merge(a,this.rawUrlTree);return this.scheduleNavigation(i,Wg,null,r)}navigate(n,r={skipLocationChange:!1}){return function Tye(e){for(let t=0;t<e.length;t++)if(null==e[t])throw new ce(4008,!1)}(n),this.navigateByUrl(this.createUrlTree(n,r),r)}serializeUrl(n){return this.urlSerializer.serialize(n)}parseUrl(n){try{return this.urlSerializer.parse(n)}catch{return this.urlSerializer.parse("/")}}isActive(n,r){let a;if(a=!0===r?{...kye}:!1===r?{...Nye}:r,wu(n))return V4(this.currentUrlTree,n,a);const i=this.parseUrl(n);return V4(this.currentUrlTree,i,a)}removeEmptyProps(n){return Object.entries(n).reduce((r,[a,i])=>(null!=i&&(r[a]=i),r),{})}scheduleNavigation(n,r,a,i,s){if(this.disposed)return Promise.resolve(!1);let o,l,u;s?(o=s.resolve,l=s.reject,u=s.promise):u=new Promise((h,d)=>{o=h,l=d});const c=this.pendingTasks.add();return Dj(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(c))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:a,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:n,extras:i,resolve:o,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(h=>Promise.reject(h))}static#e=this.\u0275fac=function(r){return new(r||e)};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),Xx=(()=>{class e{constructor(n,r,a,i,s,o){this.router=n,this.route=r,this.tabIndexAttribute=a,this.renderer=i,this.el=s,this.locationStrategy=o,this.href=null,this.onChanges=new si,this.preserveFragment=!1,this.skipLocationChange=!1,this.replaceUrl=!1,this.routerLinkInput=null;const l=s.nativeElement.tagName?.toLowerCase();this.isAnchorElement="a"===l||"area"===l,this.isAnchorElement?this.subscription=n.events.subscribe(u=>{u instanceof Qs&&this.updateHref()}):this.setTabIndexIfNotOnNativeEl("0")}setTabIndexIfNotOnNativeEl(n){null!=this.tabIndexAttribute||this.isAnchorElement||this.applyAttributeValue("tabindex",n)}ngOnChanges(n){this.isAnchorElement&&this.updateHref(),this.onChanges.next(this)}set routerLink(n){null==n?(this.routerLinkInput=null,this.setTabIndexIfNotOnNativeEl(null)):(this.routerLinkInput=wu(n)||Array.isArray(n)?n:[n],this.setTabIndexIfNotOnNativeEl("0"))}onClick(n,r,a,i,s){const o=this.urlTree;return!!(null===o||this.isAnchorElement&&(0!==n||r||a||i||s||"string"==typeof this.target&&"_self"!=this.target))||(this.router.navigateByUrl(o,{skipLocationChange:this.skipLocationChange,replaceUrl:this.replaceUrl,state:this.state,info:this.info}),!this.isAnchorElement)}ngOnDestroy(){this.subscription?.unsubscribe()}updateHref(){const n=this.urlTree;this.href=null!==n&&this.locationStrategy?this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(n)):null;const r=null===this.href?null:function jL(e,t,n){return function yre(e,t){return"src"===t&&("embed"===e||"frame"===e||"iframe"===e||"media"===e||"script"===e)||"href"===t&&("base"===e||"link"===e)?WL:UL}(t,n)(e)}(this.href,this.el.nativeElement.tagName.toLowerCase(),"href");this.applyAttributeValue("href",r)}applyAttributeValue(n,r){const a=this.renderer,i=this.el.nativeElement;null!==r?a.setAttribute(i,n,r):a.removeAttribute(i,n)}get urlTree(){return null===this.routerLinkInput?null:wu(this.routerLinkInput)?this.routerLinkInput:this.router.createUrlTree(this.routerLinkInput,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:this.preserveFragment})}static#e=this.\u0275fac=function(r){return new(r||e)(Ue(ms),Ue(qh),function Fm(e){return function Vte(e,t){if("class"===t)return e.classes;if("style"===t)return e.styles;const n=e.attrs;if(n){const r=n.length;let a=0;for(;a<r;){const i=n[a];if(M$(i))break;if(0===i)a+=2;else if("number"==typeof i)for(a++;a<r&&"string"==typeof n[a];)a++;else{if(i===t)return n[a+1];a+=2}}}return null}(Lt(),e)}("tabindex"),Ue(xw),Ue(Do),Ue(mu))};static#t=this.\u0275dir=Gr({type:e,selectors:[["","routerLink",""]],hostVars:1,hostBindings:function(r,a){1&r&&Uw("click",function(s){return a.onClick(s.button,s.ctrlKey,s.shiftKey,s.altKey,s.metaKey)}),2&r&&tE("target",a.target)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",state:"state",info:"info",relativeTo:"relativeTo",preserveFragment:[2,"preserveFragment","preserveFragment",GE],skipLocationChange:[2,"skipLocationChange","skipLocationChange",GE],replaceUrl:[2,"replaceUrl","replaceUrl",GE],routerLink:"routerLink"},standalone:!0,features:[Gz,Xl]})}return e})();class Aj{}let Rye=(()=>{class e{constructor(n,r,a,i,s){this.router=n,this.injector=a,this.preloadingStrategy=i,this.loader=s}setUpPreloading(){this.subscription=this.router.events.pipe(Bo(n=>n instanceof Qs),Pg(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(n,r){const a=[];for(const i of r){i.providers&&!i._injector&&(i._injector=kw(i.providers,n,`Route: ${i.path}`));const s=i._injector??n,o=i._loadedInjector??s;(i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent)&&a.push(this.preloadConfig(s,i)),(i.children||i._loadedRoutes)&&a.push(this.processRoutes(o,i.children??i._loadedRoutes))}return Ir(a).pipe($g())}preloadConfig(n,r){return this.preloadingStrategy.preload(r,()=>{let a;a=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(n,r):We(null);const i=a.pipe(Rr(s=>null===s?We(void 0):(r._loadedRoutes=s.routes,r._loadedInjector=s.injector,this.processRoutes(s.injector??n,s.routes))));return r.loadComponent&&!r._loadedComponent?Ir([i,this.loader.loadComponent(r)]).pipe($g()):i})}static#e=this.\u0275fac=function(r){return new(r||e)(ze(ms),ze(PU),ze(ya),ze(Aj),ze(Xk))};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Yk=new we("");let Mj=(()=>{class e{constructor(n,r,a,i,s={}){this.urlSerializer=n,this.transitions=r,this.viewportScroller=a,this.zone=i,this.options=s,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},s.scrollPositionRestoration||="disabled",s.anchorScrolling||="disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(n=>{n instanceof Px?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=n.navigationTrigger,this.restoredId=n.restoredState?n.restoredState.navigationId:0):n instanceof Qs?(this.lastId=n.id,this.scheduleScrollEvent(n,this.urlSerializer.parse(n.urlAfterRedirects).fragment)):n instanceof Hh&&n.code===Lx.IgnoredSameUrlNavigation&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(n,this.urlSerializer.parse(n.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(n=>{n instanceof aj&&(n.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(n.position):n.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(n.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(n,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new aj(n,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}static#e=this.\u0275fac=function(r){!function m3(){throw new Error("invalid")}()};static#t=this.\u0275prov=Ne({token:e,factory:e.\u0275fac})}return e})();function Rj(e){return e.routerState.root}function gs(e,t){return{\u0275kind:e,\u0275providers:t}}function Fj(){const e=ie(Pn);return t=>{const n=e.get($i);if(t!==n.components[0])return;const r=e.get(ms),a=e.get(Oj);1===e.get(Qk)&&r.initialNavigation(),e.get($j,null,pt.Optional)?.setUpPreloading(),e.get(Yk,null,pt.Optional)?.init(),r.resetRootComponentType(n.componentTypes[0]),a.closed||(a.next(),a.complete(),a.unsubscribe())}}const Oj=new we("",{factory:()=>new si}),Qk=new we("",{providedIn:"root",factory:()=>1}),$j=new we("");function Lye(e){return gs(0,[{provide:$j,useExisting:Rye},{provide:Aj,useExisting:e}])}function Bye(e){return gs(9,[{provide:Ej,useValue:bye},{provide:kj,useValue:{skipNextTransition:!!e?.skipInitialTransition,...e}}])}const Pj=new we("ROUTER_FORROOT_GUARD"),Vye=[Ag,{provide:jh,useClass:Ax},ms,Hg,{provide:qh,useFactory:Rj,deps:[ms]},Xk,[]];let Uye=(()=>{class e{constructor(n){}static forRoot(n,r){return{ngModule:e,providers:[Vye,[],{provide:Qh,multi:!0,useValue:n},{provide:Pj,useFactory:Gye,deps:[[ms,new fb,new mb]]},{provide:Yh,useValue:r||{}},r?.useHash?{provide:mu,useClass:Jde}:{provide:mu,useClass:AW},{provide:Yk,useFactory:()=>{const e=ie(vpe),t=ie(Et),n=ie(Yh),r=ie(Kx),a=ie(jh);return n.scrollOffset&&e.setOffset(n.scrollOffset),new Mj(a,r,e,t,n)}},r?.preloadingStrategy?Lye(r.preloadingStrategy).\u0275providers:[],r?.initialNavigation?qye(r):[],r?.bindToComponentInputs?gs(8,[dj,{provide:Ux,useExisting:dj}]).\u0275providers:[],r?.enableViewTransitions?Bye().\u0275providers:[],[{provide:Lj,useFactory:Fj},{provide:Eg,multi:!0,useExisting:Lj}]]}}static forChild(n){return{ngModule:e,providers:[{provide:Qh,multi:!0,useValue:n}]}}static#e=this.\u0275fac=function(r){return new(r||e)(ze(Pj,8))};static#t=this.\u0275mod=wb({type:e});static#n=this.\u0275inj=mm({})}return e})();function Gye(e){return"guarded"}function qye(e){return["disabled"===e.initialNavigation?gs(3,[{provide:AE,multi:!0,useFactory:()=>{const t=ie(ms);return()=>{t.setUpLocationChangeListener()}}},{provide:Qk,useValue:2}]).\u0275providers:[],"enabledBlocking"===e.initialNavigation?gs(2,[{provide:Qk,useValue:0},{provide:AE,multi:!0,deps:[Pn],useFactory:t=>{const n=t.get(Yde,Promise.resolve());return()=>n.then(()=>new Promise(r=>{const a=t.get(ms),i=t.get(Oj);Dj(a,()=>{r(!0)}),t.get(Kx).afterPreactivation=()=>(r(!0),i.closed?We(void 0):i),a.initialNavigation()}))}}]).\u0275providers:[]]}const Lj=new we("");let Xye=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275cmp=jd({type:e,selectors:[["app-footer"]],standalone:!0,features:[Oh],decls:4,vars:0,consts:[[1,"footer"],["xmlns","http://www.w3.org/2000/svg","width","16","height","16","fill","currentColor","viewBox","0 0 16 16",1,"bi","bi-tools"],["d","M1 0 0 1l2.2 3.081a1 1 0 0 0 .815.419h.07a1 1 0 0 1 .708.293l2.675 2.675-2.617 2.654A3.003 3.003 0 0 0 0 13a3 3 0 1 0 5.878-.851l2.654-2.617.968.968-.305.914a1 1 0 0 0 .242 1.023l3.27 3.27a.997.997 0 0 0 1.414 0l1.586-1.586a.997.997 0 0 0 0-1.414l-3.27-3.27a1 1 0 0 0-1.023-.242L10.5 9.5l-.96-.96 2.68-2.643A3.005 3.005 0 0 0 16 3q0-.405-.102-.777l-2.14 2.141L12 4l-.364-1.757L13.777.102a3 3 0 0 0-3.675 3.68L7.462 6.46 4.793 3.793a1 1 0 0 1-.293-.707v-.071a1 1 0 0 0-.419-.814zm9.646 10.646a.5.5 0 0 1 .708 0l2.914 2.915a.5.5 0 0 1-.707.707l-2.915-2.914a.5.5 0 0 1 0-.708M3 11l.471.242.529.026.287.445.445.287.026.529L5 13l-.242.471-.026.529-.445.287-.287.445-.529.026L3 15l-.471-.242L2 14.732l-.287-.445L1.268 14l-.026-.529L1 13l.242-.471.026-.529.445-.287.287-.445.529-.026z"]],template:function(r,a){1&r&&(Ar(0,"footer",0),l_(),Ar(1,"svg",1),Oi(2,"path",2),Mr(),Fh(3," by Sneha Sadaphule "),Mr())},styles:[".footer[_ngcontent-%COMP%]{width:100%;padding:5px 20px;background-color:#f0f0f0;color:#333;text-align:center;position:sticky;bottom:0;box-shadow:0 -2px 5px #0000001a}"]})}return e})(),Zye=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275cmp=jd({type:e,selectors:[["app-root"]],standalone:!0,features:[Oh],decls:20,vars:0,consts:[[1,"navbar","navbar-expand-lg","navbar-light","bg-light"],["href","#",1,"navbar-brand"],["type","button","data-toggle","collapse","data-target","#navbarNav","aria-controls","navbarNav","aria-expanded","false","aria-label","Toggle navigation",1,"navbar-toggler"],[1,"navbar-toggler-icon"],["id","navbarNav",1,"collapse","navbar-collapse"],[1,"navbar-nav","mr-auto"],[1,"nav-item"],["routerLink","/webcam-detection",1,"nav-link"],["routerLink","/image-detection",1,"nav-link"],[1,"navbar-nav","ml-auto"],["href","https://github.com/snehasadap/facial-recognition","target","_blank",1,"nav-link"],["src","https://cdn.jsdelivr.net/npm/simple-icons@v5/icons/github.svg","alt","GitHub",2,"height","24px"],[1,"content-container"]],template:function(r,a){1&r&&(Ar(0,"nav",0)(1,"a",1),Fh(2,"FaceMap"),Mr(),Ar(3,"button",2),Oi(4,"span",3),Mr(),Ar(5,"div",4)(6,"ul",5)(7,"li",6)(8,"a",7),Fh(9,"Webcam Detection"),Mr()(),Ar(10,"li",6)(11,"a",8),Fh(12,"Image Detection"),Mr()()(),Ar(13,"ul",9)(14,"li",6)(15,"a",10),Oi(16,"img",11),Mr()()()()(),Ar(17,"div",12),Oi(18,"router-outlet"),Mr(),Oi(19,"app-footer"))},dependencies:[Uye,Vk,Xx,Xye],encapsulation:2})}return e})();function zj(e,t,n,r,a,i,s){try{var o=e[i](s),l=o.value}catch(u){return void n(u)}o.done?t(l):Promise.resolve(l).then(r,a)}function F(e){return function(){var t=this,n=arguments;return new Promise(function(r,a){var i=e.apply(t,n);function s(l){zj(i,r,a,s,o,"next",l)}function o(l){zj(i,r,a,s,o,"throw",l)}s(void 0)})}}var Yye=Object.defineProperty,Qye=So(291),Jk=(e,t)=>{for(var n in t)Yye(e,n,{get:t[n],enumerable:!0})};Jk({},{Abs:()=>np,Acos:()=>Su,Acosh:()=>_u,AdadeltaOptimizer:()=>aD,AdagradOptimizer:()=>iD,AdamOptimizer:()=>sD,AdamaxOptimizer:()=>oD,Add:()=>Ho,AddN:()=>Cu,All:()=>rp,Any:()=>ap,ArgMax:()=>ip,ArgMin:()=>sp,Asin:()=>Eu,Asinh:()=>ku,Atan:()=>Nu,Atan2:()=>Du,Atanh:()=>Tu,AvgPool:()=>Au,AvgPool3D:()=>op,AvgPool3DGrad:()=>ny,AvgPoolGrad:()=>ty,BackendWasm:()=>ZZ,BatchMatMul:()=>Mu,BatchToSpaceND:()=>lp,Bincount:()=>up,BitwiseAnd:()=>cp,BroadcastArgs:()=>ry,BroadcastTo:()=>tH,Callback:()=>oq,CallbackList:()=>w5,Cast:()=>Ru,Ceil:()=>Fu,ClipByValue:()=>Go,Complex:()=>r0,ComplexAbs:()=>ay,Concat:()=>dp,Conv2D:()=>Ou,Conv2DBackpropFilter:()=>a0,Conv2DBackpropInput:()=>$u,Conv3D:()=>Pu,Conv3DBackpropFilterV2:()=>hp,Conv3DBackpropInputV2:()=>pp,Cos:()=>Lu,Cosh:()=>zu,CropAndResize:()=>mp,Cumprod:()=>fp,Cumsum:()=>Bu,CustomCallback:()=>I5,DataStorage:()=>Yx,DenseBincount:()=>iy,DepthToSpace:()=>gp,DepthwiseConv2dNative:()=>Vu,DepthwiseConv2dNativeBackpropFilter:()=>s0,DepthwiseConv2dNativeBackpropInput:()=>o0,Diag:()=>sy,Dilation2D:()=>Uu,Dilation2DBackpropFilter:()=>vp,Dilation2DBackpropInput:()=>yp,Draw:()=>l0,ENV:()=>aN,EarlyStopping:()=>uq,Einsum:()=>u0,Elu:()=>ju,EluGrad:()=>bp,Environment:()=>Jj,Equal:()=>wp,Erf:()=>Hu,Exp:()=>Gu,ExpandDims:()=>xp,Expm1:()=>qu,FFT:()=>c0,Fill:()=>oy,FlipLeftRight:()=>Ip,Floor:()=>Ku,FloorDiv:()=>Xu,FromPixels:()=>y0,FusedBatchNorm:()=>Zu,FusedConv2D:()=>Uc,FusedDepthwiseConv2D:()=>Wc,GPGPUContext:()=>QI,GatherNd:()=>_p,GatherV2:()=>Sp,GraphModel:()=>qA,Greater:()=>Cp,GreaterEqual:()=>Yu,History:()=>x5,IFFT:()=>d0,Identity:()=>Qu,Imag:()=>h0,InputSpec:()=>Dn,IsFinite:()=>Ju,IsInf:()=>ec,IsNan:()=>tc,KernelBackend:()=>Yg,LRN:()=>ic,LRNGrad:()=>Mp,LayerVariable:()=>s5,LayersModel:()=>ho,LeakyRelu:()=>nc,Less:()=>Ep,LessEqual:()=>kp,LinSpace:()=>Np,Log:()=>rc,Log1p:()=>ac,LogSoftmax:()=>rH,LogicalAnd:()=>Tp,LogicalNot:()=>Dp,LogicalOr:()=>Ap,LogicalXor:()=>nH,LowerBound:()=>jve,MathBackendCPU:()=>nM,MathBackendWebGL:()=>I9,MatrixBandPart:()=>Hve,Max:()=>sc,MaxPool:()=>lc,MaxPool3D:()=>Rp,MaxPool3DGrad:()=>uy,MaxPoolGrad:()=>ly,MaxPoolWithArgmax:()=>cy,Maximum:()=>oc,Mean:()=>uc,Min:()=>cc,Minimum:()=>dc,MirrorPad:()=>hc,Mod:()=>pc,MomentumOptimizer:()=>lD,Multinomial:()=>Fp,Multiply:()=>fc,Neg:()=>Op,NonMaxSuppressionV3:()=>Pp,NonMaxSuppressionV4:()=>Lp,NonMaxSuppressionV5:()=>zp,NotEqual:()=>$p,OP_SCOPE_SUFFIX:()=>wN,OneHot:()=>mc,OnesLike:()=>Bp,Optimizer:()=>lo,OptimizerConstructors:()=>_6,Pack:()=>Vp,PadV2:()=>gc,Pool:()=>Gve,Pow:()=>yc,Prelu:()=>vc,Prod:()=>bc,RMSPropOptimizer:()=>uD,RNN:()=>gl,RaggedGather:()=>p0,RaggedRange:()=>f0,RaggedTensorToTensor:()=>m0,Range:()=>dy,Rank:()=>dN,Real:()=>g0,RealDiv:()=>Wu,Reciprocal:()=>wc,Reduction:()=>Br,Relu:()=>xc,Relu6:()=>_c,Reshape:()=>Up,ResizeBilinear:()=>Sc,ResizeBilinearGrad:()=>jp,ResizeNearestNeighbor:()=>Ic,ResizeNearestNeighborGrad:()=>Wp,Reverse:()=>Cc,RotateWithOffset:()=>sf,Round:()=>Ec,Rsqrt:()=>kc,SGDOptimizer:()=>sI,ScatterNd:()=>Hp,SearchSorted:()=>qp,Select:()=>Kp,Selu:()=>Nc,Sequential:()=>cA,Sigmoid:()=>Mc,Sign:()=>Ac,Sin:()=>Tc,Sinh:()=>Dc,Slice:()=>Xp,Softmax:()=>$c,Softplus:()=>Rc,SpaceToBatchND:()=>Zp,SparseFillEmptyRows:()=>hy,SparseReshape:()=>Qp,SparseSegmentMean:()=>py,SparseSegmentSum:()=>fy,SparseToDense:()=>Jp,SplitV:()=>Yp,Sqrt:()=>Fc,Square:()=>my,SquaredDifference:()=>Pc,StaticRegexReplace:()=>gy,Step:()=>Ko,StridedSlice:()=>ef,StringNGrams:()=>yy,StringSplit:()=>vy,StringToHashBucketFast:()=>by,Sub:()=>Lc,Sum:()=>Oc,SymbolicTensor:()=>qi,Tan:()=>zc,Tanh:()=>Bc,Tensor:()=>Ze,TensorBuffer:()=>En,TensorScatterUpdate:()=>Gp,Tile:()=>qo,TopK:()=>tf,Transform:()=>nf,Transpose:()=>eo,Unique:()=>wy,Unpack:()=>rf,UnsortedSegmentSum:()=>xy,UpperBound:()=>qve,Variable:()=>Gc,ZerosLike:()=>af,_FusedMatMul:()=>Vc,abs:()=>kn,acos:()=>VN,acosh:()=>UN,add:()=>J,addN:()=>PH,all:()=>N0,any:()=>Fy,argMax:()=>Xc,argMin:()=>WN,asin:()=>jN,asinh:()=>HN,atan:()=>GN,atan2:()=>qN,atanh:()=>KN,avgPool:()=>ao,avgPool3d:()=>YN,backend:()=>IN,backend_util:()=>E,basicLSTMCell:()=>VH,batchNorm:()=>Qc,batchNorm2d:()=>QN,batchNorm3d:()=>JN,batchNorm4d:()=>eT,batchToSpaceND:()=>Ly,bincount:()=>tT,bitwiseAnd:()=>UH,booleanMaskAsync:()=>AG,broadcastArgs:()=>WH,broadcastTo:()=>Jc,broadcast_util:()=>mf,browser:()=>Qy,buffer:()=>Je,callbacks:()=>aMe,cast:()=>de,ceil:()=>nT,clipByValue:()=>Sr,clone:()=>vs,complex:()=>to,concat:()=>zt,concat1d:()=>rT,concat2d:()=>aT,concat3d:()=>iT,concat4d:()=>sT,constraints:()=>c5,conv1d:()=>T0,conv2d:()=>Lr,conv2dTranspose:()=>D0,conv3d:()=>lT,conv3dTranspose:()=>uT,copyRegisteredKernels:()=>Yve,cos:()=>zy,cosh:()=>A0,cosineWindow:()=>tI,cumprod:()=>By,cumsum:()=>M0,customGrad:()=>ws,data:()=>Uq,denseBincount:()=>R0,deprecationWarn:()=>xN,depthToSpace:()=>cT,depthwiseConv2d:()=>ed,deregisterOp:()=>oMe,device_util:()=>Ay,diag:()=>HH,dilation2d:()=>dT,disableDeprecationWarnings:()=>Tbe,dispose:()=>He,disposeVariables:()=>Dbe,div:()=>ve,divNoNan:()=>hT,dot:()=>pT,dropout:()=>KT,einsum:()=>td,elu:()=>gf,enableDebugMode:()=>Nbe,enableProdMode:()=>kbe,enclosingPowerOfTwo:()=>XT,engine:()=>fi,ensureShape:()=>qH,env:()=>H,equal:()=>Ca,erf:()=>fT,euclideanNorm:()=>yT,exp:()=>_r,expandDims:()=>nr,expm1:()=>vT,eye:()=>F0,fft:()=>Zy,fill:()=>_a,findBackend:()=>$be,findBackendFactory:()=>Pbe,floor:()=>bf,floorDiv:()=>k0,forceHalfFloat:()=>S9,fused:()=>Nf,gather:()=>wf,gatherND:()=>OG,gather_util:()=>bD,getBackend:()=>xH,getGradient:()=>oN,getKernel:()=>Sy,getKernelsForBackend:()=>v0,getThreadsCount:()=>xZe,gpgpu_util:()=>Z7,grad:()=>m0e,grads:()=>g0e,greater:()=>zr,greaterEqual:()=>so,ifft:()=>kf,imag:()=>Vy,image:()=>Za,inTopKAsync:()=>$G,initializers:()=>g5,input:()=>U5,io:()=>hr,irfft:()=>K0,isFinite:()=>bT,isInf:()=>wT,isNaN:()=>xT,keep:()=>Bn,kernel_impls:()=>_s,layers:()=>y5,leakyRelu:()=>Uy,less:()=>xf,lessEqual:()=>rl,linalg:()=>nD,linspace:()=>QH,loadGraphModel:()=>p2e,loadGraphModelSync:()=>f2e,loadLayersModel:()=>zTe,localResponseNormalization:()=>IT,log:()=>ka,log1p:()=>Wy,logSigmoid:()=>ST,logSoftmax:()=>$0,logSumExp:()=>jy,logicalAnd:()=>gi,logicalNot:()=>Hy,logicalOr:()=>P0,logicalXor:()=>_T,losses:()=>ZG,lowerBound:()=>eG,matMul:()=>et,math:()=>u6,max:()=>Ka,maxPool:()=>rr,maxPool3d:()=>CT,maxPoolWithArgmax:()=>tG,maximum:()=>xs,mean:()=>fn,memory:()=>_0,meshgrid:()=>nG,metrics:()=>aq,min:()=>yf,minimum:()=>al,mirrorPad:()=>ET,mod:()=>kT,model:()=>UTe,models:()=>iq,moments:()=>Gy,movingAverage:()=>MG,mul:()=>z,multiRNNCell:()=>rG,multinomial:()=>aG,neg:()=>Yt,nextFrame:()=>xD,norm:()=>vf,notEqual:()=>ad,oneHot:()=>If,ones:()=>aa,onesLike:()=>Na,op:()=>L,outerProduct:()=>iG,pad:()=>Wi,pad1d:()=>sG,pad2d:()=>oG,pad3d:()=>lG,pad4d:()=>uG,pool:()=>NT,pow:()=>io,prelu:()=>Ky,print:()=>BN,prod:()=>TT,profile:()=>Abe,raggedGather:()=>cG,raggedRange:()=>dG,raggedTensorToTensor:()=>hG,rand:()=>pG,randomGamma:()=>yG,randomNormal:()=>B0,randomStandardNormal:()=>vG,randomUniform:()=>il,randomUniformInt:()=>bG,range:()=>id,ready:()=>Fbe,real:()=>Sf,reciprocal:()=>$T,registerBackend:()=>C0,registerCallbackConstructor:()=>jTe,registerGradient:()=>aH,registerKernel:()=>_y,registerOp:()=>sMe,regularizers:()=>sq,relu:()=>Rt,relu6:()=>V0,removeBackend:()=>Obe,reshape:()=>B,reverse:()=>Xa,reverse1d:()=>wG,reverse2d:()=>xG,reverse3d:()=>IG,reverse4d:()=>SG,rfft:()=>Yy,round:()=>U0,rsqrt:()=>W0,scalar:()=>ke,scatterND:()=>RG,scatter_util:()=>Y0,searchSorted:()=>z0,selu:()=>j0,separableConv2d:()=>_f,sequential:()=>WTe,serialization:()=>ae,setBackend:()=>Rbe,setPlatform:()=>Lbe,setThreadsCount:()=>wZe,setWasmPath:()=>vZe,setWasmPaths:()=>bZe,setWebGLContext:()=>v7,setdiff1dAsync:()=>_G,shared:()=>rM,sigmoid:()=>mi,sign:()=>LT,signal:()=>XG,sin:()=>H0,sinh:()=>G0,slice:()=>ct,slice1d:()=>Xy,slice2d:()=>q0,slice3d:()=>Cf,slice4d:()=>Ef,slice_util:()=>Vn,softmax:()=>sl,softplus:()=>rd,spaceToBatchND:()=>qy,sparse:()=>YG,sparseToDense:()=>FG,spectral:()=>KG,split:()=>ia,sqrt:()=>dr,square:()=>Vt,squaredDifference:()=>X0,squeeze:()=>ol,stack:()=>Tn,step:()=>sd,stridedSlice:()=>zT,string:()=>QG,sub:()=>ye,sum:()=>xe,sumOutType:()=>S0,tan:()=>BT,tanh:()=>Yc,tensor:()=>$r,tensor1d:()=>Tt,tensor2d:()=>Is,tensor3d:()=>Z0,tensor4d:()=>ll,tensor5d:()=>CG,tensor6d:()=>EG,tensorScatterUpdate:()=>NG,tensor_util:()=>Ui,test_util:()=>fG,tidy:()=>V,tile:()=>Ea,time:()=>Mbe,topk:()=>UT,train:()=>ld,transpose:()=>tt,truncatedNormal:()=>J0,unique:()=>WT,unregisterGradient:()=>Zve,unregisterKernel:()=>Xve,unsortedSegmentSum:()=>eI,unstack:()=>vn,upcastType:()=>Ga,upperBound:()=>TG,util:()=>I,valueAndGrad:()=>y0e,valueAndGrads:()=>v0e,variable:()=>jT,variableGrads:()=>JH,version:()=>NZe,version_converter:()=>g2e,version_core:()=>U_e,version_cpu:()=>yFe,version_layers:()=>JD,version_wasm:()=>IZe,version_webgl:()=>sVe,webgl:()=>oVe,webgl_util:()=>y7,where:()=>tr,whereAsync:()=>GT,zeros:()=>mn,zerosLike:()=>ft});var eve=Object.create,eN=Object.defineProperty,tve=Object.getOwnPropertyDescriptor,nve=Object.getOwnPropertyNames,rve=Object.getPrototypeOf,ave=Object.prototype.hasOwnProperty,Cn=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),je=(e,t)=>{for(var n in t)eN(e,n,{get:t[n],enumerable:!0})},Uo=(e,t,n)=>(n=null!=e?eve(rve(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of nve(t))!ave.call(e,a)&&undefined!==a&&eN(e,a,{get:()=>t[a],enumerable:!(r=tve(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:eN(n,"default",{value:e,enumerable:!0}),e)),sve=Cn((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(_,$,U){this.low=0|_,this.high=0|$,this.unsigned=!!U}function a(_){return!0===(_&&_.__isLong__)}Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var i={},s={};function o(_,$){var U,j,G;return $?(G=0<=(_>>>=0)&&_<256)&&(j=s[_])?j:(U=u(_,(0|_)<0?-1:0,!0),G&&(s[_]=U),U):(G=-128<=(_|=0)&&_<128)&&(j=i[_])?j:(U=u(_,_<0?-1:0,!1),G&&(i[_]=U),U)}function l(_,$){if(isNaN(_))return $?w:b;if($){if(_<0)return w;if(_>=g)return A}else{if(_<=-y)return R;if(_+1>=y)return T}return _<0?l(-_,$).neg():u(_%m|0,_/m|0,$)}function u(_,$,U){return new r(_,$,U)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function h(_,$,U){if(0===_.length)throw Error("empty string");if("NaN"===_||"Infinity"===_||"+Infinity"===_||"-Infinity"===_)return b;if("number"==typeof $?(U=$,$=!1):$=!!$,(U=U||10)<2||36<U)throw RangeError("radix");var j;if((j=_.indexOf("-"))>0)throw Error("interior hyphen");if(0===j)return h(_.substring(1),$,U).neg();for(var G=l(c(U,8)),K=b,X=0;X<_.length;X+=8){var Y=Math.min(8,_.length-X),ee=parseInt(_.substring(X,X+Y),U);if(Y<8){var te=l(c(U,Y));K=K.mul(te).add(l(ee))}else K=(K=K.mul(G)).add(l(ee))}return K.unsigned=$,K}function d(_,$){return"number"==typeof _?l(_,$):"string"==typeof _?h(_,$):u(_.low,_.high,"boolean"==typeof $?$:_.unsigned)}r.fromString=h,r.fromValue=d;var m=4294967296,g=m*m,y=g/2,v=o(1<<24),b=o(0);r.ZERO=b;var w=o(0,!0);r.UZERO=w;var x=o(1);r.ONE=x;var C=o(1,!0);r.UONE=C;var k=o(-1);r.NEG_ONE=k;var T=u(-1,2147483647,!1);r.MAX_VALUE=T;var A=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var R=u(0,-2147483648,!1);r.MIN_VALUE=R;var M=r.prototype;M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},M.toString=function(_){if((_=_||10)<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(R)){var $=l(_),U=this.div($),j=U.mul($).sub(this);return U.toString(_)+j.toInt().toString(_)}return"-"+this.neg().toString(_)}for(var G=l(c(_,6),this.unsigned),K=this,X="";;){var Y=K.div(G),te=(K.sub(Y.mul(G)).toInt()>>>0).toString(_);if((K=Y).isZero())return te+X;for(;te.length<6;)te="0"+te;X=""+te+X}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var _=0!=this.high?this.high:this.low,$=31;$>0&&!(_&1<<$);$--);return 0!=this.high?$+33:$+1},M.isZero=function(){return 0===this.high&&0===this.low},M.eqz=M.isZero,M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return!(1&~this.low)},M.isEven=function(){return!(1&this.low)},M.equals=function(_){return a(_)||(_=d(_)),(this.unsigned===_.unsigned||this.high>>>31!=1||_.high>>>31!=1)&&this.high===_.high&&this.low===_.low},M.eq=M.equals,M.notEquals=function(_){return!this.eq(_)},M.neq=M.notEquals,M.ne=M.notEquals,M.lessThan=function(_){return this.comp(_)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(_){return this.comp(_)<=0},M.lte=M.lessThanOrEqual,M.le=M.lessThanOrEqual,M.greaterThan=function(_){return this.comp(_)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(_){return this.comp(_)>=0},M.gte=M.greaterThanOrEqual,M.ge=M.greaterThanOrEqual,M.compare=function(_){if(a(_)||(_=d(_)),this.eq(_))return 0;var $=this.isNegative(),U=_.isNegative();return $&&!U?-1:!$&&U?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(x)},M.neg=M.negate,M.add=function(_){a(_)||(_=d(_));var te=0,se=0,re=0,oe=0;return re+=(oe+=(65535&this.low)+(65535&_.low))>>>16,se+=(re+=(this.low>>>16)+(_.low>>>16))>>>16,te+=(se+=(65535&this.high)+(65535&_.high))>>>16,te+=(this.high>>>16)+(_.high>>>16),u((re&=65535)<<16|(oe&=65535),(te&=65535)<<16|(se&=65535),this.unsigned)},M.subtract=function(_){return a(_)||(_=d(_)),this.add(_.neg())},M.sub=M.subtract,M.multiply=function(_){if(this.isZero())return b;if(a(_)||(_=d(_)),n)return u(n.mul(this.low,this.high,_.low,_.high),n.get_high(),this.unsigned);if(_.isZero())return b;if(this.eq(R))return _.isOdd()?R:b;if(_.eq(R))return this.isOdd()?R:b;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return l(this.toNumber()*_.toNumber(),this.unsigned);var j=65535&this.high,G=this.low>>>16,K=65535&this.low,Y=65535&_.high,ee=_.low>>>16,te=65535&_.low,se=0,re=0,oe=0,le=0;return oe+=(le+=K*te)>>>16,re+=(oe+=G*te)>>>16,oe&=65535,re+=(oe+=K*ee)>>>16,se+=(re+=j*te)>>>16,re&=65535,se+=(re+=G*ee)>>>16,re&=65535,se+=(re+=K*Y)>>>16,se+=(this.high>>>16)*te+j*ee+G*Y+K*(_.high>>>16),u((oe&=65535)<<16|(le&=65535),(se&=65535)<<16|(re&=65535),this.unsigned)},M.mul=M.multiply,M.divide=function(_){if(a(_)||(_=d(_)),_.isZero())throw Error("division by zero");var U,j,G;if(n)return this.unsigned||-2147483648!==this.high||-1!==_.low||-1!==_.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?w:b;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return w;if(_.gt(this.shru(1)))return C;G=w}else{if(this.eq(R))return _.eq(x)||_.eq(k)?R:_.eq(R)?x:(U=this.shr(1).div(_).shl(1)).eq(b)?_.isNegative()?x:k:(j=this.sub(_.mul(U)),G=U.add(j.div(_)));if(_.eq(R))return this.unsigned?w:b;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();G=b}for(j=this;j.gte(_);){U=Math.max(1,Math.floor(j.toNumber()/_.toNumber()));for(var X=Math.ceil(Math.log(U)/Math.LN2),Y=X<=48?1:c(2,X-48),ee=l(U),te=ee.mul(_);te.isNegative()||te.gt(j);)te=(ee=l(U-=Y,this.unsigned)).mul(_);ee.isZero()&&(ee=x),G=G.add(ee),j=j.sub(te)}return G},M.div=M.divide,M.modulo=function(_){return a(_)||(_=d(_)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high),n.get_high(),this.unsigned):this.sub(this.div(_).mul(_))},M.mod=M.modulo,M.rem=M.modulo,M.not=function(){return u(~this.low,~this.high,this.unsigned)},M.and=function(_){return a(_)||(_=d(_)),u(this.low&_.low,this.high&_.high,this.unsigned)},M.or=function(_){return a(_)||(_=d(_)),u(this.low|_.low,this.high|_.high,this.unsigned)},M.xor=function(_){return a(_)||(_=d(_)),u(this.low^_.low,this.high^_.high,this.unsigned)},M.shiftLeft=function(_){return a(_)&&(_=_.toInt()),0==(_&=63)?this:_<32?u(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):u(0,this.low<<_-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(_){return a(_)&&(_=_.toInt()),0==(_&=63)?this:_<32?u(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):u(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(_){if(a(_)&&(_=_.toInt()),0==(_&=63))return this;var $=this.high;return _<32?u(this.low>>>_|$<<32-_,$>>>_,this.unsigned):u(32===_?$:$>>>_-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.shr_u=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},M.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var _=this.high,$=this.low;return[255&$,$>>>8&255,$>>>16&255,$>>>24,255&_,_>>>8&255,_>>>16&255,_>>>24]},M.toBytesBE=function(){var _=this.high,$=this.low;return[_>>>24,_>>>16&255,_>>>8&255,255&_,$>>>24,$>>>16&255,$>>>8&255,255&$]},r.fromBytes=function(_,$,U){return U?r.fromBytesLE(_,$):r.fromBytesBE(_,$)},r.fromBytesLE=function(_,$){return new r(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,$)},r.fromBytesBE=function(_,$){return new r(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],$)}}),ove=Cn(()=>{}),lve=Cn(()=>{}),uve=Cn((e,t)=>{!function(n,r,a){function i(u){var c=this,h=function l(){var u=4022871197;return function(h){h=String(h);for(var d=0;d<h.length;d++){var p=.02519603282416938*(u+=h.charCodeAt(d));p-=u=p>>>0,u=(p*=u)>>>0,u+=4294967296*(p-=u)}return 2.3283064365386963e-10*(u>>>0)}}();c.next=function(){var d=2091639*c.s0+2.3283064365386963e-10*c.c;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=0|d)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(u),c.s0<0&&(c.s0+=1),c.s1-=h(u),c.s1<0&&(c.s1+=1),c.s2-=h(u),c.s2<0&&(c.s2+=1),h=null}function s(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var h=new i(u),d=c&&c.state,p=h.next;return p.int32=function(){return 4294967296*h.next()|0},p.double=function(){return p()+11102230246251565e-32*(2097152*p()|0)},p.quick=p,d&&("object"==typeof d&&s(d,h),p.state=function(){return s(h,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),cve=Cn((e,t)=>{!function(n,r,a){function i(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},l===(0|l)?u.x=l:c+=l;for(var h=0;h<c.length+64;h++)u.x^=0|c.charCodeAt(h),u.next()}function s(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new i(l),h=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do{var m=((c.next()>>>11)+(c.next()>>>0)/4294967296)/(1<<21)}while(0===m);return m},d.int32=c.next,d.quick=d,h&&("object"==typeof h&&s(h,c),d.state=function(){return s(c,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),dve=Cn((e,t)=>{!function(n,r,a){function i(l){var u=this,c="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^d^d<<1)|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(0|l)?u.x=l:c+=l;for(var h=0;h<c.length+64;h++)u.x^=0|c.charCodeAt(h),h==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function s(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new i(l),h=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do{var m=((c.next()>>>11)+(c.next()>>>0)/4294967296)/(1<<21)}while(0===m);return m},d.int32=c.next,d.quick=d,h&&("object"==typeof h&&s(h,c),d.state=function(){return s(c,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),hve=Cn((e,t)=>{!function(n,r,a){function i(l){var u=this;u.next=function(){var p,f,h=u.x,d=u.i;return p=h[d],f=(p^=p>>>7)^p<<24,f^=(p=h[d+1&7])^p>>>10,f^=(p=h[d+3&7])^p>>>3,f^=(p=h[d+4&7])^p<<7,p=h[d+7&7],h[d]=f^=(p^=p<<13)^p<<9,u.i=d+1&7,f},function c(h,d){var p,m=[];if(d===(0|d))m[0]=d;else for(d=""+d,p=0;p<d.length;++p)m[7&p]=m[7&p]<<15^d.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&0===m[p];++p);for(8==p&&(m[7]=-1),h.x=m,h.i=0,p=256;p>0;--p)h.next()}(u,l)}function s(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){null==l&&(l=+new Date);var c=new i(l),h=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do{var m=((c.next()>>>11)+(c.next()>>>0)/4294967296)/(1<<21)}while(0===m);return m},d.int32=c.next,d.quick=d,h&&(h.x&&s(h,c),d.state=function(){return s(c,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),pve=Cn((e,t)=>{!function(n,r,a){function i(l){var u=this;u.next=function(){var f,m,h=u.w,d=u.X,p=u.i;return u.w=h=h+1640531527|0,m=d[p+34&127],f=d[p=p+1&127],m^=m<<13,f^=f<<17,m=d[p]=(m^=m>>>15)^(f^=f>>>12),u.i=p,m+(h^h>>>16)|0},function c(h,d){var p,f,m,g,y,v=[],b=128;for(d===(0|d)?(f=d,d=null):(d+="\0",f=0,b=Math.max(b,d.length)),m=0,g=-32;g<b;++g)d&&(f^=d.charCodeAt((g+32)%d.length)),0===g&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(m=0==(p=v[127&g]^=f+(y=y+1640531527|0))?m+1:0);for(m>=128&&(v[127&(d&&d.length||0)]=-1),m=127,g=512;g>0;--g)f=v[m+34&127],p=v[m=m+1&127],f^=f<<13,p^=p<<17,v[m]=(f^=f>>>15)^(p^=p>>>12);h.w=y,h.X=v,h.i=m}(u,l)}function s(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){null==l&&(l=+new Date);var c=new i(l),h=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do{var m=((c.next()>>>11)+(c.next()>>>0)/4294967296)/(1<<21)}while(0===m);return m},d.int32=c.next,d.quick=d,h&&(h.X&&s(h,c),d.state=function(){return s(c,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),fve=Cn((e,t)=>{!function(n,r,a){function i(l){var u=this,c="";u.next=function(){var d=u.b,p=u.c,f=u.d,m=u.a;return d=d<<25^d>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-d|0,u.b=d=d<<20^d>>>12^p,u.c=p=p-f|0,u.d=f<<16^p>>>16^m,u.a=m-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=0|l):c+=l;for(var h=0;h<c.length+20;h++)u.b^=0|c.charCodeAt(h),u.next()}function s(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new i(l),h=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do{var m=((c.next()>>>11)+(c.next()>>>0)/4294967296)/(1<<21)}while(0===m);return m},d.int32=c.next,d.quick=d,h&&("object"==typeof h&&s(h,c),d.state=function(){return s(c,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o}(0,"object"==typeof t&&t,"function"==typeof define&&define)}),mve=Cn(()=>{}),gve=Cn((e,t)=>{!function(n,r,a){var p,i=256,l="random",u=a.pow(i,6),c=a.pow(2,52),h=2*c,d=i-1;function f(x,C,k){var T=[],A=v(y((C=1==C?{entropy:!0}:C||{}).entropy?[x,w(r)]:x??function b(){try{var x;return p&&(x=p.randomBytes)?x=x(i):(x=new Uint8Array(i),(n.crypto||n.msCrypto).getRandomValues(x)),w(x)}catch{var C=n.navigator,k=C&&C.plugins;return[+new Date,n,k,n.screen,w(r)]}}(),3),T),R=new m(T),M=function(){for(var _=R.g(6),$=u,U=0;_<c;)_=(_+U)*i,$*=i,U=R.g(1);for(;_>=h;)_/=2,$/=2,U>>>=1;return(_+U)/$};return M.int32=function(){return 0|R.g(4)},M.quick=function(){return R.g(4)/4294967296},M.double=M,v(w(R.S),r),(C.pass||k||function(_,$,U,j){return j&&(j.S&&g(j,R),_.state=function(){return g(R,{})}),U?(a[l]=_,$):_})(M,A,"global"in C?C.global:this==a,C.state)}function m(x){var C,k=x.length,T=this,A=0,R=T.i=T.j=0,M=T.S=[];for(k||(x=[k++]);A<i;)M[A]=A++;for(A=0;A<i;A++)M[A]=M[R=d&R+x[A%k]+(C=M[A])],M[R]=C;(T.g=function(_){for(var $,U=0,j=T.i,G=T.j,K=T.S;_--;)$=K[j=d&j+1],U=U*i+K[d&(K[j]=K[G=d&G+$])+(K[G]=$)];return T.i=j,T.j=G,U})(i)}function g(x,C){return C.i=x.i,C.j=x.j,C.S=x.S.slice(),C}function y(x,C){var A,k=[],T=typeof x;if(C&&"object"==T)for(A in x)try{k.push(y(x[A],C-1))}catch{}return k.length?k:"string"==T?x:x+"\0"}function v(x,C){for(var T,k=x+"",A=0;A<k.length;)C[d&A]=d&(T^=19*C[d&A])+k.charCodeAt(A++);return w(C)}function w(x){return String.fromCharCode.apply(0,x)}if(v(a.random(),r),"object"==typeof t&&t.exports){t.exports=f;try{p=mve()}catch{}}else"function"==typeof define&&So.amdO?define(function(){return f}):a["seed"+l]=f}(typeof self<"u"?self:e,[],Math)}),Zx=Cn((e,t)=>{var n=uve(),r=cve(),a=dve(),i=hve(),s=pve(),o=fve(),l=gve();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=i,l.xor4096=s,l.tychei=o,t.exports=l}),Bj=Cn(()=>{}),tN=Cn(()=>{}),Vj=Cn(()=>{}),yve=Cn(()=>{}),vve=Cn(()=>{}),bve=Cn(()=>{}),wve=Cn((e,t)=>{var r,n=(r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(r=r||__filename),function(a){function s(){return fe.buffer!=Ye&&jt(fe.buffer),Oa}function l(){return fe.buffer!=Ye&&jt(fe.buffer),gr}function u(){return fe.buffer!=Ye&&jt(fe.buffer),ca}function h(){return fe.buffer!=Ye&&jt(fe.buffer),da}var p,f,m,d=typeof(a=a||{})<"u"?a:{};d.ready=new Promise(function(O,q){p=O,f=q}),typeof process<"u"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var R,M,_,g=Object.assign({},d),y=[],b=(O,q)=>{throw q},w="object"==typeof window,x="function"==typeof importScripts,C="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,k=d.ENVIRONMENT_IS_PTHREAD||!1,T="";function A(O){return d.locateFile?d.locateFile(O,T):T+O}if(C){var j=tN(),G=Vj();let O;T=x?G.dirname(T)+"/":__dirname+"/",R=(q,pe)=>(q=rm(q)?new URL(q):G.normalize(q),j.readFileSync(q,pe?void 0:"utf8")),_=q=>{var pe=R(q,!0);return pe.buffer||(pe=new Uint8Array(pe)),pe},M=(q,pe,Oe)=>{q=rm(q)?new URL(q):G.normalize(q),j.readFile(q,function(Qe,Xe){Qe?Oe(Qe):pe(Xe.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),y=process.argv.slice(2),process.on("uncaughtException",function(q){if(!(q instanceof Rd))throw q}),process.on("unhandledRejection",function(q){throw q}),b=(q,pe)=>{if(Si())throw process.exitCode=q,pe;(function U(O){O instanceof Rd||ee("exiting due to exception: "+O)})(pe),process.exit(q)},d.inspect=function(){return"[Emscripten Module object]"};try{O=yve()}catch(q){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),q}global.Worker=O.Worker}else(w||x)&&(x?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),typeof r<"u"&&r&&(T=r),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",C||(R=O=>{var q=new XMLHttpRequest;return q.open("GET",O,!1),q.send(null),q.responseText},x&&(_=O=>{var q=new XMLHttpRequest;return q.open("GET",O,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),M=(O,q,pe)=>{var Oe=new XMLHttpRequest;Oe.open("GET",O,!0),Oe.responseType="arraybuffer",Oe.onload=()=>{200==Oe.status||0==Oe.status&&Oe.response?q(Oe.response):pe()},Oe.onerror=pe,Oe.send(null)}));C&&typeof performance>"u"&&(global.performance=vve().performance);var K=console.log.bind(console),X=console.warn.bind(console);C&&(K=O=>j.writeSync(1,O+"\n"),X=O=>j.writeSync(2,O+"\n"));var le,Y=d.print||K,ee=d.printErr||X;Object.assign(d,g),g=null,d.arguments&&(y=d.arguments),d.quit&&(b=d.quit),Atomics,Atomics,Atomics,d.wasmBinary&&(le=d.wasmBinary);var Ce=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&Md("no native wasm support detected");var fe,_e,Fe,Ye,Jt,Oa,gr,ca,da,De=!1,dt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function qt(O,q,pe){for(var Oe=(q>>>=0)+pe,Qe=q;O[Qe]&&!(Qe>=Oe);)++Qe;if(Qe-q>16&&O.buffer&&dt)return dt.decode(O.buffer instanceof SharedArrayBuffer?O.slice(q,Qe):O.subarray(q,Qe));for(var Xe="";q<Qe;){var be=O[q++];if(128&be){var Te=63&O[q++];if(192!=(224&be)){var yn=63&O[q++];if((be=224==(240&be)?(15&be)<<12|Te<<6|yn:(7&be)<<18|Te<<12|yn<<6|63&O[q++])<65536)Xe+=String.fromCharCode(be);else{var ai=be-65536;Xe+=String.fromCharCode(55296|ai>>10,56320|1023&ai)}}else Xe+=String.fromCharCode((31&be)<<6|Te)}else Xe+=String.fromCharCode(be)}return Xe}function jt(O){Ye=O,d.HEAP8=Jt=new Int8Array(O),d.HEAP16=new Int16Array(O),d.HEAP32=gr=new Int32Array(O),d.HEAPU8=Oa=new Uint8Array(O),d.HEAPU16=new Uint16Array(O),d.HEAPU32=ca=new Uint32Array(O),d.HEAPF32=new Float32Array(O),d.HEAPF64=da=new Float64Array(O)}k&&(Ye=d.buffer);var ha=d.INITIAL_MEMORY||16777216;if(k)fe=d.wasmMemory,Ye=d.buffer;else if(d.wasmMemory)fe=d.wasmMemory;else if(!((fe=new WebAssembly.Memory({initial:ha/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");fe&&(Ye=fe.buffer),ha=Ye.byteLength,jt(Ye);var $a,vo=[],tm=[],Fs=[];function Si(){return Ce}function lr(){!k&&Hv(tm)}var $l=0,nm=null,bo=null;function Md(O){d.onAbort&&d.onAbort(O),ee(O="Aborted("+O+")"),De=!0,Fe=1,O+=". Build with -sASSERTIONS for more info.";var q=new WebAssembly.RuntimeError(O);throw f(q),q}var kr;function _1(O){return O.startsWith("data:application/octet-stream;base64,")}function rm(O){return O.startsWith("file://")}function C1(O){try{if(O==kr&&le)return new Uint8Array(le);if(_)return _(O);throw"both async and sync fetching of the wasm failed"}catch(q){Md(q)}}_1(kr="tfjs-backend-wasm-threaded-simd.wasm")||(kr=A(kr));var E1={};function Rd(O){this.name="ExitStatus",this.message="Program terminated with exit("+O+")",this.status=O}function jv(O){var q=Ke.pthreads[O];(function rt(O,q){O||Md(q)})(q),Ke.returnWorkerToPool(q)}function eR(O){var q=Ke.getNewWorker();if(!q)return 6;Ke.runningWorkers.push(q),Ke.pthreads[O.pthread_ptr]=q,q.pthread_ptr=O.pthread_ptr;var pe={cmd:"run",start_routine:O.startRoutine,arg:O.arg,pthread_ptr:O.pthread_ptr};return q.runPthread=()=>{C&&q.ref(),q.postMessage(pe,O.transferList),delete q.runPthread},q.loaded&&q.runPthread(),0}function N1(O){if(k)return Pl(1,1,O);Fe=O,Si()||(Ke.terminateAllThreads(),d.onExit&&d.onExit(O),De=!0),b(O,new Rd(O))}var T1=function tR(O,q){if(Fe=O,!q&&k)throw D1(O),"unwind";N1(O)},Ke={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){k?Ke.initWorker():Ke.initMainThread()},initMainThread:function(){for(var O=8;O--;)Ke.allocateUnusedWorker()},initWorker:function(){Ce=!1},setExitStatus:function(O){Fe=O},terminateAllThreads:function(){for(var O of Object.values(Ke.pthreads))Ke.returnWorkerToPool(O);for(var O of Ke.unusedWorkers)O.terminate();Ke.unusedWorkers=[]},returnWorkerToPool:function(O){var q=O.pthread_ptr;delete Ke.pthreads[q],Ke.unusedWorkers.push(O),Ke.runningWorkers.splice(Ke.runningWorkers.indexOf(O),1),O.pthread_ptr=0,C&&O.unref(),IO(q)},receiveObjectTransfer:function(O){},threadInitTLS:function(){Ke.tlsInitFunctions.forEach(O=>O())},loadWasmModuleToWorker:function(O,q){O.onmessage=Xe=>{var be=Xe.data,Te=be.cmd;if(O.pthread_ptr&&(Ke.currentProxiedOperationCallerThread=O.pthread_ptr),be.targetThread&&be.targetThread!=j1()){var yn=Ke.pthreads[be.targetThread];return yn?yn.postMessage(be,be.transferList):ee('Internal error! Worker sent a message "'+Te+'" to target pthread '+be.targetThread+", but that thread no longer exists!"),void(Ke.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===Te?Gv(be.queue):"spawnThread"===Te?eR(be):"cleanupThread"===Te?jv(be.thread):"killThread"===Te?function Q2(O){var q=Ke.pthreads[O];delete Ke.pthreads[O],q.terminate(),IO(O),Ke.runningWorkers.splice(Ke.runningWorkers.indexOf(q),1),q.pthread_ptr=0}(be.thread):"cancelThread"===Te?function J2(O){Ke.pthreads[O].postMessage({cmd:"cancel"})}(be.thread):"loaded"===Te?(O.loaded=!0,C&&O.unref(),q&&q(O),O.runPthread&&O.runPthread()):"print"===Te?Y("Thread "+be.threadId+": "+be.text):"printErr"===Te?ee("Thread "+be.threadId+": "+be.text):"alert"===Te?alert("Thread "+be.threadId+": "+be.text):"setimmediate"===be.target?O.postMessage(be):"callHandler"===Te?d[be.handler](...be.args):Te&&ee("worker sent an unknown command "+Te),Ke.currentProxiedOperationCallerThread=void 0},O.onerror=Xe=>{throw ee("worker sent an error! "+Xe.filename+":"+Xe.lineno+": "+Xe.message),Xe},C&&(O.on("message",function(Xe){O.onmessage({data:Xe})}),O.on("error",function(Xe){O.onerror(Xe)}),O.on("detachedExit",function(){}));var pe=[];for(var Qe of["onExit","onAbort","print","printErr"])d.hasOwnProperty(Qe)&&pe.push(Qe);O.postMessage({cmd:"load",handlers:pe,urlOrBlob:d.mainScriptUrlOrBlob||r,wasmMemory:fe,wasmModule:_e})},allocateUnusedWorker:function(){var O,q=A("tfjs-backend-wasm-threaded-simd.worker.js");O=new Worker(q),Ke.unusedWorkers.push(O)},getNewWorker:function(){return 0==Ke.unusedWorkers.length&&(Ke.allocateUnusedWorker(),Ke.loadWasmModuleToWorker(Ke.unusedWorkers[0])),Ke.unusedWorkers.pop()}};function Hv(O){for(;O.length>0;)O.shift()(d)}function D1(O){if(k)return Pl(2,0,O);try{T1(O)}catch(q){!function nR(O){if(O instanceof Rd||"unwind"==O)return Fe;b(1,O)}(q)}}d.PThread=Ke,d.establishStackSpace=function rR(){var O=j1(),q=l()[O+52>>>2],pe=l()[O+56>>>2];rQ(q,q-pe),H1(q)};var qv,am=[];function A1(O,q,pe,Oe){return k?Pl(3,1,O,q,pe,Oe):M1(O,q,pe,Oe)}function M1(O,q,pe,Oe){if(typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Qe=[];if(k&&0===Qe.length)return A1(O,q,pe,Oe);var be={startRoutine:pe,pthread_ptr:O,arg:Oe,transferList:Qe};return k?(be.cmd="spawnThread",postMessage(be,Qe),0):eR(be)}function Gv(O){Atomics.store(l(),O>>2,1),j1()&&tQ(O),Atomics.compareExchange(l(),O>>2,1,0)}function Fd(O){Fd.shown||(Fd.shown={}),Fd.shown[O]||(Fd.shown[O]=1,C&&(O="warning: "+O),ee(O))}function Pl(O,q){var pe=arguments.length-2,Oe=arguments;return function wR(O){var q=SO(),pe=O();return H1(q),pe}(()=>{for(var Qe=pe,Xe=G1(8*Qe),be=Xe>>3,Te=0;Te<pe;Te++){var yn=Oe[2+Te];h()[be+Te>>>0]=yn}return eQ(O,Qe,Xe,q)})}d.invokeEntryPoint=function iR(O,q){var pe=function aR(O){var q=am[O];return q||(O>=am.length&&(am.length=O+1),am[O]=q=$a.get(O)),q}(O)(q);Si()?Ke.setExitStatus(pe):nQ(pe)},d.executeNotifiedProxyingQueue=Gv,qv=C?()=>{var O=process.hrtime();return 1e3*O[0]+O[1]/1e6}:()=>performance.timeOrigin+performance.now();var Kv=[];function IR(O){try{return fe.grow(O-Ye.byteLength+65535>>>16),jt(fe.buffer),1}catch{}}function F1(O){return k?Pl(4,1,O):52}function O1(O,q,pe,Oe,Qe){return k?Pl(5,1,O,q,pe,Oe,Qe):70}var CR=[null,[],[]];function ER(O,q){var pe=CR[O];0===q||10===q?((1===O?Y:ee)(qt(pe,0)),pe.length=0):pe.push(q)}function $1(O,q,pe,Oe){if(k)return Pl(6,1,O,q,pe,Oe);for(var Qe=0,Xe=0;Xe<pe;Xe++){var be=u()[q>>>2],Te=u()[q+4>>>2];q+=8;for(var yn=0;yn<Te;yn++)ER(O,s()[be+yn>>>0]);Qe+=Te}return u()[Oe>>>2]=Qe,0}function P1(O){return d["_"+O]}function NR(O,q,pe,Oe,Qe){var Xe={string:ii=>{var lm=0;if(null!=ii&&0!==ii){var sQ=1+(ii.length<<2);!function _t(O,q,pe){(function St(O,q,pe,Oe){if(!(Oe>0))return 0;for(var Qe=pe>>>=0,Xe=pe+Oe-1,be=0;be<O.length;++be){var Te=O.charCodeAt(be);if(Te>=55296&&Te<=57343&&(Te=65536+((1023&Te)<<10)|1023&O.charCodeAt(++be)),Te<=127){if(pe>=Xe)break;q[pe++>>>0]=Te}else if(Te<=2047){if(pe+1>=Xe)break;q[pe++>>>0]=192|Te>>6,q[pe++>>>0]=128|63&Te}else if(Te<=65535){if(pe+2>=Xe)break;q[pe++>>>0]=224|Te>>12,q[pe++>>>0]=128|Te>>6&63,q[pe++>>>0]=128|63&Te}else{if(pe+3>=Xe)break;q[pe++>>>0]=240|Te>>18,q[pe++>>>0]=128|Te>>12&63,q[pe++>>>0]=128|Te>>6&63,q[pe++>>>0]=128|63&Te}}q[pe>>>0]=0})(O,s(),q,pe)}(ii,lm=G1(sQ),sQ)}return lm},array:ii=>{var lm=G1(ii.length);return function kR(O,q){(function i(){return fe.buffer!=Ye&&jt(fe.buffer),Jt})().set(O,q>>>0)}(ii,lm),lm}},Te=P1(O),yn=[],ai=0;if(Oe)for(var xo=0;xo<Oe.length;xo++){var iQ=Xe[pe[xo]];iQ?(0===ai&&(ai=SO()),yn[xo]=iQ(Oe[xo])):yn[xo]=Oe[xo]}var _O=Te.apply(null,yn);return function GQe(ii){return 0!==ai&&H1(ai),function be(ii){return"string"===q?function At(O,q){return(O>>>=0)?qt(s(),O,q):""}(ii):"boolean"===q?!!ii:ii}(ii)}(_O)}Ke.init();var q1,K1,X1,DR=[null,N1,D1,A1,F1,O1,$1],L1={__emscripten_init_main_thread_js:function oR(O){JY(O,!x,1,!w),Ke.threadInitTLS()},__emscripten_thread_cleanup:function lR(O){k?postMessage({cmd:"cleanupThread",thread:O}):jv(O)},__pthread_create_js:M1,_emscripten_default_pthread_stack_size:function uR(){return 65536},_emscripten_get_now_is_monotonic:function dR(){return!0},_emscripten_notify_task_queue:function hR(O,q,pe,Oe){if(O==q)setTimeout(()=>Gv(Oe));else if(k)postMessage({targetThread:O,cmd:"processProxyingQueue",queue:Oe});else{var Qe=Ke.pthreads[O];if(!Qe)return;Qe.postMessage({cmd:"processProxyingQueue",queue:Oe})}return 1},_emscripten_set_offscreencanvas_size:function pR(O,q,pe){return-1},abort:function fR(){Md("")},emscripten_check_blocking_allowed:function mR(){C||x||Fd("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function gR(){return Date.now()},emscripten_get_heap_max:function yR(){return 4294901760},emscripten_get_now:qv,emscripten_memcpy_big:function vR(O,q,pe){s().copyWithin(O>>>0,q>>>0,q+pe>>>0)},emscripten_num_logical_cores:function bR(){return C?bve().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function xR(O,q,pe){Kv.length=q;for(var Oe=pe>>3,Qe=0;Qe<q;Qe++)Kv[Qe]=h()[Oe+Qe>>>0];return(O<0?E1[-O-1]:DR[O]).apply(null,Kv)},emscripten_resize_heap:function SR(O){var q=s().length;if((O>>>=0)<=q)return!1;var yn,pe=4294901760;if(O>pe)return!1;for(var Qe=1;Qe<=4;Qe*=2){var Xe=q*(1+.2/Qe);if(Xe=Math.min(Xe,O+100663296),IR(Math.min(pe,(yn=Math.max(O,Xe))+(65536-yn%65536)%65536)))return!0}return!1},emscripten_unwind_to_js_event_loop:function _R(){throw"unwind"},exit:T1,fd_close:F1,fd_seek:O1,fd_write:$1,memory:fe||d.wasmMemory},j1=(function Y2(){var O={env:L1,wasi_snapshot_preview1:L1};function q(be,Te){if(d.asm=be.exports,function sR(O){Ke.tlsInitFunctions.push(O)}(d.asm._emscripten_tls_init),$a=d.asm.__indirect_function_table,function q2(O){tm.unshift(O)}(d.asm.__wasm_call_ctors),_e=Te,!k){var ai=Ke.unusedWorkers.length;Ke.unusedWorkers.forEach(function(xo){Ke.loadWasmModuleToWorker(xo,function(){--ai||function S1(O){if($l--,d.monitorRunDependencies&&d.monitorRunDependencies($l),0==$l&&(null!==nm&&(clearInterval(nm),nm=null),bo)){var q=bo;bo=null,q()}}()})})}}function pe(be){q(be.instance,be.module)}function Oe(be){return function Z2(){if(!le&&(w||x)){if("function"==typeof fetch&&!rm(kr))return fetch(kr,{credentials:"same-origin"}).then(function(O){if(!O.ok)throw"failed to load wasm binary file at '"+kr+"'";return O.arrayBuffer()}).catch(function(){return C1(kr)});if(M)return new Promise(function(O,q){M(kr,function(pe){O(new Uint8Array(pe))},q)})}return Promise.resolve().then(function(){return C1(kr)})}().then(function(Te){return WebAssembly.instantiate(Te,O)}).then(function(Te){return Te}).then(be,function(Te){ee("failed to asynchronously prepare wasm: "+Te),Md(Te)})}if(k||function K2(O){$l++,d.monitorRunDependencies&&d.monitorRunDependencies($l)}(),d.instantiateWasm)try{return d.instantiateWasm(O,q)}catch(be){ee("Module.instantiateWasm callback failed with error: "+be),f(be)}(function Qe(){return le||"function"!=typeof WebAssembly.instantiateStreaming||_1(kr)||rm(kr)||C||"function"!=typeof fetch?Oe(pe):fetch(kr,{credentials:"same-origin"}).then(function(be){return WebAssembly.instantiateStreaming(be,O).then(pe,function(yn){return ee("wasm streaming compile failed: "+yn),ee("falling back to ArrayBuffer instantiation"),Oe(pe)})})})().catch(f)}(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Acos=function(){return(d._Acos=d.asm.Acos).apply(null,arguments)},d._Acosh=function(){return(d._Acosh=d.asm.Acosh).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._ArgMin=function(){return(d._ArgMin=d.asm.ArgMin).apply(null,arguments)},d._Asin=function(){return(d._Asin=d.asm.Asin).apply(null,arguments)},d._Asinh=function(){return(d._Asinh=d.asm.Asinh).apply(null,arguments)},d._Atan=function(){return(d._Atan=d.asm.Atan).apply(null,arguments)},d._Atan2=function(){return(d._Atan2=d.asm.Atan2).apply(null,arguments)},d._Atanh=function(){return(d._Atanh=d.asm.Atanh).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._AvgPool3D=function(){return(d._AvgPool3D=d.asm.AvgPool3D).apply(null,arguments)},d._AvgPool3DGrad=function(){return(d._AvgPool3DGrad=d.asm.AvgPool3DGrad).apply(null,arguments)},d._AvgPoolGrad=function(){return(d._AvgPoolGrad=d.asm.AvgPoolGrad).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Bincount=function(){return(d._Bincount=d.asm.Bincount).apply(null,arguments)},d._BitwiseAnd=function(){return(d._BitwiseAnd=d.asm.BitwiseAnd).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Conv3D=function(){return(d._Conv3D=d.asm.Conv3D).apply(null,arguments)},d._Conv3DBackpropFilterV2=function(){return(d._Conv3DBackpropFilterV2=d.asm.Conv3DBackpropFilterV2).apply(null,arguments)},d._Conv3DBackpropInputV2=function(){return(d._Conv3DBackpropInputV2=d.asm.Conv3DBackpropInputV2).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DenseBincount=function(){return(d._DenseBincount=d.asm.DenseBincount).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Diag=function(){return(d._Diag=d.asm.Diag).apply(null,arguments)},d._Dilation2D=function(){return(d._Dilation2D=d.asm.Dilation2D).apply(null,arguments)},d._Dilation2DBackpropFilter=function(){return(d._Dilation2DBackpropFilter=d.asm.Dilation2DBackpropFilter).apply(null,arguments)},d._Dilation2DBackpropInput=function(){return(d._Dilation2DBackpropInput=d.asm.Dilation2DBackpropInput).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._EluGrad=function(){return(d._EluGrad=d.asm.EluGrad).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Erf=function(){return(d._Erf=d.asm.Erf).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._Expm1=function(){return(d._Expm1=d.asm.Expm1).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._IsFinite=function(){return(d._IsFinite=d.asm.IsFinite).apply(null,arguments)},d._IsInf=function(){return(d._IsInf=d.asm.IsInf).apply(null,arguments)},d._IsNan=function(){return(d._IsNan=d.asm.IsNan).apply(null,arguments)},d._LRN=function(){return(d._LRN=d.asm.LRN).apply(null,arguments)},d._LRNGrad=function(){return(d._LRNGrad=d.asm.LRNGrad).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._LinSpace=function(){return(d._LinSpace=d.asm.LinSpace).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._Log1p=function(){return(d._Log1p=d.asm.Log1p).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._LogicalNot=function(){return(d._LogicalNot=d.asm.LogicalNot).apply(null,arguments)},d._LogicalOr=function(){return(d._LogicalOr=d.asm.LogicalOr).apply(null,arguments)},d._LogicalXor=function(){return(d._LogicalXor=d.asm.LogicalXor).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._MaxPool3D=function(){return(d._MaxPool3D=d.asm.MaxPool3D).apply(null,arguments)},d._MaxPool3DGrad=function(){return(d._MaxPool3DGrad=d.asm.MaxPool3DGrad).apply(null,arguments)},d._MaxPoolGrad=function(){return(d._MaxPoolGrad=d.asm.MaxPoolGrad).apply(null,arguments)},d._MaxPoolWithArgmax=function(){return(d._MaxPoolWithArgmax=d.asm.MaxPoolWithArgmax).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Mod=function(){return(d._Mod=d.asm.Mod).apply(null,arguments)},d._Multinomial=function(){return(d._Multinomial=d.asm.Multinomial).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Reciprocal=function(){return(d._Reciprocal=d.asm.Reciprocal).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._ResizeBilinearGrad=function(){return(d._ResizeBilinearGrad=d.asm.ResizeBilinearGrad).apply(null,arguments)},d._ResizeNearestNeighbor=function(){return(d._ResizeNearestNeighbor=d.asm.ResizeNearestNeighbor).apply(null,arguments)},d._ResizeNearestNeighborGrad=function(){return(d._ResizeNearestNeighborGrad=d.asm.ResizeNearestNeighborGrad).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SearchSorted=function(){return(d._SearchSorted=d.asm.SearchSorted).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Selu=function(){return(d._Selu=d.asm.Selu).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sign=function(){return(d._Sign=d.asm.Sign).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Sinh=function(){return(d._Sinh=d.asm.Sinh).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._Softplus=function(){return(d._Softplus=d.asm.Softplus).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._SparseToDense=function(){return(d._SparseToDense=d.asm.SparseToDense).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._TensorScatterUpdate=function(){return(d._TensorScatterUpdate=d.asm.TensorScatterUpdate).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(d._malloc=d.asm.malloc).apply(null,arguments)},d._free=function(){return(d._free=d.asm.free).apply(null,arguments)},d.__emscripten_tls_init=function(){return(d.__emscripten_tls_init=d.asm._emscripten_tls_init).apply(null,arguments)},d._pthread_self=function(){return(j1=d._pthread_self=d.asm.pthread_self).apply(null,arguments)}),JY=(d.___errno_location=function(){return(d.___errno_location=d.asm.__errno_location).apply(null,arguments)},d.__emscripten_thread_init=function(){return(JY=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),eQ=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d._emscripten_main_thread_process_queued_calls=function(){return(d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_run_in_main_runtime_thread_js=function(){return(eQ=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),tQ=(d._emscripten_dispatch_to_thread_=function(){return(d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},d.__emscripten_proxy_execute_task_queue=function(){return(tQ=d.__emscripten_proxy_execute_task_queue=d.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),IO=d.__emscripten_thread_free_data=function(){return(IO=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},nQ=d.__emscripten_thread_exit=function(){return(nQ=d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},rQ=d._emscripten_stack_set_limits=function(){return(rQ=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)},SO=d.stackSave=function(){return(SO=d.stackSave=d.asm.stackSave).apply(null,arguments)},H1=d.stackRestore=function(){return(H1=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},G1=d.stackAlloc=function(){return(G1=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)};function aQ(O){if(O=O||y,!($l>0)){if(k)return p(d),lr(),void startWorker(d);(function Ol(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)O=d.preRun.shift(),vo.unshift(O);var O;Hv(vo)})(),$l>0||(d.setStatus?(d.setStatus("Running..."),setTimeout(function(){setTimeout(function(){d.setStatus("")},1),q()},1)):q())}function q(){q1||(q1=!0,d.calledRun=!0,!De&&(lr(),p(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),function I1(){if(!k){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)O=d.postRun.shift(),Fs.unshift(O);Hv(Fs)}var O}()))}}if(d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)},d.keepRuntimeAlive=Si,d.wasmMemory=fe,d.cwrap=function TR(O,q,pe,Oe){var Qe=(pe=pe||[]).every(be=>"number"===be||"boolean"===be);return"string"!==q&&Qe&&!Oe?P1(O):function(){return NR(O,q,pe,arguments)}},d.ExitStatus=Rd,d.PThread=Ke,bo=function O(){q1||aQ(),q1||(bo=O)},d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(aQ(),m&&(K1={uncaughtException:process.listeners("uncaughtException").filter(function(O){return!m.uncaughtException.indexOf(O)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(O){return!m.unhandledRejection.indexOf(O)>-1})}),typeof WasmBackendModule<"u")X1=WasmBackendModule;else{if(!(typeof a<"u"))throw new Error("Could not find wasm module in post.js");X1=a}if(K1){var HQe=X1._dispose;X1._dispose=function(){HQe(),K1.uncaughtException.forEach(function(O){process.removeListener("uncaughtException",O)}),K1.unhandledRejection.forEach(function(O){process.removeListener("unhandledRejection",O)})}}return a.ready});"object"==typeof e&&"object"==typeof t?t.exports=n:"function"==typeof define&&So.amdO?define([],function(){return n}):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=n)}),xve=Cn((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'}),Ive=Cn((e,t)=>{var r,n=(r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(r=r||__filename),function(a){var s,o,l,i=typeof(a=a||{})<"u"?a:{};i.ready=new Promise(function(Z,ue){s=Z,o=ue}),typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var v,b,w,u=Object.assign({},i),c=[],p="object"==typeof window,f="function"==typeof importScripts,m="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(m){var k=tN(),T=Vj();g=f?T.dirname(g)+"/":__dirname+"/",v=(Z,ue)=>(Z=Ol(Z)?new URL(Z):T.normalize(Z),k.readFileSync(Z,ue?void 0:"utf8")),w=Z=>{var ue=v(Z,!0);return ue.buffer||(ue=new Uint8Array(ue)),ue},b=(Z,ue,Me)=>{Z=Ol(Z)?new URL(Z):T.normalize(Z),k.readFile(Z,function(vt,un){vt?Me(vt):ue(un.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),c=process.argv.slice(2),process.on("uncaughtException",function(Z){if(!(Z instanceof nm))throw Z}),process.on("unhandledRejection",function(Z){throw Z}),i.inspect=function(){return"[Emscripten Module object]"}}else(p||f)&&(f?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),r&&(g=r),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v=Z=>{var ue=new XMLHttpRequest;return ue.open("GET",Z,!1),ue.send(null),ue.responseText},f&&(w=Z=>{var ue=new XMLHttpRequest;return ue.open("GET",Z,!1),ue.responseType="arraybuffer",ue.send(null),new Uint8Array(ue.response)}),b=(Z,ue,Me)=>{var vt=new XMLHttpRequest;vt.open("GET",Z,!0),vt.responseType="arraybuffer",vt.onload=()=>{200==vt.status||0==vt.status&&vt.response?ue(vt.response):Me()},vt.onerror=Me,vt.send(null)});var _,A=i.print||console.log.bind(console),R=i.printErr||console.warn.bind(console);Object.assign(i,u),u=null,i.arguments&&(c=i.arguments),i.wasmBinary&&(_=i.wasmBinary),"object"!=typeof WebAssembly&&Fs("no native wasm support detected");var U,re,oe,le,De,j=!1,X=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Y(Z,ue,Me){for(var vt=(ue>>>=0)+Me,un=ue;Z[un]&&!(un>=vt);)++un;if(un-ue>16&&Z.buffer&&X)return X.decode(Z.subarray(ue,un));for(var cn="";ue<un;){var ht=Z[ue++];if(128&ht){var lt=63&Z[ue++];if(192!=(224&ht)){var Rn=63&Z[ue++];if((ht=224==(240&ht)?(15&ht)<<12|lt<<6|Rn:(7&ht)<<18|lt<<12|Rn<<6|63&Z[ue++])<65536)cn+=String.fromCharCode(ht);else{var ri=ht-65536;cn+=String.fromCharCode(55296|ri>>10,56320|1023&ri)}}else cn+=String.fromCharCode((31&ht)<<6|lt)}else cn+=String.fromCharCode(ht)}return cn}function dt(Z){re=Z,i.HEAP8=oe=new Int8Array(Z),i.HEAP16=new Int16Array(Z),i.HEAP32=new Int32Array(Z),i.HEAPU8=le=new Uint8Array(Z),i.HEAPU16=new Uint16Array(Z),i.HEAPU32=De=new Uint32Array(Z),i.HEAPF32=new Float32Array(Z),i.HEAPF64=new Float64Array(Z)}var St=[],_t=[],Ye=[],jt=0,ha=null,$a=null;function Fs(Z){i.onAbort&&i.onAbort(Z),R(Z="Aborted("+Z+")"),j=!0,Z+=". Build with -sASSERTIONS for more info.";var ue=new WebAssembly.RuntimeError(Z);throw o(ue),ue}var lr;function Si(Z){return Z.startsWith("data:application/octet-stream;base64,")}function Ol(Z){return Z.startsWith("file://")}function I1(Z){try{if(Z==lr&&_)return new Uint8Array(_);if(w)return w(Z);throw"both async and sync fetching of the wasm failed"}catch(ue){Fs(ue)}}function nm(Z){this.name="ExitStatus",this.message="Program terminated with exit("+Z+")",this.status=Z}function bo(Z){for(;Z.length>0;)Z.shift()(i)}function _1(Z){try{return U.grow(Z-re.byteLength+65535>>>16),dt(U.buffer),1}catch{}}Si(lr="tfjs-backend-wasm.wasm")||(lr=function y(Z){return i.locateFile?i.locateFile(Z,g):g+Z}(lr));var Y2=[null,[],[]];function ZY(Z,ue){var Me=Y2[Z];0===ue||10===ue?((1===Z?A:R)(Y(Me,0)),Me.length=0):Me.push(ue)}function E1(Z){return i["_"+Z]}function Q2(Z,ue,Me,vt,un){var cn={string:pa=>{var Ll=0;if(null!=pa&&0!==pa){var W1=1+(pa.length<<2);!function se(Z,ue,Me){(function te(Z,ue,Me,vt){if(!(vt>0))return 0;for(var un=Me>>>=0,cn=Me+vt-1,ht=0;ht<Z.length;++ht){var lt=Z.charCodeAt(ht);if(lt>=55296&&lt<=57343&&(lt=65536+((1023&lt)<<10)|1023&Z.charCodeAt(++ht)),lt<=127){if(Me>=cn)break;ue[Me++>>>0]=lt}else if(lt<=2047){if(Me+1>=cn)break;ue[Me++>>>0]=192|lt>>6,ue[Me++>>>0]=128|63&lt}else if(lt<=65535){if(Me+2>=cn)break;ue[Me++>>>0]=224|lt>>12,ue[Me++>>>0]=128|lt>>6&63,ue[Me++>>>0]=128|63&lt}else{if(Me+3>=cn)break;ue[Me++>>>0]=240|lt>>18,ue[Me++>>>0]=128|lt>>12&63,ue[Me++>>>0]=128|lt>>6&63,ue[Me++>>>0]=128|63&lt}}ue[Me>>>0]=0})(Z,le,ue,Me)}(pa,Ll=Xv(W1),W1)}return Ll},array:pa=>{var Ll=Xv(pa.length);return function Rd(Z,ue){oe.set(Z,ue>>>0)}(pa,Ll),Ll}},lt=E1(Z),Rn=[],ri=0;if(vt)for(var wo=0;wo<vt.length;wo++){var U1=cn[Me[wo]];U1?(0===ri&&(ri=z1()),Rn[wo]=U1(vt[wo])):Rn[wo]=vt[wo]}var Zv=lt.apply(null,Rn);return function xO(pa){return 0!==ri&&B1(ri),function ht(pa){return"string"===ue?function ee(Z,ue){return(Z>>>=0)?Y(le,Z,ue):""}(pa):"boolean"===ue?!!pa:pa}(pa)}(Zv)}var im,sm,om,jv={abort:function K2(){Fs("")},emscripten_get_heap_max:function Md(){return 4294901760},emscripten_memcpy_big:function X2(Z,ue,Me){le.copyWithin(Z>>>0,ue>>>0,ue+Me>>>0)},emscripten_resize_heap:function rm(Z){var Rn,ue=le.length,Me=4294901760;if((Z>>>=0)>Me)return!1;for(var un=1;un<=4;un*=2){var cn=ue*(1+.2/un);if(cn=Math.min(cn,Z+100663296),_1(Math.min(Me,(Rn=Math.max(Z,cn))+(65536-Rn%65536)%65536)))return!0}return!1},fd_close:function C1(Z){return 52},fd_seek:function Z2(Z,ue,Me,vt,un){return 70},fd_write:function YY(Z,ue,Me,vt){for(var un=0,cn=0;cn<Me;cn++){var ht=De[ue>>>2],lt=De[ue+4>>>2];ue+=8;for(var Rn=0;Rn<lt;Rn++)ZY(Z,le[ht+Rn>>>0]);un+=lt}return De[vt>>>2]=un,0}},z1=(function q2(){var Z={env:jv,wasi_snapshot_preview1:jv};function ue(ht,lt){i.asm=ht.exports,dt((U=i.asm.memory).buffer),function ni(Z){_t.unshift(Z)}(i.asm.__wasm_call_ctors),function tm(Z){if(jt--,i.monitorRunDependencies&&i.monitorRunDependencies(jt),0==jt&&(null!==ha&&(clearInterval(ha),ha=null),$a)){var ue=$a;$a=null,ue()}}()}function Me(ht){ue(ht.instance)}function vt(ht){return function G2(){if(!_&&(p||f)){if("function"==typeof fetch&&!Ol(lr))return fetch(lr,{credentials:"same-origin"}).then(function(Z){if(!Z.ok)throw"failed to load wasm binary file at '"+lr+"'";return Z.arrayBuffer()}).catch(function(){return I1(lr)});if(b)return new Promise(function(Z,ue){b(lr,function(Me){Z(new Uint8Array(Me))},ue)})}return Promise.resolve().then(function(){return I1(lr)})}().then(function(lt){return WebAssembly.instantiate(lt,Z)}).then(function(lt){return lt}).then(ht,function(lt){R("failed to asynchronously prepare wasm: "+lt),Fs(lt)})}if(function vo(Z){jt++,i.monitorRunDependencies&&i.monitorRunDependencies(jt)}(),i.instantiateWasm)try{return i.instantiateWasm(Z,ue)}catch(ht){R("Module.instantiateWasm callback failed with error: "+ht),o(ht)}(function un(){return _||"function"!=typeof WebAssembly.instantiateStreaming||Si(lr)||Ol(lr)||m||"function"!=typeof fetch?vt(Me):fetch(lr,{credentials:"same-origin"}).then(function(ht){return WebAssembly.instantiateStreaming(ht,Z).then(Me,function(Rn){return R("wasm streaming compile failed: "+Rn),R("falling back to ArrayBuffer instantiation"),vt(Me)})})})().catch(o)}(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Acos=function(){return(i._Acos=i.asm.Acos).apply(null,arguments)},i._Acosh=function(){return(i._Acosh=i.asm.Acosh).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._ArgMin=function(){return(i._ArgMin=i.asm.ArgMin).apply(null,arguments)},i._Asin=function(){return(i._Asin=i.asm.Asin).apply(null,arguments)},i._Asinh=function(){return(i._Asinh=i.asm.Asinh).apply(null,arguments)},i._Atan=function(){return(i._Atan=i.asm.Atan).apply(null,arguments)},i._Atan2=function(){return(i._Atan2=i.asm.Atan2).apply(null,arguments)},i._Atanh=function(){return(i._Atanh=i.asm.Atanh).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._AvgPool3D=function(){return(i._AvgPool3D=i.asm.AvgPool3D).apply(null,arguments)},i._AvgPool3DGrad=function(){return(i._AvgPool3DGrad=i.asm.AvgPool3DGrad).apply(null,arguments)},i._AvgPoolGrad=function(){return(i._AvgPoolGrad=i.asm.AvgPoolGrad).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Bincount=function(){return(i._Bincount=i.asm.Bincount).apply(null,arguments)},i._BitwiseAnd=function(){return(i._BitwiseAnd=i.asm.BitwiseAnd).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Conv3D=function(){return(i._Conv3D=i.asm.Conv3D).apply(null,arguments)},i._Conv3DBackpropFilterV2=function(){return(i._Conv3DBackpropFilterV2=i.asm.Conv3DBackpropFilterV2).apply(null,arguments)},i._Conv3DBackpropInputV2=function(){return(i._Conv3DBackpropInputV2=i.asm.Conv3DBackpropInputV2).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DenseBincount=function(){return(i._DenseBincount=i.asm.DenseBincount).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Diag=function(){return(i._Diag=i.asm.Diag).apply(null,arguments)},i._Dilation2D=function(){return(i._Dilation2D=i.asm.Dilation2D).apply(null,arguments)},i._Dilation2DBackpropFilter=function(){return(i._Dilation2DBackpropFilter=i.asm.Dilation2DBackpropFilter).apply(null,arguments)},i._Dilation2DBackpropInput=function(){return(i._Dilation2DBackpropInput=i.asm.Dilation2DBackpropInput).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._EluGrad=function(){return(i._EluGrad=i.asm.EluGrad).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Erf=function(){return(i._Erf=i.asm.Erf).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._Expm1=function(){return(i._Expm1=i.asm.Expm1).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._IsFinite=function(){return(i._IsFinite=i.asm.IsFinite).apply(null,arguments)},i._IsInf=function(){return(i._IsInf=i.asm.IsInf).apply(null,arguments)},i._IsNan=function(){return(i._IsNan=i.asm.IsNan).apply(null,arguments)},i._LRN=function(){return(i._LRN=i.asm.LRN).apply(null,arguments)},i._LRNGrad=function(){return(i._LRNGrad=i.asm.LRNGrad).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._LinSpace=function(){return(i._LinSpace=i.asm.LinSpace).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._Log1p=function(){return(i._Log1p=i.asm.Log1p).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._LogicalNot=function(){return(i._LogicalNot=i.asm.LogicalNot).apply(null,arguments)},i._LogicalOr=function(){return(i._LogicalOr=i.asm.LogicalOr).apply(null,arguments)},i._LogicalXor=function(){return(i._LogicalXor=i.asm.LogicalXor).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._MaxPool3D=function(){return(i._MaxPool3D=i.asm.MaxPool3D).apply(null,arguments)},i._MaxPool3DGrad=function(){return(i._MaxPool3DGrad=i.asm.MaxPool3DGrad).apply(null,arguments)},i._MaxPoolGrad=function(){return(i._MaxPoolGrad=i.asm.MaxPoolGrad).apply(null,arguments)},i._MaxPoolWithArgmax=function(){return(i._MaxPoolWithArgmax=i.asm.MaxPoolWithArgmax).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Mod=function(){return(i._Mod=i.asm.Mod).apply(null,arguments)},i._Multinomial=function(){return(i._Multinomial=i.asm.Multinomial).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Reciprocal=function(){return(i._Reciprocal=i.asm.Reciprocal).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._ResizeBilinearGrad=function(){return(i._ResizeBilinearGrad=i.asm.ResizeBilinearGrad).apply(null,arguments)},i._ResizeNearestNeighbor=function(){return(i._ResizeNearestNeighbor=i.asm.ResizeNearestNeighbor).apply(null,arguments)},i._ResizeNearestNeighborGrad=function(){return(i._ResizeNearestNeighborGrad=i.asm.ResizeNearestNeighborGrad).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SearchSorted=function(){return(i._SearchSorted=i.asm.SearchSorted).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Selu=function(){return(i._Selu=i.asm.Selu).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sign=function(){return(i._Sign=i.asm.Sign).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Sinh=function(){return(i._Sinh=i.asm.Sinh).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._Softplus=function(){return(i._Softplus=i.asm.Softplus).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._SparseToDense=function(){return(i._SparseToDense=i.asm.SparseToDense).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._TensorScatterUpdate=function(){return(i._TensorScatterUpdate=i.asm.TensorScatterUpdate).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)},i.stackSave=function(){return(z1=i.stackSave=i.asm.stackSave).apply(null,arguments)}),B1=i.stackRestore=function(){return(B1=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},Xv=i.stackAlloc=function(){return(Xv=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};function V1(Z){function ue(){im||(im=!0,i.calledRun=!0,!j&&(function ti(){bo(_t)}(),s(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),function gr(){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;)Z=i.postRun.shift(),Ye.unshift(Z);var Z;bo(Ye)}()))}Z=Z||c,jt>0||(function Mn(){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)Z=i.preRun.shift(),St.unshift(Z);var Z;bo(St)}(),jt>0)||(i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),ue()},1)):ue())}if(i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)},i.cwrap=function J2(Z,ue,Me,vt){var un=(Me=Me||[]).every(ht=>"number"===ht||"boolean"===ht);return"string"!==ue&&un&&!vt?E1(Z):function(){return Q2(Z,ue,Me,arguments)}},$a=function Z(){im||V1(),im||($a=Z)},i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();if(V1(),l&&(sm={uncaughtException:process.listeners("uncaughtException").filter(function(Z){return!l.uncaughtException.indexOf(Z)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Z){return!l.unhandledRejection.indexOf(Z)>-1})}),typeof a<"u")om=a;else{if(!(typeof WasmBackendModuleThreadedSimd<"u"))throw new Error("Could not find wasm module in post.js");om=WasmBackendModuleThreadedSimd}if(sm){var wO=om._dispose;om._dispose=function(){wO(),sm.uncaughtException.forEach(function(Z){process.removeListener("uncaughtException",Z)}),sm.unhandledRejection.forEach(function(Z){process.removeListener("unhandledRejection",Z)})}}return a.ready});"object"==typeof e&&"object"==typeof t?t.exports=n:"function"==typeof define&&So.amdO?define([],function(){return n}):"object"==typeof e&&(e.WasmBackendModule=n)}),Yx=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Yg=class{refCount(e){return Ia("refCount")}incRef(e){return Ia("incRef")}timerAvailable(){return!0}time(e){return Ia("time")}read(e){return Ia("read")}readSync(e){return Ia("readSync")}readToGPU(e,t){return Ia("readToGPU")}numDataIds(){return Ia("numDataIds")}disposeData(e,t){return Ia("disposeData")}write(e,t,n){return Ia("write")}move(e,t,n,r,a){return Ia("move")}createTensorFromGPUData(e,t,n){return Ia("createTensorFromGPUData")}memory(){return Ia("memory")}floatPrecision(){return Ia("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Ia("dispose")}};function Ia(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Uj(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Qx(e,t,n)}function Sve(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Qx(e,n,r),Qx(t,n,r)}function Qg(e,t,n){return Math.max(e,Math.min(t,n))}function _ve(e){return e%2==0?e:e+1}function Qx(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function Cve(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Eve(e,t){let n=Math.random();return t*n+(1-n)*e}function kve(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function D(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Fr(e,t,n=""){D(Js(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Iu(e){D(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Mt(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Nve(e){return 0===e.length}function Wj(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function Js(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Jh(e){return e%1==0}function Tve(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function Dve(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Ave(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Uj(t),t}function Jg(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Mve(e,t=(a=>0),n,r){return new Promise((a,i)=>{let s=0,o=()=>{if(e())return void a();s++;let l=t(s);null!=n&&s>=n?i():null!=r?r(o,l):setTimeout(o,l)};o()})}function Rve(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function pi(e,t){let n=t.length;return D((e=null==e?t.map((r,a)=>a):[].concat(e)).every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),D(e.every(r=>Jh(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function jj(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||a?null:pi(t,e).sort(),s=0;for(let o=0;o<e.length;++o){if(null!=i){if(i[s]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==i[s]||i[s]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),i[s]<=o&&s++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Hj(e,t){return nN(e,t)}function nN(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Gj(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function qj(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Fve(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Jx(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Kj(e){if(null==e)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Wo(e){return"string"==typeof e||e instanceof String}function Xj(e){return"boolean"==typeof e}function Zj(e){return"number"==typeof e}function ey(e){return Array.isArray(e)?ey(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Zj(e)?"float32":Wo(e)?"string":Xj(e)?"bool":"float32"}function jo(e){return!!(e&&e.constructor&&e.call&&e.apply)}function e0(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function ep(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Yj(e,t,n,r=!1){let a=new Array;if(1===t.length){let i=t[0]*(r?2:1);for(let s=0;s<i;s++)a[s]=n[e+s]}else{let i=t[0],s=t.slice(1),o=s.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<i;l++)a[l]=Yj(e+l*o,s,n,r)}return a}function tp(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce((a,i)=>a*i)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Yj(0,e,t,n)}function Ove(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function rN(e,t){let n=t0(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function t0(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function $ve(e,t){let n=e.reduce((r,a)=>r*a,1);if(null==t||"float32"===t)return tp(e,new Float32Array(n));if("int32"===t)return tp(e,new Int32Array(n));if("bool"===t)return tp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Sa(e){e.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Pve(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function Lve(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function n0(e){return e&&e.then&&"function"==typeof e.then}var Qj="tfjsflags",Jj=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=zve,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let r=this.urlFlags[e];H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}getAsync(e){var t=this;return F(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(n0(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);Qj in e&&e[Qj].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=function Vve(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,r)})}};function zve(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(function Bve(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("="))),t}function H(){return aN}var iN,aN=null;function eH(){if(null==iN){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");e=self}iN=e}return iN}function sN(e,t){let n=function Wve(){let e=eH();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var np="Abs",Su="Acos",_u="Acosh",Ho="Add",Cu="AddN",rp="All",ap="Any",ip="ArgMax",sp="ArgMin",Eu="Asin",ku="Asinh",Nu="Atan",Tu="Atanh",Du="Atan2",Au="AvgPool",ty="AvgPoolGrad",op="AvgPool3D",ny="AvgPool3DGrad",Mu="BatchMatMul",lp="BatchToSpaceND",up="Bincount",cp="BitwiseAnd",tH="BroadcastTo",ry="BroadcastArgs",Ru="Cast",Fu="Ceil",Go="ClipByValue",r0="Complex",ay="ComplexAbs",dp="Concat",Ou="Conv2D",a0="Conv2DBackpropFilter",$u="Conv2DBackpropInput",Pu="Conv3D",hp="Conv3DBackpropFilterV2",pp="Conv3DBackpropInputV2",Lu="Cos",zu="Cosh",fp="Cumprod",Bu="Cumsum",mp="CropAndResize",iy="DenseBincount",gp="DepthToSpace",Vu="DepthwiseConv2dNative",s0="DepthwiseConv2dNativeBackpropFilter",o0="DepthwiseConv2dNativeBackpropInput",sy="Diag",Uu="Dilation2D",yp="Dilation2DBackpropInput",vp="Dilation2DBackpropFilter",l0="Draw",Wu="RealDiv",u0="Einsum",ju="Elu",bp="EluGrad",Hu="Erf",wp="Equal",Gu="Exp",xp="ExpandDims",qu="Expm1",c0="FFT",oy="Fill",Ip="FlipLeftRight",Ku="Floor",Xu="FloorDiv",Zu="FusedBatchNorm",Sp="GatherV2",_p="GatherNd",Cp="Greater",Yu="GreaterEqual",Qu="Identity",d0="IFFT",h0="Imag",Ju="IsFinite",ec="IsInf",tc="IsNan",nc="LeakyRelu",Ep="Less",kp="LessEqual",Np="LinSpace",rc="Log",ac="Log1p",Tp="LogicalAnd",Dp="LogicalNot",Ap="LogicalOr",nH="LogicalXor",rH="LogSoftmax",jve="LowerBound",ic="LRN",Mp="LRNGrad",Hve="MatrixBandPart",sc="Max",oc="Maximum",lc="MaxPool",ly="MaxPoolGrad",Rp="MaxPool3D",uy="MaxPool3DGrad",cy="MaxPoolWithArgmax",uc="Mean",cc="Min",dc="Minimum",hc="MirrorPad",pc="Mod",Fp="Multinomial",fc="Multiply",Op="Neg",$p="NotEqual",Pp="NonMaxSuppressionV3",Lp="NonMaxSuppressionV4",zp="NonMaxSuppressionV5",Bp="OnesLike",mc="OneHot",Vp="Pack",gc="PadV2",Gve="Pool",yc="Pow",vc="Prelu",bc="Prod",p0="RaggedGather",f0="RaggedRange",m0="RaggedTensorToTensor",dy="Range",g0="Real",wc="Reciprocal",xc="Relu",Up="Reshape",Ic="ResizeNearestNeighbor",Wp="ResizeNearestNeighborGrad",Sc="ResizeBilinear",jp="ResizeBilinearGrad",_c="Relu6",Cc="Reverse",Ec="Round",kc="Rsqrt",Hp="ScatterNd",Gp="TensorScatterUpdate",qp="SearchSorted",Kp="Select",Nc="Selu",Xp="Slice",Tc="Sin",Dc="Sinh",Ac="Sign",Mc="Sigmoid",Rc="Softplus",Fc="Sqrt",Oc="Sum",Zp="SpaceToBatchND",Yp="SplitV",$c="Softmax",hy="SparseFillEmptyRows",Qp="SparseReshape",py="SparseSegmentMean",fy="SparseSegmentSum",Jp="SparseToDense",Pc="SquaredDifference",my="Square",gy="StaticRegexReplace",ef="StridedSlice",yy="StringNGrams",vy="StringSplit",by="StringToHashBucketFast",Lc="Sub",zc="Tan",Bc="Tanh",qo="Tile",tf="TopK",nf="Transform",eo="Transpose",wy="Unique",rf="Unpack",xy="UnsortedSegmentSum",qve="UpperBound",af="ZerosLike",Ko="Step",y0="FromPixels",sf="RotateWithOffset",Vc="_FusedMatMul",Uc="FusedConv2D",Wc="FusedDepthwiseConv2D";function Xo(...e){H().getBool("IS_TEST")||H().getBool("PROD")||console.warn(...e)}function Kve(...e){H().getBool("IS_TEST")||H().getBool("PROD")||console.log(...e)}var lf=sN("kernelRegistry",()=>new Map),Iy=sN("gradRegistry",()=>new Map);function Sy(e,t){let n=lN(e,t);return lf.get(n)}function oN(e){return Iy.get(e)}function v0(e){let t=lf.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[i,s]=a,[o]=i.split("_");o===e&&n.push(s)}return n}function _y(e){let{kernelName:t,backendName:n}=e,r=lN(t,n);lf.has(r)&&Xo(`The kernel '${t}' for backend '${n}' is already registered`),lf.set(r,e)}function aH(e){let{kernelName:t}=e;Iy.has(t)&&H().getBool("DEBUG")&&Xo(`Overriding the gradient for '${t}'`),Iy.set(t,e)}function Xve(e,t){let n=lN(e,t);if(!lf.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);lf.delete(n)}function Zve(e){if(!Iy.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Iy.delete(e)}function Yve(e,t){v0(e).forEach(n=>{_y(Object.assign({},n,{backendName:t}))})}function lN(e,t){return`${t}_${e}`}var I={};function iH(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}je(I,{arraysEqual:()=>Js,arraysEqualWithNull:()=>Wj,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Sa,assertNonNull:()=>Iu,assertShapesMatch:()=>Fr,bytesFromStringArray:()=>Kj,bytesPerElement:()=>Jx,checkConversionForErrors:()=>Gj,clamp:()=>Qg,computeStrides:()=>ep,convertBackendValuesAndArrayBuffer:()=>Ove,createScalarValue:()=>rbe,createShuffledIndices:()=>Ave,decodeString:()=>x0,distSquared:()=>kve,encodeString:()=>ky,fetch:()=>ibe,fingerPrint64:()=>nbe,flatten:()=>Yo,getArrayFromDType:()=>nN,getTypedArrayFromDType:()=>Hj,hasEncodingLoss:()=>Fve,hexToLong:()=>Cy,indexToLoc:()=>Lve,inferDtype:()=>ey,inferFromImplicitShape:()=>Rve,isBoolean:()=>Xj,isFunction:()=>jo,isInt:()=>Jh,isNumber:()=>Zj,isPromise:()=>n0,isScalarShape:()=>Nve,isString:()=>Wo,isTypedArray:()=>er,isValidDtype:()=>qj,locToIndex:()=>Pve,makeOnesTypedArray:()=>rN,makeZerosNestedTypedArray:()=>$ve,makeZerosTypedArray:()=>t0,nearestDivisor:()=>e0,nearestLargerEven:()=>_ve,now:()=>Ey,parseAxisParam:()=>pi,randUniform:()=>Eve,repeatedTry:()=>Mve,rightPad:()=>Jg,shuffle:()=>Uj,shuffleCombo:()=>Sve,sizeFromShape:()=>Mt,sizeToSquarishShape:()=>Dve,squeezeShape:()=>jj,sum:()=>Cve,swap:()=>Qx,tanh:()=>Tve,toNestedArray:()=>tp,toTypedArray:()=>w0});var sH=Uo(sve()),jc=sH.default||sH;function Cy(e){return jc.fromString(e,!0,16)}var oH=Cy("c3a5c85c97cb3127"),Hc=Cy("b492b66fbe98f273"),Or=Cy("9ae16a3b2f90404f");function uN(e){return e.xor(e.shru(47))}function lH(e,t,n){let r=e.slice(t,t+n);return jc.fromBytes(Array.from(r),!0,!0)}function Zt(e,t){return lH(e,t,8)}function uH(e,t){return lH(e,t,4)}function Jn(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Zo(e,t,n=Cy("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function b0(e,t,n,r){return function Qve(e,t,n,r,a,i){a=a.add(e),i=Jn(i.add(a).add(r),21);let s=a;return a=(a=a.add(t)).add(n),i=i.add(Jn(a,44)),[a.add(r),i.add(s)]}(Zt(e,t),Zt(e,t+8),Zt(e,t+16),Zt(e,t+24),n,r)}function nbe(e,t=e.length){let n=jc.fromNumber(81,!0);if(t<=32)return t<=16?function Jve(e,t=e.length){if(t>=8){let n=Or.add(2*t),r=Zt(e,0).add(Or),a=Zt(e,t-8);return Zo(Jn(a,37).mul(n).add(r),Jn(r,25).add(a).mul(n),n)}if(t>=4){let n=Or.add(2*t);return Zo(uH(e,0).shl(3).add(t),uH(e,t-4),n)}if(t>0){let s=t+(e[t-1]<<2);return uN(Or.mul(e[0]+(e[t>>1]<<8)).xor(oH.mul(s))).mul(Or)}return Or}(e,t):function ebe(e,t=e.length){let n=Or.add(2*t),r=Zt(e,0).mul(Hc),a=Zt(e,8),i=Zt(e,t-8).mul(n),s=Zt(e,t-16).mul(Or);return Zo(Jn(r.add(a),43).add(Jn(i,30)).add(s),r.add(Jn(a.add(Or),18)).add(i),n)}(e,t);if(t<=64)return function tbe(e,t=e.length){let n=Or.add(2*t),r=Zt(e,0).mul(Or),a=Zt(e,8),i=Zt(e,t-8).mul(n),s=Zt(e,t-16).mul(Or),o=Jn(r.add(a),43).add(Jn(i,30)).add(s),l=Zo(o,r.add(Jn(a.add(Or),18)).add(i),n),u=Zt(e,16).mul(n),c=Zt(e,24),h=o.add(Zt(e,t-32)).mul(n),d=l.add(Zt(e,t-24)).mul(n);return Zo(Jn(u.add(c),43).add(Jn(h,30)).add(d),u.add(Jn(c.add(r),18)).add(h),n)}(e,t);let r=n,a=n.mul(Hc).add(113),i=uN(a.mul(Or).add(113)).mul(Or),s=[jc.UZERO,jc.UZERO],o=[jc.UZERO,jc.UZERO];r=r.mul(Or).add(Zt(e,0));let l=0,u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Jn(r.add(a).add(s[0]).add(Zt(e,l+8)),37).mul(Hc),a=Jn(a.add(s[1]).add(Zt(e,l+48)),42).mul(Hc),r=r.xor(o[1]),a=a.add(s[0]).add(Zt(e,l+40)),i=Jn(i.add(o[0]),33).mul(Hc),s=b0(e,l,s[1].mul(Hc),r.add(o[0])),o=b0(e,l+32,i.add(o[1]),a.add(Zt(e,l+16))),[i,r]=[r,i],l+=64}while(l!==u);let h=Hc.add(i.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),s[0]=s[0].add(o[0]),o[0]=o[0].add(s[0]),r=Jn(r.add(a).add(s[0]).add(Zt(e,l+8)),37).mul(h),a=Jn(a.add(s[1]).add(Zt(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),a=a.add(s[0].mul(9).add(Zt(e,l+40))),i=Jn(i.add(o[0]),33).mul(h),s=b0(e,l,s[1].mul(h),r.add(o[0])),o=b0(e,l+32,i.add(o[1]),a.add(Zt(e,l+16))),[i,r]=[r,i],Zo(Zo(s[0],o[0],h).add(uN(a).mul(oH)).add(i),Zo(s[1],o[1],h).add(r),h)}function rbe(e,t){return"string"===t?ky(e):w0([e],t)}function w0(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Yo(e)),H().getBool("DEBUG")&&Gj(e,t),function abe(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)0!==Math.round(e[r])&&(n[r]=1);return n}throw new Error(`Unknown data type ${t}`)}function Ey(){return H().platform.now()}function ibe(e,t){return H().platform.fetch(e,t)}function ky(e,t="utf-8"){return t=t||"utf-8",H().platform.encode(e,t)}function x0(e,t="utf-8"){return t=t||"utf-8",H().platform.decode(e,t)}function er(e){return null!=H().platform.isTypedArray?H().platform.isTypedArray(e):iH(e)}function Yo(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||n0(e)||null==e||er(e)&&n)t.push(e);else if(Array.isArray(e)||er(e))for(let r=0;r<e.length;++r)Yo(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)Yo(e[a],t,n)}return t}var sbe=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new lbe)}profileKernel(e,t,n){let r,i,a=()=>{r=n()},s=Ey();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();i=Promise.resolve({kernelMs:Ey()-s})}if(H().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{obe(u,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(o=>o.kernelMs),extraInfo:i.then(o=>null!=o.getExtraProfileInfo?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:i}=e;n.forEach(s=>{Promise.all([s.data(),r,i]).then(o=>{this.logger.logKernelProfile(t,s,o[0],o[1],a,o[2])})})}};function obe(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var lbe=class{logKernelProfile(e,t,n,r,a,i){let s="number"==typeof r?Jg(`${r}ms`,9):r.error,o=Jg(e,25),l=t.rank,u=t.size,c=Jg(t.shape.toString(),14),h="";for(let d in a){let p=a[d];if(null!=p){let f=p.shape||t.shape,m=f.length;h+=`${d}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}\t%c${s}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}},cH=20,Ny=3,cN=7;function dbe(e,t,n,r){let a=ep(t),i=function hbe(e,t,n,r){let a=Mt(t),i=r[r.length-1],s=new Array(i).fill(0),o=t.length,l="complex64"===n?Dy(e):e;if(o>1)for(let u=0;u<a/i;u++){let c=u*i;for(let h=0;h<i;h++)s[h]=Math.max(s[h],Ty(l[c+h],0,n).length)}return s}(e,t,n,a),s=t.length,o=I0(e,t,n,a,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${s}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join("\n")),l.join("\n")}function Ty(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(cN))} + ${parseFloat(e[1].toFixed(cN))}j`:Wo(e)?`'${e}'`:"bool"===n?dH(e):parseFloat(e.toFixed(cN)).toString(),Jg(r,t)}function dH(e){return 0===e?"false":"true"}function I0(e,t,n,r,a,i=!0){let s="complex64"===n?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===n?[Ty(Dy(e)[0],0,n)]:"bool"===n?[dH(e[0])]:[e[0].toString()];if(1===l){if(o>cH){let g=Array.from(e.slice(0,Ny*s)),y=Array.from(e.slice((o-Ny)*s,o*s));return"complex64"===n&&(g=Dy(g),y=Dy(y)),["["+g.map((v,b)=>Ty(v,a[b],n)).join(", ")+", ..., "+y.map((v,b)=>Ty(v,a[o-Ny+b],n)).join(", ")+"]"]}return["["+("complex64"===n?Dy(e):Array.from(e)).map((m,g)=>Ty(m,a[g],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),h=r[0]*s,d=[];if(o>cH){for(let m=0;m<Ny;m++){let g=m*h;d.push(...I0(e.slice(g,g+h),u,n,c,a,!1))}d.push("...");for(let m=o-Ny;m<o;m++){let g=m*h;d.push(...I0(e.slice(g,g+h),u,n,c,a,m===o-1))}}else for(let m=0;m<o;m++){let g=m*h;d.push(...I0(e.slice(g,g+h),u,n,c,a,m===o-1))}let p=2===l?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Dy(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var En=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Mt(e),null!=n){let r=n.length;D(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||nN(t,this.size),this.strides=ep(e)}set(e,...t){0===t.length&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Vi().makeTensor(this.values,this.shape,this.dtype)}},Vi=null,uf=null,Ze=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Mt(e),this.strides=ep(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return F(function*(){let t=yield e.data();return uf.buffer(e.shape,e.dtype,t)})()}bufferSync(){return uf.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return F(function*(){let t=yield e.data();return tp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return tp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return F(function*(){e.throwIfDisposed();let t=Vi().read(e.dataId);if("string"===e.dtype){let n=yield t;try{return n.map(r=>x0(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataToGPU(e){return this.throwIfDisposed(),Vi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Vi().readSync(this.dataId);if("string"===this.dtype)try{return e.map(t=>x0(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return F(function*(){e.throwIfDisposed();let t=yield Vi().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Vi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return uf.print(this,e)}clone(){return this.throwIfDisposed(),uf.clone(this)}toString(e=!1){return dbe(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),uf.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Vi().makeVariable(this,e,t,n)}};function Q(){return sN("Tensor",()=>Ze)}Object.defineProperty(Ze,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Q();var Gc=class extends Ze{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Js(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Vi().disposeTensor(this),this.dataId=e.dataId,Vi().incRef(this,null)}dispose(){Vi().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Gc,Symbol.hasInstance,{value:e=>e instanceof Ze&&null!=e.assign&&e.assign instanceof Function});var dN,e,hN,pN,fN,mN,Ui={};je(Ui,{assertTypesMatch:()=>fH,getTensorsInContainer:()=>gN,isTensorInList:()=>vbe,makeTypesMatch:()=>pn}),(e=dN||(dN={})).R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(hN||(hN={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(pN||(pN={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(fN||(fN={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(mN||(mN={}));var ybe={float32:fN,int32:hN,bool:pN,complex64:mN};function Ga(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ybe[e][t]}function S0(e){return Ga(e,"int32")}function hH(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function pH(e){return typeof GPUBuffer<"u"&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function pn(e,t){if(e.dtype===t.dtype)return[e,t];let n=Ga(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function fH(e,t){D(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function vbe(e,t){return t.some(n=>n.id===e.id)}function gN(e){let t=[];return mH(e,t,new Set),t}function mH(e,t,n){if(null==e)return;if(e instanceof Ze)return void t.push(e);if(!function bbe(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let i=r[a];n.has(i)||(n.add(i),mH(i,t,n))}}function yN(e){return null!=e.kernelName}var gH=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},vN=class CO{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new gH}ready(){var t=this;return F(function*(){if(null!=t.pendingBackendInit)return t.pendingBackendInit.then(()=>{});if(null!=t.backendInstance)return;let n=t.getSortedBackends();for(let r=0;r<n.length;r++){let a=n[r];if(yield t.initializeBackend(a).success)return void(yield t.setBackend(a))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{let{asyncInit:n}=this.initializeBackend(t);if(n)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Xo(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}setBackend(t){var n=this;return F(function*(){if(null==n.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(n.backendName=t,null==n.registry[t]){n.backendInstance=null;let{success:r,asyncInit:a}=n.initializeBackend(t);if(!(a?yield r:r))return!1}return n.backendInstance=n.registry[t],n.setupRegisteredKernels(),n.profiler=new sbe(n.backendInstance),!0})()}setupRegisteredKernels(){v0(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){v0(t).forEach(n=>{null!=n.disposeFunc&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(null==n)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(!r||r instanceof Yg||"function"!=typeof r.then)return this.registry[t]=r,{success:!0,asyncInit:!1};{let a=++this.pendingBackendInitId,i=r.then(s=>!(a<this.pendingBackendInitId||(this.registry[t]=s,this.pendingBackendInit=null,0))).catch(s=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,Xo(`Initialization of backend ${t} failed`),Xo(s.stack||s.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(r){return Xo(`Initialization of backend ${t} failed`),Xo(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:a,asyncInit:i}=this.initializeBackend(r);if(i||a)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),a=r.backend,i=this.readSync(n),s=a.refCount(n);a.disposeData(n,!0),r.backend=t,t.move(n,i,r.shape,r.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a,r=null;if(null==n){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");n=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof n)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,n,r){t();try{let a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return CO.nextTensorId++}nextVariableId(){return CO.nextVariableId++}clone(t){let n=P.runKernel(Qu,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[n],s=>({x:()=>P.runKernel(Ru,{x:s},{dtype:"float32"})}),[],{}),n}runKernel(t,n,r){if(null==Sy(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let a=this.backend.numDataIds(),i=0;r.forEach(l=>{i+="complex64"===l.dtype?3:1});let o=a-n-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,o,r=[],a=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l,u=yN(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(yN(t)){let{kernelName:f,inputs:m,attrs:g}=t,y=Sy(f,this.backendName);D(null!=y,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let v=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,v,b);let w=b.map(x=>null!=x.rank?x:this.makeTensorFromTensorInfo(x));if(a){let x=this.getTensorsForGradient(f,m,w);r=this.saveTensorsForBackwardMode(x)}return w}}else{let{forwardFunc:f}=t,m=g=>{a&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}let p,{inputs:c,attrs:h}=t,d=yN(t)?null:t.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs):n=o()}),a&&this.addTapeNode(u,c,n,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>null!=c[f]?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let a=oN(t);if(null!=a){let o,i=a.inputsToSave||[],s=a.outputsToSave||[];a.saveAllInputs?(D(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=i.map(u=>n[u]);let l=r.filter((u,c)=>s[c]);return o.concat(l)}return[]}makeTensor(t,n,r,a){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");a=a||this.backend;let i=t;"string"===(r=r||"float32")&&Wo(t[0])&&(i=t.map(l=>ky(l)));let s=a.write(i,n,r),o=new Ze(n,r,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===r){let l=this.state.tensorInfo.get(s),u=Kj(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,a){return this.makeTensorFromTensorInfo({dataId:t,shape:n,dtype:r=r||"float32"},a)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:a,dtype:i}=t,s=new Ze(a,i,r,this.nextTensorId());return this.trackTensor(s,n),s}makeVariable(t,n=!0,r,a){r=r||this.nextVariableId().toString(),null!=a&&a!==t.dtype&&(t=t.cast(a));let i=new Gc(t,n,r,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,n){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*Jx(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Gc||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){let r=t.size*Jx(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){var n=this;return F(function*(){n.state.profiling=!0;let r=n.state.numBytes,a=n.state.numTensors;n.state.activeProfile.kernels=[],n.state.activeProfile.result=yield t(),n.state.profiling=!1,n.state.activeProfile.peakBytes=Math.max(...n.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),n.state.activeProfile.newBytes=n.state.numBytes-r,n.state.activeProfile.newTensors=n.state.numTensors-a;for(let i of n.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return n.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,n,r,a,i,s){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:i},l=oN(t);null!=l&&(a=l.gradFunc),null!=a&&(o.gradient=u=>(u=u.map((c,h)=>{if(null==c){let d=r[h],p=t0(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),a(u.length>1?u:u[0],i,s))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=gN(t),r=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let s=this.state.activeScope.track[i];!s.kept&&!r.has(s.id)&&s.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===a.id&&this.track(i)})}gradients(t,n,r,a=!1){if(D(n.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));D(i instanceof Ze,()=>"The result y returned by f() must be a tensor.");let s=function ube(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let h in c){let d=c[h],p=!1;for(let f=0;f<t.length;f++)if(r[d.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,a[u.id]=!0;break}if(p)break}}let i={};i[n.id]=!0;let s={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(i[u.outputs[h].id]){for(let d in c)i[c[d].id]=!0,s[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(a[u.id]&&s[u.id]){let c={};for(let d in u.inputs){let p=u.inputs[d];r[p.id]&&(c[d]=p)}let h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,o.push(h)}}return o}(this.state.activeTape,n,i);if(!a&&0===s.length&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[i.id]=r??function wbe(e){let t=rN(Mt(e),"float32");return P.makeTensor(t,e,"float32")}(i.shape),function cbe(e,t,n,r){for(let a=t.length-1;a>=0;a--){let i=t[a],s=[];if(i.outputs.forEach(l=>{let u=e[l.id];s.push(null!=u?u:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);let o=i.gradient(s);for(let l in i.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=i.inputs[l];if(!Js(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==e[c.id])e[c.id]=u;else{let h=e[c.id];e[c.id]=r(h,u),h.dispose()}}}}(o,s,u=>this.tidy(u),xbe);let l=n.map(u=>o[u.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return D(jo(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{D(n.every(o=>o instanceof Ze),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,a={};return n.forEach((o,l)=>{a[l]=o}),this.runKernelFunc({forwardFunc:(o,l)=>(r=t(...n,l),D(r.value instanceof Ze,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(jo(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(o,l)=>{let u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];D(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(c.every(d=>d instanceof Ze),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return c.forEach((d,p)=>{h[p]=()=>d}),h},inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}time(t){var n=this;return F(function*(){let r=Ey(),a=yield n.backend.time(t);return a.wallMs=Ey()-r,a})()}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new gH;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function yH(){let e=eH();if(null==e._tfengine){let t=new Jj(e);e._tfengine=new vN(t)}return function Uve(e){aN=e}(e._tfengine.ENV),function fbe(e){Vi=e}(()=>e._tfengine),e._tfengine}vN.nextTensorId=0,vN.nextVariableId=0;var P=yH();function xbe(e,t){return P.runKernel(Ho,{a:e,b:t})}var bN,Ay={};function Sbe(e){bN=e}function _be(e){if(void 0!==bN)return bN;if(e||function Ibe(){return typeof navigator<"u"&&null!=navigator}()){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):e.userAgentData&&e.userAgentData.mobile}return!1}function vH(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}je(Ay,{isBrowser:()=>vH,isMobile:()=>_be,mockIsMobile:()=>Sbe});var ra=H();function ys(e,t){let n=e;if(er(e))return"string"===t?[]:[e.length];if(hH(e))return[e.height,e.width*(e.channels||"RGBA").length];if(pH(e))return[e.buffer.size/(null==t?4:Jx(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||er(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&H().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&bH(e,r,[]),r}function bH(e,t,n){if(n=n||[],!Array.isArray(e)&&!er(e))return void D(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);D(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),D(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)bH(e[a],r,n.concat(a))}function wH(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function N(e,t,n,r="numeric"){if(e instanceof Q())return wH(r,e.dtype,t,n),e;let a=ey(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),wH(r,a,t,n),null==e||!er(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);let i=ys(e,a);!er(e)&&!Array.isArray(e)&&(e=[e]);let s="string"!==a?w0(e,a):Yo(e,[],!0);return P.makeTensor(s,i,a)}function My(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,i)=>N(a,`${t}[${i}]`,n,r))}ra.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ra.registerFlag("IS_BROWSER",()=>vH()),ra.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ra.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ra.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),ra.registerFlag("PROD",()=>!1),ra.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ra.getBool("DEBUG")),ra.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ra.registerFlag("IS_TEST",()=>!1),ra.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ra.getBool("DEBUG")),ra.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),ra.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),ra.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var wN="__op";function L(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=wN;let a=(...i)=>{P.startScope(n);try{let s=r(...i);return n0(s)&&console.error("Cannot return a Promise inside of tidy."),P.endScope(s),s}catch(s){throw P.endScope(null),s}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var to=L({complex_:function Cbe(e,t){let n=N(e,"real","complex"),r=N(t,"imag","complex");return Fr(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),P.runKernel(r0,{real:n,imag:r})}});function Qo(e,t,n,r){if(null==r)r=ey(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(pH(e)||hH(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return P.backend.createTensorFromGPUData(e,t||n,r)}if(!er(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Sa(t);let a=Mt(t),i=Mt(n);D(a===i,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${i}`);for(let s=0;s<n.length;++s){let l=s!==n.length-1||n[s]!==Mt(t.slice(s));D(n[s]===t[s]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!er(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?w0(e,r):Yo(e,[],!0),P.makeTensor(e,t,r)}function $r(e,t,n){return Qo(e,t,ys(e,n),n)}var qc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},no=class oQ{static join(t){return new oQ(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t||(t instanceof Array||(t=[t]),0===(t=t.map(r=>er(r)?r.buffer:r)).length))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let i=n+a.byteLength;this.shards.push({buffer:a,start:n,end:i}),n=i}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),(n=Math.min(this.byteLength,n))<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);let i=new ArrayBuffer(n-t),s=new Uint8Array(i),o=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],c=t+o-u.start,h=o,d=Math.min(n,u.end)-u.start,p=new Uint8Array(u.buffer,c,d-c);if(s.set(p,h),o+=p.length,n<u.end)break}return i}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(a){return t<a.start?-1:t>=a.end?1:0}if(0===n(this.shards[this.previousShardIndex]))return this.previousShardIndex;let r=function Ebe(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,i=t(e[a]);if(0===i)return a;i<0?r=a:n=a+1}return-1}(this.shards,n);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function kbe(){H().set("PROD",!0)}function Nbe(){H().set("DEBUG",!0)}function Tbe(){H().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function xN(e){H().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Dbe(){P.disposeVariables()}function fi(){return P}function _0(){return P.memory()}function Abe(e){return P.profile(e)}function V(e,t){return P.tidy(e,t)}function He(e){gN(e).forEach(t=>t.dispose())}function Bn(e){return P.keep(e)}function Mbe(e){return P.time(e)}function Rbe(e){return P.setBackend(e)}function Fbe(){return P.ready()}function xH(){return P.backendName}function Obe(e){P.removeBackend(e)}function $be(e){return P.findBackend(e)}function Pbe(e){return P.findBackendFactory(e)}function C0(e,t,n=1){return P.registerBackend(e,t,n)}function IN(){return P.backend}function Lbe(e,t){H().setPlatform(e,t)}var Jo=4;function zbe(e,t){return SN.apply(this,arguments)}function SN(){return SN=F(function*(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);for(let s=0;s<a.length;++s){let o=a[s],l=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){let c=new Promise(function(){var h=F(function*(d){let p=yield l.bytes(),f=p.reduce((y,v)=>y+v.length,0)+Jo*p.length,m=new Uint8Array(f),g=0;for(let y=0;y<p.length;y++){let v=p[y],b=new Uint8Array(new Uint32Array([v.length]).buffer);m.set(b,g),g+=Jo,m.set(v,g),g+=v.length}d(m)});return function(d){return h.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=t&&(u.group=t),n.push(u)}return{data:Ube(yield Promise.all(r)),specs:n}}),SN.apply(this,arguments)}function IH(e,t){let n=new no(e),r={},a=0;for(let i of t){let s=Bbe(i,(o,l)=>n.slice(a+o,a+l));r[i.name]=SH(i,n.slice(a,a+s)),a+=s}return r}function Bbe(e,t){let r,n=Mt(e.shape);if("quantization"in e)r=qc[e.quantization.dtype];else{if("string"===e.dtype){let a=0;for(let i=0;i<n;i++)a+=Jo+new Uint32Array(t(a,a+Jo))[0];return a}r=qc[e.dtype]}return n*r}function Vbe(e,t){return _N.apply(this,arguments)}function _N(){return _N=F(function*(e,t){let r,n=Mt(e.shape);if("quantization"in e)r=qc[e.quantization.dtype];else{if("string"===e.dtype){let a=0;for(let i=0;i<n;i++)a+=Jo+new Uint32Array(yield t(a,a+Jo))[0];return a}r=qc[e.dtype]}return n*r}),_N.apply(this,arguments)}function SH(e,t){let s,n=e.name,r=e.dtype,a=e.shape,i=Mt(a),o=0;if("quantization"in e){let l=e.quantization;if("uint8"===l.dtype||"uint16"===l.dtype){if(!("min"in l)||!("scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==l.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}let u=qc[l.dtype],c="uint8"===l.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===l.dtype||"uint16"===l.dtype){s=new Float32Array(c.length);for(let h=0;h<c.length;h++)s[h]=c[h]*l.scale+l.min}else{if("float16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);s=function Xbe(){let e=function Gbe(){let e=n=>{let r=n<<13,a=0;for(;!(8388608&r);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function qbe(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function Kbe(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),i=new Uint32Array(a);for(let s=0;s<r.length;s++){let o=r[s];i[s]=e[n[o>>10]+(1023&o)]+t[o>>10]}return new Float32Array(a)}}()(c)}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);s=new Int32Array(c.length);for(let h=0;h<c.length;h++)s[h]=Math.round(c[h]*l.scale+l.min)}o+=i*u}else if("string"===r){let l=Mt(e.shape);s=[];for(let u=0;u<l;u++){let c=new Uint32Array(t.slice(o,o+Jo))[0];o+=Jo;let h=new Uint8Array(t.slice(o,o+c));s.push(h),o+=c}}else{let l=qc[r];if("float32"===r)s=new Float32Array(t);else if("int32"===r)s=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){s=new Float32Array(t);let u=new Float32Array(s.length/2),c=new Float32Array(s.length/2);for(let f=0;f<u.length;f++)u[f]=s[2*f],c[f]=s[2*f+1];let h=$r(u,a,"float32"),d=$r(c,a,"float32"),p=to(h,d);return h.dispose(),d.dispose(),p}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}s=new Uint8Array(t)}o+=i*l}return $r(s,a,r)}function _H(e,t,n){return CN.apply(this,arguments)}function CN(){return CN=F(function*(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:a,value:i}=yield e.read();if(a&&null==i)throw new Error(`Reader is done but ${n-r.byteLength} bytes are still expected`);let s=new Uint8Array(r.length+i.byteLength);s.set(r,0),s.set(new Uint8Array(i),r.length),r=s}return r.buffer}),CN.apply(this,arguments)}function CH(e,t){return EN.apply(this,arguments)}function EN(){return EN=F(function*(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let i of t){let s=yield Vbe(i,function(){var u=F(function*(c,h){return a=yield _H(r,a,h),a.slice(c,h)});return function(c,h){return u.apply(this,arguments)}}());a=yield _H(r,a,s);let o=a.slice(0,s);a=a.slice(s);let l=SH(i,o);if(n[i.name]=l,"webgpu"===xH()){let u=IN();"uploadToGPU"in u&&Mt(l.shape)>=H().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}),EN.apply(this,arguments)}function Ube(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(i=>{if(t+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(i=>{r.set(new Uint8Array(i.buffer),a),a+=i.byteLength}),r.buffer}var kN=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function EH(e){return kN?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Hbe(e){return no.join(e)}function kH(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let n=e.split("/");return n[n.length-1]}function NH(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function TH(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}function NN(e,t){return TN.apply(this,arguments)}function TN(){return TN=F(function*(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=yield t(e.weightsManifest)),TH(e,n,r)}),TN.apply(this,arguments)}function Ry(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:EH(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:EH(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new no(e.weightData).byteLength}}function DN(e){let t=[];for(let n of e)t.push(...n.weights);return t}var qa=class Qi{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Qi.instance&&(Qi.instance=new Qi),Qi.instance}static registerSaveRouter(t){Qi.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Qi.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Qi.getHandlers(t,"save")}static getLoadHandlers(t,n){return Qi.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?Qi.getInstance().loadRouters:Qi.getInstance().saveRouters).forEach(i=>{let s=i(t,r);null!==s&&a.push(s)}),a}},Zbe=e=>qa.registerSaveRouter(e),Ybe=e=>qa.registerLoadRouter(e),Qbe=e=>qa.getSaveHandlers(e),Jbe=(e,t)=>qa.getLoadHandlers(e,t),AN="tensorflowjs",Kc="models_store",el="model_info_store";function DH(){if(!H().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function RN(e){let t=e.result;t.createObjectStore(Kc,{keyPath:"modelPath"}),t.createObjectStore(el,{keyPath:"modelPath"})}var cf=(()=>{let e=class{constructor(t){if(this.indexedDB=DH(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){var n=this;return F(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return n.databaseAction(n.modelPath,t)})()}load(){var t=this;return F(function*(){return t.databaseAction(t.modelPath)})()}databaseAction(t,n){return new Promise((r,a)=>{let i=this.indexedDB.open(AN,1);i.onupgradeneeded=()=>RN(i),i.onsuccess=()=>{let s=i.result;if(null==n){let o=s.transaction(Kc,"readonly"),l=o.objectStore(Kc).get(this.modelPath);l.onsuccess=()=>{if(null==l.result)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=u=>(s.close(),a(l.error)),o.oncomplete=()=>s.close()}else{n.weightData=no.join(n.weightData);let c,h,o=Ry(n),l=s.transaction(el,"readwrite"),u=l.objectStore(el);try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(d){return a(d)}c.onsuccess=()=>{h=s.transaction(Kc,"readwrite");let p,d=h.objectStore(Kc);try{p=d.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return a(f)}p.onsuccess=()=>r({modelArtifactsInfo:o}),p.onerror=f=>{u=l.objectStore(el);let m=u.delete(this.modelPath);m.onsuccess=()=>(s.close(),a(p.error)),m.onerror=g=>(s.close(),a(p.error))}},c.onerror=d=>(s.close(),a(c.error)),l.oncomplete=()=>{null==h?s.close():h.oncomplete=()=>s.close()}}},i.onerror=s=>a(i.error)})}};return e.URL_SCHEME="indexeddb://",e})(),AH=e=>H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(cf.URL_SCHEME)?function ewe(e){return new cf(e)}(e.slice(cf.URL_SCHEME.length)):null;qa.registerSaveRouter(AH),qa.registerLoadRouter(AH);var ro="/",df="tensorflowjs_models",MH="info",rwe="model_topology",awe="weight_specs",iwe="weight_data",swe="model_metadata";function RH(e){return{info:[df,e,MH].join(ro),topology:[df,e,rwe].join(ro),weightSpecs:[df,e,awe].join(ro),weightData:[df,e,iwe].join(ro),modelMetadata:[df,e,swe].join(ro)}}function FH(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function owe(e){let t=e.split(ro);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ro)}var hf=(()=>{let e=class{constructor(t){if(!H().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=RH(this.modelPath)}save(t){var n=this;return F(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(t.modelTopology),a=JSON.stringify(t.weightSpecs),i=Ry(t),s=no.join(t.weightData);try{return n.LS.setItem(n.keys.info,JSON.stringify(i)),n.LS.setItem(n.keys.topology,r),n.LS.setItem(n.keys.weightSpecs,a),n.LS.setItem(n.keys.weightData,function Wbe(e){if(kN)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s)),n.LS.setItem(n.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch{throw FH(n.keys),new Error(`Failed to save model '${n.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var t=this;return F(function*(){let n=JSON.parse(t.LS.getItem(t.keys.info));if(null==n)throw new Error(`In local storage, there is no model with name '${t.modelPath}'`);if("JSON"!==n.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},a=JSON.parse(t.LS.getItem(t.keys.topology));if(null==a)throw new Error(`In local storage, the topology of model '${t.modelPath}' is missing.`);r.modelTopology=a;let i=JSON.parse(t.LS.getItem(t.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${t.modelPath}' are missing.`);r.weightSpecs=i;let s=t.LS.getItem(t.keys.modelMetadata);if(null!=s){let l=JSON.parse(s);r.format=l.format,r.generatedBy=l.generatedBy,r.convertedBy=l.convertedBy,null!=l.signature&&(r.signature=l.signature),null!=l.userDefinedMetadata&&(r.userDefinedMetadata=l.userDefinedMetadata),null!=l.modelInitializer&&(r.modelInitializer=l.modelInitializer),null!=l.initializerSignature&&(r.initializerSignature=l.initializerSignature),null!=l.trainingConfig&&(r.trainingConfig=l.trainingConfig)}let o=t.LS.getItem(t.keys.weightData);if(null==o)throw new Error(`In local storage, the binary weight values of model '${t.modelPath}' are missing.`);return r.weightData=function jbe(e){if(kN){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(o),r})()}};return e.URL_SCHEME="localstorage://",e})(),OH=e=>H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(hf.URL_SCHEME)?function uwe(e){return new hf(e)}(e.slice(hf.URL_SCHEME.length)):null;qa.registerSaveRouter(OH),qa.registerLoadRouter(OH);var pf="://",tl=class zl{constructor(){this.managers={}}static getInstance(){return null==zl.instance&&(zl.instance=new zl),zl.instance}static registerManager(t,n){D(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(pf)&&(t=t.slice(0,t.indexOf(pf))),D(t.length>0,()=>"scheme must not be an empty string.");let r=zl.getInstance();D(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=zl.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(zl.getInstance().managers)}};function E0(e){if(-1===e.indexOf(pf))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${tl.getSchemes().join(",")}`);return{scheme:e.split(pf)[0],path:e.split(pf)[1]}}function $H(e,t){return FN.apply(this,arguments)}function FN(){return FN=F(function*(e,t,n=!1){D(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=qa.getLoadHandlers(e);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],i=qa.getSaveHandlers(t);D(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let s=i[0],o=E0(e).scheme,l=E0(e).path,u=o===E0(e).scheme,c=yield a.load();n&&u&&(yield tl.getManager(o).removeModel(l));let h=yield s.save(c);return n&&!u&&(yield tl.getManager(o).removeModel(l)),h.modelArtifactsInfo}),FN.apply(this,arguments)}function dwe(){return ON.apply(this,arguments)}function ON(){return ON=F(function*(){let e=tl.getSchemes(),t={};for(let n of e){let r=yield tl.getManager(n).listModels();for(let a in r)t[n+pf+a]=r[a]}return t}),ON.apply(this,arguments)}function hwe(e){return $N.apply(this,arguments)}function $N(){return $N=F(function*(e){let t=E0(e);return tl.getManager(t.scheme).removeModel(t.path)}),$N.apply(this,arguments)}function pwe(e,t){return PN.apply(this,arguments)}function PN(){return PN=F(function*(e,t){return $H(e,t,!1)}),PN.apply(this,arguments)}function fwe(e,t){return LN.apply(this,arguments)}function LN(){return LN=F(function*(e,t){return $H(e,t,!0)}),LN.apply(this,arguments)}if(H().get("IS_BROWSER")){H().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){typeof window>"u"||!H().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(e,t):(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{n.source===window&&n.data.name===this.messageName&&(n.stopPropagation(),(0,this.functionRefs[n.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(e){return iH(e)}});try{tl.registerManager(hf.URL_SCHEME,new class{constructor(){D(H().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return F(function*(){let t={},n=df+ro,r=ro+MH;for(let a=0;a<e.LS.length;++a){let i=e.LS.key(a);i.startsWith(n)&&i.endsWith(r)&&(t[owe(i)]=JSON.parse(e.LS.getItem(i)))}return t})()}removeModel(e){var t=this;return F(function*(){let n=RH(e=function lwe(e){return e.startsWith(hf.URL_SCHEME)?e.slice(hf.URL_SCHEME.length):e}(e));if(null==t.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);let r=JSON.parse(t.LS.getItem(n.info));return FH(n),r})()}})}catch{}try{tl.registerManager(cf.URL_SCHEME,new class{constructor(){this.indexedDB=DH()}listModels(){var e=this;return F(function*(){return new Promise((t,n)=>{let r=e.indexedDB.open(AN,1);r.onupgradeneeded=()=>RN(r),r.onsuccess=()=>{let a=r.result,i=a.transaction(el,"readonly"),s=i.objectStore(el).getAll();s.onsuccess=()=>{let o={};for(let l of s.result)o[l.modelPath]=l.modelArtifactsInfo;t(o)},s.onerror=o=>(a.close(),n(s.error)),i.oncomplete=()=>a.close()},r.onerror=a=>n(r.error)})})()}removeModel(e){var t=this;return F(function*(){return e=function twe(e){return e.startsWith(cf.URL_SCHEME)?e.slice(cf.URL_SCHEME.length):e}(e),new Promise((n,r)=>{let a=t.indexedDB.open(AN,1);a.onupgradeneeded=()=>RN(a),a.onsuccess=()=>{let u,i=a.result,s=i.transaction(el,"readwrite"),o=s.objectStore(el),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=o.delete(e),h=()=>{u=i.transaction(Kc,"readwrite");let d=u.objectStore(Kc).delete(e);d.onsuccess=()=>n(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};c.onsuccess=h,c.onerror=d=>(h(),i.close(),r(l.error))}},l.onerror=c=>(i.close(),r(l.error)),s.oncomplete=()=>{null==u?i.close():u.oncomplete=()=>i.close()}},a.onerror=i=>r(a.error)})})()}})}catch{}}var zN;function Je(e,t="float32",n){return t=t||"float32",Sa(e),new En(e,t,n)}H().get("IS_NODE")&&!H().get("IS_BROWSER")&&H().setPlatform("node",new class{constructor(){this.util=lve(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=H().global.fetch?H().global.fetch(e,t):(null==zN&&(zN=ove()),zN(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var de=L({cast_:function vwe(e,t){let n=N(e,"x","cast");if(!qj(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return P.runKernel(Ru,{x:n},{dtype:t})}}),vs=L({clone_:function bwe(e){let t={x:N(e,"x","clone","string_or_numeric")};return P.runKernel(Qu,t)}});function BN(e,t=!1){console.log(e.toString(t))}yH(),function mbe(e){uf=e}({buffer:Je,cast:de,clone:vs,print:BN});var J=L({add_:function xwe(e,t){let n=N(e,"a","add"),r=N(t,"b","add");return[n,r]=pn(n,r),P.runKernel(Ho,{a:n,b:r})}}),k0=L({floorDiv_:function Iwe(e,t){let n=N(e,"a","floorDiv"),r=N(t,"b","floorDiv");return[n,r]=pn(n,r),P.runKernel(Xu,{a:n,b:r})}}),ve=L({div_:function Swe(e,t){let n=N(e,"a","div"),r=N(t,"b","div");return[n,r]=pn(n,r),"int32"===n.dtype&&"int32"===r.dtype?k0(n,r):P.runKernel(Wu,{a:n,b:r},{})}}),z=L({mul_:function _we(e,t){let n=N(e,"a","mul"),r=N(t,"b","mul");return[n,r]=pn(n,r),P.runKernel(fc,{a:n,b:r})}}),kn=L({abs_:function Cwe(e){let t=N(e,"x","abs");return P.runKernel("complex64"===t.dtype?ay:np,{x:t})}}),VN=L({acos_:function Ewe(e){let t={x:N(e,"x","acos")};return P.runKernel(Su,t)}}),UN=L({acosh_:function kwe(e){let t={x:N(e,"x","acosh")};return P.runKernel(_u,t)}}),PH=L({addN_:function Nwe(e){D(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),D(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,i)=>N(a,`tensors${i}`,"addN")),n=t[0];return t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!Js(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),P.runKernel(Cu,t)}}),N0=L({all_:function Twe(e,t=null,n=!1){let r={x:N(e,"x","all","bool")};return P.runKernel(rp,r,{axis:t,keepDims:n})}}),Fy=L({any_:function Dwe(e,t=null,n=!1){let r={x:N(e,"x","any","bool")};return P.runKernel(ap,r,{axis:t,keepDims:n})}}),Xc=L({argMax_:function Awe(e,t=0){let n={x:N(e,"x","argMax")};return P.runKernel(ip,n,{axis:t})}}),WN=L({argMin_:function Mwe(e,t=0){let n={x:N(e,"x","argMin")};return P.runKernel(sp,n,{axis:t})}}),jN=L({asin_:function Rwe(e){let t={x:N(e,"x","asin")};return P.runKernel(Eu,t)}}),HN=L({asinh_:function Fwe(e){let t={x:N(e,"x","asinh")};return P.runKernel(ku,t)}}),GN=L({atan_:function Owe(e){let t={x:N(e,"x","atan")};return P.runKernel(Nu,t)}}),qN=L({atan2_:function $we(e,t){let n=N(e,"a","atan2"),r=N(t,"b","atan2");return[n,r]=pn(n,r),P.runKernel(Du,{a:n,b:r})}}),KN=L({atanh_:function Pwe(e){let t={x:N(e,"x","atanh")};return P.runKernel(Tu,t)}});function Lwe(e,t,n,r,a="NHWC",i){return Oy(e,[...t,e[3]],n,i,r,null,null,BH(a))}function LH(e,t,n,r,a,i,s="channelsLast"){let u,[o,l]=$y(t);if("channelsLast"===s)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);u=[o,l,e[1],e[1]]}return Oy(e,u,n,r,a,i,!1,s)}function zwe(e,t,n,r,a,i,s="NDHWC"){let c,h,[o,l,u]=ZN(t);if("NDHWC"===s)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==s)throw new Error(`Unknown dataFormat ${s}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return zH(e,c,n,r,a,!1,h,i)}function Oy(e,t,n,r,a,i,s=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}let A,[d,p,,f]=t,[m,g]=$y(n),[y,v]=$y(r),b=ff(d,y),w=ff(p,v),{padInfo:x,outHeight:C,outWidth:k}=function Uwe(e,t,n,r,a,i,s,o,l){let u,c,h;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let d=function Bwe(e,t,n,r,a){null==r&&(r=XN(e,t,n));let s=e[1];return[Py((e[0]-t+2*r)/n+1,a),Py((s-t+2*r)/n+1,a)]}([t,n],i,r,e,o);c=d[0],h=d[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/a);let d=Math.max(0,(c-1)*r+i-t),p=Math.max(0,(h-1)*a+s-n),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2);u={top:f,bottom:m,left:g,right:p-g,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-i+1)/r),h=Math.ceil((n-s+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Py((t-i+d+p)/r+1,o),h=Py((n-s+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(a,u,c,m,g,b,w,i,o),T=s?f*h:f;return"channelsFirst"===o?A=[l,T,C,k]:"channelsLast"===o&&(A=[l,C,k,T]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:C,outWidth:k,outChannels:T,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:v,inShape:e,outShape:A,filterShape:t}}function zH(e,t,n,r,a,i=!1,s="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===s)[l,u,c,h,d]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[l,d,u,c,h]=e}let j,[p,f,m,,g]=t,[y,v,b]=ZN(n),[w,x,C]=ZN(r),k=ff(p,w),T=ff(f,x),A=ff(m,C),{padInfo:R,outDepth:M,outHeight:_,outWidth:$}=function Wwe(e,t,n,r,a,i,s,o,l,u,c){let h,d,p,f;if("valid"===e&&(e=0),"number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function Vwe(e,t,n,r,a,i){null==a&&(a=XN(e,t[0],r[0]));let s=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(s[o]=Py((e[o]-t[o]+2*a)/r[o]+1,i));return s}([t,n,r,1],[o,l,u],1,[a,i,s],e,c);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/a),p=Math.ceil(n/i),f=Math.ceil(r/s);let m=(d-1)*a+o-t,g=(p-1)*i+l-n,y=(f-1)*s+u-r,v=Math.floor(m/2),b=m-v,w=Math.floor(g/2),x=g-w,C=Math.floor(y/2);h={top:w,bottom:x,left:C,right:y-C,front:v,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(a,u,c,h,y,v,b,k,T,A,o),U=i?g*d:g;return"channelsFirst"===s?j=[l,U,M,_,$]:"channelsLast"===s&&(j=[l,M,_,$,U]),{batchSize:l,dataFormat:s,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:M,outHeight:_,outWidth:$,outChannels:U,padInfo:R,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:T,effectiveFilterWidth:A,dilationDepth:w,dilationHeight:x,dilationWidth:C,inShape:e,outShape:j,filterShape:t}}function XN(e,t,n,r=1){let a=ff(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function $y(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function ZN(e){return"number"==typeof e?[e,e,e]:e}function ff(e,t){return t<=1?e:e+(e-1)*(t-1)}function Py(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function nl(e){let[t,n,r]=$y(e);return 1===t&&1===n&&1===r}function bs(e,t){return nl(e)||nl(t)}function Zc(e){return $y(e).every(t=>t>0)}function BH(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Pr(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)D(Jh(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(a=>{D(Jh(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})})}}}var B=L({reshape_:function jwe(e,t){let n={x:N(e,"x","reshape","string_or_numeric")};return P.runKernel(Up,n,{shape:t})}}),ao=L({avgPool_:function Hwe(e,t,n,r,a){let i=N(e,"x","avgPool","float32");D(bs(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=i,l=!1;3===i.rank&&(l=!0,o=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Pr("avgPool",r,a);let h=P.runKernel(Au,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:a});return h=de(h,i.dtype),l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),YN=L({avgPool3d_:function Gwe(e,t,n,r,a,i="NDHWC"){let s=N(e,"x","avgPool3d","float32"),o=s,l=!1;4===s.rank&&(l=!0,o=B(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),D(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),D("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),D("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Pr("avgPool3d",r,a);let h=P.runKernel(op,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i});return h=de(h,o.dtype),l?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),zt=L({concat_:function qwe(e,t=0){D(e.length>=1,()=>"Pass at least one tensor to concat");let n=My(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===n.length?vs(n[0]):P.runKernel(dp,n,{axis:t})}}),et=L({matMul_:function Kwe(e,t,n=!1,r=!1){let a=N(e,"a","matMul"),i=N(t,"b","matMul");return[a,i]=pn(a,i),P.runKernel(Mu,{a,b:i},{transposeA:n,transposeB:r})}}),mi=L({sigmoid_:function Xwe(e){let t={x:N(e,"x","sigmoid","float32")};return P.runKernel(Mc,t)}}),ct=L({slice_:function Zwe(e,t,n){let r=N(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return P.runKernel(Xp,{x:r},{begin:t,size:n})}}),Yc=L({tanh_:function Ywe(e){let t={x:N(e,"x","tanh","float32")};return P.runKernel(Bc,t)}}),VH=L({basicLSTMCell_:function Qwe(e,t,n,r,a,i){let s=N(e,"forgetBias","basicLSTMCell"),o=N(t,"lstmKernel","basicLSTMCell"),l=N(n,"lstmBias","basicLSTMCell"),u=N(r,"data","basicLSTMCell"),c=N(a,"c","basicLSTMCell"),h=N(i,"h","basicLSTMCell"),d=zt([u,h],1),p=et(d,o),f=J(p,l),g=f.shape[1]/4,y=[f.shape[0],g],v=ct(f,[0,0],y),b=ct(f,[0,g],y),w=ct(f,[0,2*g],y),x=ct(f,[0,3*g],y),C=J(z(mi(v),Yc(b)),z(c,mi(J(s,w))));return[C,z(Yc(C),mi(x))]}}),Ly=L({batchToSpaceND_:function Jwe(e,t,n){let r=N(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);return D(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),D(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),D(r.shape[0]%a==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`),P.runKernel(lp,{x:r},{blockShape:t,crops:n})}});function exe(e){let t;return t=0===e.rank||1===e.rank?B(e,[1,1,1,e.size]):2===e.rank?B(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?B(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var Qc=L({batchNorm_:function txe(e,t,n,r,a,i){null==i&&(i=.001);let u,c,s=N(e,"x","batchNorm"),o=N(t,"mean","batchNorm"),l=N(n,"variance","batchNorm");null!=a&&(u=N(a,"scale","batchNorm")),null!=r&&(c=N(r,"offset","batchNorm")),D(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:exe(s),scale:u,offset:c,mean:o,variance:l},p=P.runKernel(Zu,h,{varianceEpsilon:i});return B(p,s.shape)}}),QN=L({batchNorm2d_:function nxe(e,t,n,r,a,i){let u,c,s=N(e,"x","batchNorm"),o=N(t,"mean","batchNorm"),l=N(n,"variance","batchNorm");return null!=a&&(u=N(a,"scale","batchNorm")),null!=r&&(c=N(r,"offset","batchNorm")),D(2===s.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${s.rank}.`),D(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),D(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&D(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&D(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Qc(s,o,l,c,u,i)}}),JN=L({batchNorm3d_:function rxe(e,t,n,r,a,i){let u,c,s=N(e,"x","batchNorm"),o=N(t,"mean","batchNorm"),l=N(n,"variance","batchNorm");return null!=a&&(u=N(a,"scale","batchNorm")),null!=r&&(c=N(r,"offset","batchNorm")),D(3===s.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${s.rank}.`),D(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),D(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&D(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&D(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Qc(s,o,l,c,u,i)}}),eT=L({batchNorm4d_:function axe(e,t,n,r,a,i){let u,c,s=N(e,"x","batchNorm"),o=N(t,"mean","batchNorm"),l=N(n,"variance","batchNorm");return null!=a&&(u=N(a,"scale","batchNorm")),null!=r&&(c=N(r,"offset","batchNorm")),D(4===s.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${s.rank}.`),D(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),D(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&D(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&D(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Qc(s,o,l,c,u,i)}}),tT=L({bincount_:function ixe(e,t,n){let r=N(e,"x","bincount"),a=N(t,"weights","bincount");return D("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(a.size===r.size||0===a.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`),P.runKernel(up,{x:r,weights:a},{size:n})}}),UH=L({bitwiseAnd_:function sxe(e,t){let n=N(e,"x","bitwiseAnd"),r=N(t,"y","bitwiseAnd");if(!Js(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);return P.runKernel(cp,{a:n,b:r})}}),WH=L({broadcastArgs_:function oxe(e,t){let n=N(e,"s0","broadcastArgs","int32"),r=N(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return P.runKernel(ry,{s0:n,s1:r})}}),Jc=L({broadcastTo_:function lxe(e,t){let n=N(e,"broadcastTo","x"),r=n.shape;if(Sa(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=B(n,l)}let a=n.shape,i=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])i[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length?vs(n):P.runKernel(qo,{x:n},{reps:i})}}),nT=L({ceil_:function uxe(e){let t={x:N(e,"x","ceil","float32")};return P.runKernel(Fu,t)}});function _a(e,t,n){return Sa(e),n=n||ey(t),P.runKernel(oy,{},{shape:e,value:t,dtype:n})}var Sr=L({clipByValue_:function cxe(e,t,n){let r=N(e,"x","clipByValue");return D(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n?_a(r.shape,t,r.dtype):P.runKernel(Go,{x:r},{clipValueMin:t,clipValueMax:n})}}),rT=L({concat1d_:function dxe(e){return zt(e,0)}}),aT=L({concat2d_:function hxe(e,t){return zt(e,t)}}),iT=L({concat3d_:function pxe(e,t){return zt(e,t)}}),sT=L({concat4d_:function fxe(e,t){return zt(e,t)}}),Lr=L({conv2d_:function mxe(e,t,n,r,a="NHWC",i=[1,1],s){let o=N(e,"x","conv2d","float32"),l=N(t,"filter","conv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),D(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Pr("conv2d",r,s);let h="NHWC"===a?u.shape[3]:u.shape[1];D(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),D(bs(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),D(Zc(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Zc(n),()=>"Error in conv2D: Strides should be larger than 0.");let f=P.runKernel(Ou,{x:u,filter:l},{strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s});return c?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),T0=L({conv1d_:function gxe(e,t,n,r,a="NWC",i=1,s){let o=N(e,"x","conv1d"),l=N(t,"filter","conv1d"),u=o,c=!1;2===o.rank&&(c=!0,u=B(o,[1,o.shape[0],o.shape[1]])),D(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),D(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Pr("conv1d",r,s),D(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(bs(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),D(Zc(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Zc(n),()=>"Error in conv1D: Stride should be larger than 0."),D("NWC"===a,()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let h=B(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=B(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Lr(d,h,[1,n],r,"NHWC",[1,i],s);return B(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),oT=L({conv2DBackpropInput_:function yxe(e,t,n,r,a,i="NHWC",s){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),D(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),D(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];D(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),D(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Pr("conv2dDerInput",a,s);let f=P.runKernel($u,{dy:l,filter:n},{strides:r,pad:a,dataFormat:i,dimRoundingMode:s,inputShape:o});return u?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),D0=L({conv2dTranspose_:function vxe(e,t,n,r,a,i){let s=N(e,"x","conv2dTranspose"),o=N(t,"filter","conv2dTranspose");return oT(n,s,o,r,a,"NHWC",i)}}),lT=L({conv3d_:function bxe(e,t,n,r,a="NDHWC",i=[1,1,1]){let s=N(e,"x","conv3d"),o=N(t,"filter","conv3d"),l=s,u=!1;4===s.rank&&(u=!0,l=B(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),D(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),D(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),D(bs(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),D("NDHWC"===a,()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),D(Zc(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Zc(n),()=>"Error in conv3D: Strides should be larger than 0.");let d=P.runKernel(Pu,{x:l,filter:o},{strides:n,pad:r,dataFormat:a,dilations:i});return u?B(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),jH=L({conv3DBackpropInput_:function wxe(e,t,n,r,a){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,s=t,o=!1;4===t.rank&&(o=!0,s=B(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);let l=i[4],u=s.shape[4];D(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),D(5===s.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`),D(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),D(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),D(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let d=P.runKernel(pp,{dy:s,filter:n},{pad:a,strides:r,inputShape:i});return o?B(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),uT=L({conv3dTranspose_:function xxe(e,t,n,r,a){let i=N(e,"x","conv3dTranspose"),s=N(t,"filter","conv3dTranspose");return jH(n,i,s,r,a)}}),zy=L({cos_:function Ixe(e){let t={x:N(e,"x","cos","float32")};return P.runKernel(Lu,t)}}),A0=L({cosh_:function Sxe(e){let t={x:N(e,"x","cosh","float32")};return P.runKernel(zu,t)}}),By=L({cumprod_:function _xe(e,t=0,n=!1,r=!1){let a={x:N(e,"x","cumprod")};return P.runKernel(fp,a,{axis:t,exclusive:n,reverse:r})}}),M0=L({cumsum_:function Cxe(e,t=0,n=!1,r=!1){let a={x:N(e,"x","cumsum")};return P.runKernel(Bu,a,{axis:t,exclusive:n,reverse:r})}}),R0=L({denseBincount_:function Exe(e,t,n,r=!1){let a=N(e,"x","denseBincount"),i=N(t,"weights","denseBincount");return D("int32"===a.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),D(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(i.size===a.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${i.shape}.`),P.runKernel(iy,{x:a,weights:i},{size:n,binaryOutput:r})}}),cT=L({depthToSpace_:function kxe(e,t,n="NHWC"){let r=N(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],s="NHWC"===n?r.shape[3]:r.shape[1];return D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),D(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),D(s%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${s} for depthToSpace with input shape ${r.shape}`),P.runKernel(gp,{x:r},{blockSize:t,dataFormat:n})}}),ed=L({depthwiseConv2d_:function Nxe(e,t,n,r,a="NHWC",i=[1,1],s){let o=N(e,"x","depthwiseConv2d","float32"),l=N(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),D(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h="NHWC"===a?u.shape[3]:u.shape[1];D(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Pr("depthwiseConv2d",r,s);let f=P.runKernel(Vu,{x:u,filter:l},{strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s});return c?B(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),HH=L({diag_:function Txe(e){let t={x:N(e,"x","diag")};return P.runKernel(sy,t)}}),dT=L({dilation2d_:function Dxe(e,t,n,r,a=[1,1],i="NHWC"){let s=N(e,"x","dilation2d"),o=N(t,"filter","dilation2d");D(3===s.rank||4===s.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`),D(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),D("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=s,u=!1;3===s.rank&&(l=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]),u=!0),D(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let d=P.runKernel(Uu,{x:l,filter:o},{strides:n,pad:r,dilations:a});return u?B(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),mf={};function GH(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a;(t[t.length-1-a]||1)>1&&1===(e[i]||1)&&r.unshift(i)}return r}function Nn(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],i=t.length-r-1;(null==a||1===a&&t[i]>1)&&n.unshift(i)}return n}function Bt(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let i=e[e.length-a-1];null==i&&(i=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===i)r[n-a-1]=s;else if(1===s)r[n-a-1]=i;else{if(i!==s)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-a-1]=i}}return r}je(mf,{assertAndGetBroadcastShape:()=>Bt,getBroadcastDims:()=>GH,getReductionAxes:()=>Nn});var Ca=L({equal_:function Axe(e,t){let n=N(e,"a","equal","string_or_numeric"),r=N(t,"b","equal","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(wp,{a:n,b:r})}}),tr=L({where_:function Mxe(e,t,n){let r=N(t,"a","where"),a=N(n,"b","where"),i=N(e,"condition","where","bool"),s=Bt(Bt(i.shape,r.shape),a.shape),o=Jc(i,s),l=Jc(r,s),u=Jc(a,s);return P.runKernel(Kp,{condition:o,t:l,e:u})}}),ft=L({zerosLike_:function Rxe(e){let t={x:N(e,"x","zerosLike")};return P.runKernel(af,t)}}),hT=L({divNoNan_:function Fxe(e,t){let n=N(e,"a","div"),r=N(t,"b","div");[n,r]=pn(n,r);let a=ve(n,r),i=ft(a),s=Ca(r,i);return tr(s,i,a)}}),pT=L({dot_:function Oxe(e,t){let n=N(e,"t1","dot"),r=N(t,"t2","dot");D(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(D(a===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${i}.`),1===n.rank&&1===r.rank){let s=B(n,[1,-1]),o=B(r,[-1,1]),l=et(s,o);return B(l,[])}if(1===n.rank&&2===r.rank){let s=B(n,[1,-1]),o=B(r,[r.shape[0],r.shape[1]]),l=et(s,o);return B(l,[l.size])}if(2===n.rank&&1===r.rank){let s=B(r,[-1,1]),o=et(n,s);return B(o,[o.size])}{let s=B(r,[r.shape[0],r.shape[1]]);return et(n,s)}}}),td=L({einsum_:function $xe(e,...t){let n=t.map((a,i)=>N(a,`tensors${i}`,"einsum"));return P.runKernel(u0,n,{equation:e})}}),gf=L({elu_:function Pxe(e){let t={x:N(e,"x","elu","float32")};return P.runKernel(ju,t)}}),qH=L({ensureShape_:function Lxe(e,t){let n=N(e,"x","ensureShape","string_or_numeric");if(!Wj(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}}),fT=L({erf_:function zxe(e){let t=N(e,"x","erf");return D("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=de(t,"float32")),P.runKernel(Hu,{x:t})}});function mT(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function KH(e,t,n){let r=e.length+t.length,a=[],i=0,s=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[i++]):a.push(t[s++]);return a}function XH(e,t){let n=[],r=e.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&n.push(e[i]);return[n,t.map(i=>e[i])]}function nd(e,t){return KH(e,t.map(r=>1),t)}function Bxe(e,t,n){D(mT(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function ZH(e,t){if(mT(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(r=>n.push(r)),n}function gT(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Vxe(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var Ka=L({max_:function Uxe(e,t=null,n=!1){let r={x:N(e,"x","max")};return P.runKernel(sc,r,{reductionIndices:t,keepDims:n})}}),yf=L({min_:function Wxe(e,t=null,n=!1){let r={x:N(e,"x","min")};return P.runKernel(cc,r,{axis:t,keepDims:n})}}),io=L({pow_:function jxe(e,t){let n=N(e,"base","pow"),r=N(t,"exp","pow");return[n,r]=pn(n,r),P.runKernel(yc,{a:n,b:r})}});function ke(e,t){if((er(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&er(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Qo(e,[],[],t)}var dr=L({sqrt_:function Hxe(e){let t={x:N(e,"x","sqrt","float32")};return P.runKernel(Fc,t)}}),Vt=L({square_:function Gxe(e){let t=N(e,"x","square");return P.runKernel("Square",{x:t},{})}}),xe=L({sum_:function qxe(e,t=null,n=!1){let r=N(e,"x","sum");return"bool"===r.dtype&&(r=de(r,"int32")),P.runKernel(Oc,{x:r},{axis:t,keepDims:n})}});function YH(e,t,n=null){if(0===e.rank)return kn(e);if(1!==e.rank&&null===n)return YH(B(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return xe(kn(e),n);if(t===1/0)return Ka(kn(e),n);if(t===-1/0)return yf(kn(e),n);if("euclidean"===t||2===t)return dr(xe(io(kn(e),ke(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Ka(xe(kn(e),n[0]),n[1]-1);if(t===1/0)return Ka(xe(kn(e),n[1]),n[0]);if(t===-1/0)return yf(xe(kn(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return dr(xe(Vt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var vf=L({norm_:function Kxe(e,t="euclidean",n=null,r=!1){let a=YH(e=N(e,"x","norm"),t,n),i=a.shape;if(r){let s=pi(n,e.shape);i=nd(a.shape,s)}return B(a,i)}}),yT=L({euclideanNorm_:function Xxe(e,t=null,n=!1){return vf(e,"euclidean",t,n)}}),_r=L({exp_:function Zxe(e){let t={x:N(e,"x","exp")};return P.runKernel(Gu,t)}}),nr=L({expandDims_:function Yxe(e,t=0){let n=N(e,"x","expandDims","string_or_numeric");return D(t<=n.rank,()=>"Axis must be <= rank of the tensor"),P.runKernel(xp,{input:n},{dim:t})}}),vT=L({expm1_:function Qxe(e){let t={x:N(e,"x","expm1")};return P.runKernel(qu,t)}}),Ea=L({tile_:function Jxe(e,t){let n=N(e,"x","tile","string_or_numeric");return D(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),P.runKernel(qo,{x:n},{reps:t})}}),F0=L({eye_:function e0e(e,t,n,r="float32"){null==t&&(t=e);let a=Je([e,t],r),i=e<=t?e:t;for(let o=0;o<i;++o)a.set(1,o,o);let s=B(a.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return Ea(nr(s,0),[n[0],1,1]);if(2===n.length)return Ea(nr(nr(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ea(nr(nr(nr(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),bf=L({floor_:function t0e(e){let t={x:N(e,"x","floor","float32")};return P.runKernel(Ku,t)}}),wf=L({gather_:function n0e(e,t,n=0,r=0){let a=N(e,"x","gather"),i=N(t,"indices","gather","int32");return P.runKernel(Sp,{x:a,indices:i},{axis:n,batchDims:r})}}),zr=L({greater_:function r0e(e,t){let n=N(e,"a","greater","string_or_numeric"),r=N(t,"b","greater","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(Cp,{a:n,b:r})}}),so=L({greaterEqual_:function a0e(e,t){let n=N(e,"a","greaterEqual","string_or_numeric"),r=N(t,"b","greaterEqual","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(Yu,{a:n,b:r})}}),Vy=L({imag_:function i0e(e){let t={input:N(e,"input","imag")};return P.runKernel(h0,t)}}),bT=L({isFinite_:function s0e(e){let t={x:N(e,"x","isFinite")};return P.runKernel(Ju,t)}}),wT=L({isInf_:function o0e(e){let t={x:N(e,"x","isInf")};return P.runKernel(ec,t)}}),xT=L({isNaN_:function l0e(e){let t={x:N(e,"x","isNaN")};return P.runKernel(tc,t)}}),Uy=L({leakyRelu_:function u0e(e,t=.2){let n={x:N(e,"x","leakyRelu")};return P.runKernel(nc,n,{alpha:t})}}),xf=L({less_:function c0e(e,t){let n=N(e,"a","less","string_or_numeric"),r=N(t,"b","less","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(Ep,{a:n,b:r})}}),rl=L({lessEqual_:function d0e(e,t){let n=N(e,"a","lessEqual","string_or_numeric"),r=N(t,"b","lessEqual","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(kp,{a:n,b:r})}});function QH(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");return P.runKernel(Np,{},{start:e,stop:t,num:n})}var IT=L({localResponseNormalization_:function h0e(e,t=5,n=1,r=1,a=.5){let i=N(e,"x","localResponseNormalization");D(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),D(Jh(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let s=i,o=!1;3===i.rank&&(o=!0,s=B(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let c=P.runKernel(ic,{x:s},{depthRadius:t,bias:n,alpha:r,beta:a});return o?B(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ka=L({log_:function p0e(e){let t={x:N(e,"x","log","float32")};return P.runKernel(rc,t)}}),Wy=L({log1p_:function f0e(e){let t={x:N(e,"x","log1p")};return P.runKernel(ac,t)}});function m0e(e){return D(jo(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=N(t,"x","tf.grad","string_or_numeric"),a=null!=n?N(n,"dy","tf.grad"):null;return P.tidy(()=>{let{value:i,grads:s}=P.gradients(()=>e(r),[r],a);return null!=a&&Fr(i.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),O0(s),s[0]})}}function g0e(e){return D(jo(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{D(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=My(t,"args","tf.grads","string_or_numeric"),a=null!=n?N(n,"dy","tf.grads"):null;return P.tidy(()=>{let{value:i,grads:s}=P.gradients(()=>e(...r),r,a);return null!=a&&Fr(i.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),O0(s),s})}}function y0e(e){return D(jo(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{D(t instanceof Ze,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(null==n||n instanceof Ze,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=P.gradients(()=>e(t),[t],n);return O0(r),{grad:r[0],value:a}}}function v0e(e){return D(jo(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{D(Array.isArray(t)&&t.every(a=>a instanceof Ze),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(null==n||n instanceof Ze,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=P.gradients(()=>e(...t),t,n);return null!=n&&Fr(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),O0(r.grads),r}}function JH(e,t){D(jo(e),()=>"The f passed in variableGrads(f) must be a function"),D(null==t||Array.isArray(t)&&t.every(u=>u instanceof Gc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=null!=t;if(!n){t=[];for(let u in P.registeredVariables)t.push(P.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,a=t.length;D((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let{value:s,grads:o}=P.gradients(e,t,null,!0);D(o.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let l={};return t.forEach((u,c)=>{null!=o[c]&&(l[u.name]=o[c])}),r?.forEach(u=>l[u.name]=null),{value:s,grads:l}}function ws(e){return P.customGrad(e)}function O0(e){if(e.filter(t=>null==t).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var Yt=L({neg_:function b0e(e){let t={x:N(e,"x","neg")};return P.runKernel(Op,t)}}),rd=L({softplus_:function w0e(e){let t={x:N(e,"x","softplus")};return P.runKernel(Rc,t)}}),ST=L({logSigmoid_:function x0e(e){let t=N(e,"x","logSigmoid");return ws(n=>({value:Yt(rd(Yt(n))),gradFunc:r=>z(r,mi(Yt(n)))}))(t)}}),ye=L({sub_:function I0e(e,t){let n=N(e,"a","sub"),r=N(t,"b","sub");return[n,r]=pn(n,r),P.runKernel(Lc,{a:n,b:r})}}),$0=L({logSoftmax_:function S0e(e,t=-1){let n=N(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ws((r,a)=>{let i=Ka(r,t,!0),s=ye(r,i),o=ye(de(s,"float32"),ka(xe(_r(s),t,!0)));return a([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,d=_r(c);return ye(l,z(xe(l,t,!0),d))}}})(n)}}),jy=L({logSumExp_:function _0e(e,t=null,n=!1){let r=N(e,"x","logSumExp"),a=pi(t,r.shape),i=Ka(r,a,!0),s=ye(r,i),o=_r(s),l=xe(o,a),u=ka(l),c=J(B(i,u.shape),u);if(n){let h=nd(c.shape,a);return B(c,h)}return c}}),gi=L({logicalAnd_:function C0e(e,t){let n=N(e,"a","logicalAnd","bool"),r=N(t,"b","logicalAnd","bool");return Bt(n.shape,r.shape),P.runKernel(Tp,{a:n,b:r})}}),Hy=L({logicalNot_:function E0e(e){let t={x:N(e,"x","logicalNot","bool")};return P.runKernel(Dp,t)}}),P0=L({logicalOr_:function k0e(e,t){let n=N(e,"a","logicalOr","bool"),r=N(t,"b","logicalOr","bool");return Bt(n.shape,r.shape),P.runKernel(Ap,{a:n,b:r})}}),_T=L({logicalXor_:function N0e(e,t){let n=N(e,"a","logicalXor","bool"),r=N(t,"b","logicalXor","bool");return Bt(n.shape,r.shape),gi(P0(e,t),Hy(gi(e,t)))}}),L0=2147483648,z0=L({searchSorted_:function T0e(e,t,n="left"){let r=N(e,"sortedSequence","searchSorted"),a=N(t,"values","searchSorted"),s=a.shape[a.shape.length-1],o=B(r,[-1,r.shape[r.shape.length-1]]),l=B(a,[-1,s]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Mt(l.shape)>=L0)throw new Error(`values tensor size must less than ${L0}`);if(o.shape[1]>=L0)throw new Error(`trailing dim_size must less than ${L0} for int32 output type, was ${o.shape[1]}`);return P.runKernel(qp,{sortedSequence:o,values:l},{side:n})}});function eG(e,t){return z0(e,t,"left")}var rr=L({maxPool_:function D0e(e,t,n,r,a){let i=N(e,"x","maxPool"),o=i,l=!1;3===i.rank&&(l=!0,o=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),D(bs(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),Pr("maxPool",r,a);let h=P.runKernel(lc,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:a});return l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),CT=L({maxPool3d_:function A0e(e,t=[1,1,1],n,r,a,i="NDHWC"){let s=N(e,"x","maxPool3d"),o=s,l=!1;4===s.rank&&(l=!0,o=B(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),D(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),D("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Pr("maxPool3d",r,a);let h=P.runKernel(Rp,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i});return l?B(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),tG=L({maxPoolWithArgmax_:function M0e(e,t,n,r,a=!1){let i={x:N(e,"x","maxPoolWithArgmax")},o=P.runKernel(cy,i,{filterSize:t,strides:n,pad:r,includeBatchInIndex:a});return{result:o[0],indexes:o[1]}}}),xs=L({maximum_:function R0e(e,t){let n=N(e,"a","maximum"),r=N(t,"b","maximum");return[n,r]=pn(n,r),"bool"===n.dtype&&(n=de(n,"int32"),r=de(r,"int32")),Bt(n.shape,r.shape),P.runKernel(oc,{a:n,b:r})}}),fn=L({mean_:function F0e(e,t=null,n=!1){let r={x:N(e,"x","mean")};return P.runKernel(uc,r,{axis:t,keepDims:n})}});function mn(e,t="float32"){if(Sa(e),"complex64"===t){let r=mn(e,"float32"),a=mn(e,"float32");return to(r,a)}let n=t0(Mt(e),t);return P.makeTensor(n,e,t)}function aa(e,t="float32"){if(Sa(e),"complex64"===t){let r=aa(e,"float32"),a=mn(e,"float32");return to(r,a)}let n=rN(Mt(e),t);return P.makeTensor(n,e,t)}function nG(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=N(e,"x","meshgrid",e instanceof Ze?e.dtype:"float32");if(void 0===t)return[r];let a=N(t,"y","meshgrid",t instanceof Ze?t.dtype:"float32"),i=Mt(r.shape),s=Mt(a.shape);return"xy"===n?(r=B(r,[1,-1]),a=B(a,[-1,1]),[et(aa([s,1],r.dtype),r),et(a,aa([1,i],a.dtype))]):(r=B(r,[-1,1]),a=B(a,[1,-1]),[et(r,aa([1,s],r.dtype)),et(aa([i,1],a.dtype),a)])}var al=L({minimum_:function O0e(e,t){let n=N(e,"a","minimum"),r=N(t,"b","minimum");return[n,r]=pn(n,r),"bool"===n.dtype&&(n=de(n,"int32"),r=de(r,"int32")),Bt(n.shape,r.shape),P.runKernel(dc,{a:n,b:r})}}),ET=L({mirrorPad_:function $0e(e,t,n){D("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=N(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)D(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),D(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);return P.runKernel(hc,{x:r},{paddings:t,mode:n})}}),kT=L({mod_:function P0e(e,t){let n=N(e,"a","mod"),r=N(t,"b","mod");return[n,r]=pn(n,r),P.runKernel(pc,{a:n,b:r})}}),Gy=L({moments_:function L0e(e,t=null,n=!1){let r=pi(t,(e=N(e,"x","moments")).shape),a=fn(e,r,n),i=a.shape;n||(i=nd(a.shape,r));let s=Vt(ye(de(e,"float32"),B(a,i)));return{mean:a,variance:fn(s,r,n)}}}),rG=L({multiRNNCell_:function z0e(e,t,n,r){let a=N(t,"data","multiRNNCell"),i=My(n,"c","multiRNNCell"),s=My(r,"h","multiRNNCell"),o=a,l=[];for(let h=0;h<e.length;h++){let d=e[h](o,i[h],s[h]);l.push(d[0]),l.push(d[1]),o=d[1]}let u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}}),aG=L({multinomial_:function B0e(e,t,n,r=!1){let a=N(e,"logits","multinomial"),i=a.size,s=a.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(s>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${s}`);n=n||Math.random();let o={logits:1===s?B(a,[1,-1]):a},u=P.runKernel(Fp,o,{numSamples:t,seed:n,normalized:r});return 1===s?B(u,[u.size]):u}}),ad=L({notEqual_:function V0e(e,t){let n=N(e,"a","notEqual","string_or_numeric"),r=N(t,"b","notEqual","string_or_numeric");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel($p,{a:n,b:r})}}),If=L({oneHot_:function U0e(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:N(e,"indices","oneHot","int32")};return P.runKernel(mc,i,{dtype:a,depth:t,onValue:n,offValue:r})}}),Na=L({onesLike_:function W0e(e){let t={x:N(e,"x","onesLike")};return P.runKernel(Bp,t)}}),iG=L({outerProduct_:function j0e(e,t){let n=N(e,"v1","outerProduct"),r=N(t,"v2","outerProduct");D(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=B(n,[-1,1]),i=B(r,[1,-1]);return et(a,i)}}),Wi=L({pad_:function H0e(e,t,n=0){let r=N(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return P.runKernel(gc,{x:r},{paddings:t,constantValue:n})}}),sG=L({pad1d_:function G0e(e,t,n=0){return D(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Wi(e,[t],n)}}),oG=L({pad2d_:function q0e(e,t,n=0){return D(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Wi(e,t,n)}}),lG=L({pad3d_:function K0e(e,t,n=0){return D(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Wi(e,t,n)}}),uG=L({pad4d_:function X0e(e,t,n=0){return D(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Wi(e,t,n)}}),qy=L({spaceToBatchND_:function Z0e(e,t,n){let r=N(e,"x","spaceToBatchND");return D(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),D(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),D(r.shape.reduce((s,o,l)=>l>0&&l<=t.length?s&&(o+n[l-1][0]+n[l-1][1])%t[l-1]==0:s,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),P.runKernel(Zp,{x:r},{blockShape:t,paddings:n})}}),NT=L({pool_:function Y0e(e,t,n,r,a,i,s){null==a&&(a=[1,1]),null==i&&(i=1),0===r&&(r="valid");let o=N(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(bs(i,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${a}'`);let d,c=LH(l.shape,t,i,a,r),h=[c.dilationHeight,c.dilationWidth];d="same"===r?function J0e(e,t){let n=e.map((i,s)=>i+(i-1)*(t[s]-1)).map(i=>i-1),r=n.map(i=>Math.floor(i/2)),a=n.map((i,s)=>i-r[s]);return n.map((i,s)=>[r[s],a[s]])}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];let p=1===h[0]&&1===h[1],[f,m]=function Q0e(e,t,n){let r=n.map(c=>c[0]),a=n.map(c=>c[1]),i=e.concat(r,a),s=t.map((c,h)=>(c-i[h]%c)%c),o=a.map((c,h)=>c+s[h]),l=t.map((c,h)=>[r[h],o[h]]),u=t.map((c,h)=>[0,s[h]]);return[l,u]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",y=p?l:qy(l,h,f),v=("avg"===n?()=>ao(y,t,i,g,s):()=>rr(y,t,i,g,s))(),b=p?v:Ly(v,h,m);return u?B(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),Ky=L({prelu_:function eIe(e,t){let n=N(e,"x","prelu"),r=N(t,"alpha","prelu");return P.runKernel(vc,{x:n,alpha:r})}}),TT=L({prod_:function tIe(e,t=null,n=!1){let r=N(e,"x","prod");return"bool"===r.dtype&&(r=de(r,"int32")),P.runKernel(bc,{x:r},{axis:t,keepDims:n})}}),cG=L({raggedGather_:function nIe(e,t,n,r){let a=e.map((c,h)=>N(c,`tensors${h}`,"raggedGather","int32")),i=N(t,"paramsDenseValues","raggedGather"),s=N(n,"indices","raggedGather","int32"),u=P.runKernel(p0,{paramsNestedSplits:a,paramsDenseValues:i,indices:s},{outputRaggedRank:r});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),dG=L({raggedRange_:function rIe(e,t,n){let r=N(e,"starts","raggedRange"),a=N(t,"limits","raggedRange",r.dtype),i=N(n,"deltas","raggedRange",r.dtype),o=P.runKernel(f0,{starts:r,limits:a,deltas:i});return{rtNestedSplits:o[0],rtDenseValues:o[1]}}}),hG=L({raggedTensorToTensor_:function aIe(e,t,n,r,a){let i=N(e,"shape","raggedTensorToTensor","int32"),s=N(t,"values","raggedTensorToTensor"),o=N(n,"defaultValue","raggedTensorToTensor",s.dtype),l=r.map((h,d)=>N(h,`tensors${d}`,"raggedTensorToTensor","int32"));return P.runKernel(m0,{shape:i,values:s,defaultValue:o,rowPartitionTensors:l},{rowPartitionTypes:a})}}),pG=L({rand_:function iIe(e,t,n){Sa(e);let r=Mt(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let i=0;i<r;i++)a[i]=t();return P.makeTensor(a,e,n)}}),DT=Uo(Zx()),fG={};je(fG,{TEST_EPSILON_FLOAT16:()=>mG,createVideoElement:()=>pIe,encodeStrings:()=>gG,expectArrayBuffersEqual:()=>hIe,expectArraysClose:()=>oIe,expectArraysEqual:()=>uIe,expectNumbersClose:()=>cIe,expectPromiseToFail:()=>lIe,expectValuesInRange:()=>dIe,play:()=>fIe,testEpsilon:()=>AT});var sIe=.001,mG=.1;function oIe(e,t,n){return null==n&&(n=AT()),MT(e,t,(r,a)=>RT(r,a,n))}function AT(){return 32===P.backend.floatPrecision()?sIe:mG}function MT(e,t,n){let r=!0;if((er(e)||er(t))&&(r=!1),er(e)&&er(t)&&(r=!0),r){let s=e.constructor.name,o=t.constructor.name;if(s!==o)throw new Error(`Arrays are of different type. Actual: ${s}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let s=ys(e),o=ys(t);if(!Js(s,o))throw new Error(`Arrays have different shapes. Actual: [${s}]. Expected: [${o}]`)}let a=er(e)?e:Yo(e),i=er(t)?t:Yo(t);if(a.length!==i.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${i.length}.\nActual:   ${a}.\nExpected: ${i}.`);for(let s=0;s<i.length;++s){let o=a[s],l=i[s];if(!n(o,l))throw new Error(`Arrays differ: actual[${s}] = ${o}, expected[${s}] = ${l}.\nActual:   ${a}.\nExpected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function lIe(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function uIe(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Wo(e)||Wo(e[0])||Wo(t)||Wo(t[0])?MT(e,n,(r,a)=>r==a):MT(e,t,(r,a)=>RT(r,a,0))}function cIe(e,t,n){if(null==n&&(n=AT()),!RT(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function RT(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function dIe(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function hIe(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function gG(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?gG(n):e[t]=ky(n)}return e}function pIe(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}function fIe(e){return FT.apply(this,arguments)}function FT(){return FT=F(function*(e){yield e.play(),"requestVideoFrameCallback"in e&&(yield new Promise(t=>{e.requestVideoFrameCallback(t)}))}),FT.apply(this,arguments)}var OT=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let i=a||Math.random();this.random=DT.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,i;do{r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a}while(i>=1||0===i);let s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*s,t=this.mean+this.stdDev*a*s,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},mIe=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=DT.alea(a.toString()),this.randn=new OT(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,i;for(;;){do{r=this.randn.nextValue(),i=1+this.c*r}while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<t||Math.log(a)<n)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},gIe=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=DT.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}},yG=L({randomGamma_:function yIe(e,t,n=1,r="float32",a){if(Sa(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let i=new mIe(t,n,r,a),s=Je(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}}),B0=L({randomNormal_:function vIe(e,t=0,n=1,r,a){if(Sa(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let i=new OT(t,n,r,!1,a),s=Je(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}}),vG=L({randomStandardNormal_:function bIe(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return B0(e,0,1,t,n)}}),il=L({randomUniform_:function wIe(e,t=0,n=1,r="float32",a){Sa(e);let i=Je(e,r),s=new gIe(t,n,null,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}}),bG=L({randomUniformInt_:function xIe(e,t,n,r){return il(e,t,n,"int32",r)}});function id(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return P.runKernel(dy,{},{start:e,stop:t,step:n,dtype:r})}var Sf=L({real_:function IIe(e){let t={input:N(e,"input","real")};return P.runKernel(g0,t)}}),$T=L({reciprocal_:function SIe(e){let t={x:N(e,"x","reciprocal")};return P.runKernel(wc,t)}}),Rt=L({relu_:function _Ie(e){let t={x:N(e,"x","relu")};return P.runKernel(xc,t)}}),V0=L({relu6_:function CIe(e){let t={x:N(e,"x","relu6")};return P.runKernel(_c,t)}}),Xa=L({reverse_:function EIe(e,t){let n={x:N(e,"x","reverse")};return P.runKernel(Cc,n,{dims:t})}}),wG=L({reverse1d_:function kIe(e){let t=N(e,"x","reverse");return D(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Xa(t,0)}}),xG=L({reverse2d_:function NIe(e,t){let n=N(e,"x","reverse");return D(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Xa(n,t)}}),IG=L({reverse3d_:function TIe(e,t){let n=N(e,"x","reverse");return D(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Xa(n,t)}}),SG=L({reverse4d_:function DIe(e,t){let n=N(e,"x","reverse");return D(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Xa(n,t)}}),U0=L({round_:function AIe(e){let t={x:N(e,"x","round")};return P.runKernel(Ec,t)}}),W0=L({rsqrt_:function MIe(e){let t={x:N(e,"x","rsqrt","float32")};return P.runKernel(kc,t)}}),j0=L({selu_:function RIe(e){let t={x:N(e,"x","selu")};return P.runKernel(Nc,t)}}),_f=L({separableConv2d_:function FIe(e,t,n,r,a,i=[1,1],s="NHWC"){let o=N(e,"x","separableConv2d"),l=N(t,"depthwiseFilter","separableConv2d"),u=N(n,"pointwiseFilter","separableConv2d"),c=o,h=!1;if(3===o.rank&&(h=!0,c=B(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===s)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),D(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),D(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],p=l.shape[3];D(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);let f=ed(c,l,r,a,s,i),m=Lr(f,u,1,"valid",s);return h?B(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});function PT(){return PT=F(function*(e,t){let n=N(e,"x","setdiff1d"),r=N(t,"y","setdiff1d");D(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),D(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),D(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=yield n.data(),i=yield r.data(),s=new Set(i),o=0;for(let c=0;c<a.length;c++)s.has(a[c])||o++;let l=new En([o],n.dtype),u=new En([o],"int32");for(let c=0,h=0;c<a.length;c++)s.has(a[c])||(l.values[h]=a[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}),PT.apply(this,arguments)}var _G=function OIe(e,t){return PT.apply(this,arguments)},LT=L({sign_:function $Ie(e){let t={x:N(e,"x","sign")};return P.runKernel(Ac,t)}}),H0=L({sin_:function PIe(e){let t={x:N(e,"x","sin","float32")};return P.runKernel(Tc,t)}}),G0=L({sinh_:function LIe(e){let t={x:N(e,"x","sinh")};return P.runKernel(Dc,t)}}),Xy=L({slice1d_:function zIe(e,t,n){let r=N(e,"x","slice1d");return D(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ct(r,[t],[n])}}),q0=L({slice2d_:function BIe(e,t,n){let r=N(e,"x","slice2d");return D(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ct(r,t,n)}}),Cf=L({slice3d_:function VIe(e,t,n){let r=N(e,"x","slice3d");return D(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ct(r,t,n)}}),Ef=L({slice4d_:function UIe(e,t,n){let r=N(e,"x","slice4d");return D(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ct(r,t,n)}}),sl=L({softmax_:function WIe(e,t=-1){let n=N(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return P.runKernel($c,{logits:n},{dim:t})}}),Zy=L({fft_:function jIe(e){return D("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),P.runKernel(c0,{input:e})}}),kf=L({ifft_:function HIe(e){return D("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),P.runKernel(d0,{input:e})}}),K0=L({irfft_:function GIe(e){let r,t=e.shape[e.shape.length-1],n=e.size/t;if(t<=2){let a=B(e,[n,t]);r=kf(a)}else{let a=[n,2*(t-1)],i=B(Sf(e),[n,t]),s=B(Vy(e),[n,t]),o=Xa(ct(i,[0,1],[n,t-2]),1),l=z(Xa(ct(s,[0,1],[n,t-2]),1),ke(-1)),u=zt([i,o],1),c=zt([s,l],1),h=B(to(u,c),[a[0],a[1]]);r=kf(h)}if(r=Sf(r),3===e.rank&&0!==e.shape[0]){let a=r,i=e.shape[0];r=B(r,[i,r.shape[0]/i,r.shape[1]]),a.dispose()}return r}}),ia=L({split_:function qIe(e,t,n=0){let r={x:N(e,"x","split")};return P.runKernel(Yp,r,{numOrSizeSplits:t,axis:n})}}),Yy=L({rfft_:function KIe(e,t){D("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let a,n=e.shape[e.shape.length-1],r=e.size/n;if(null!=t&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,a=ct(e,f,m),n=t}else if(null!=t&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,a=zt([e,mn(f)],e.shape.length-1),n=t}else a=e;let i=ft(a),s=B(to(a,i),[r,n]),o=Zy(s),l=Math.floor(n/2)+1,u=Sf(o),c=Vy(o),h=ia(u,[l,n-l],u.shape.length-1),d=ia(c,[l,n-l],c.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,B(to(h[0],d[0]),p)}}),X0=L({squaredDifference_:function XIe(e,t){let n=N(e,"a","squaredDifference"),r=N(t,"b","squaredDifference");return[n,r]=pn(n,r),Bt(n.shape,r.shape),P.runKernel(Pc,{a:n,b:r},{})}}),ol=L({squeeze_:function ZIe(e,t){let n=N(e,"x","squeeze","string_or_numeric");return B(n,jj(n.shape,t).newShape)}}),Tn=L({stack_:function YIe(e,t=0){let n=My(e,"tensors","stack","string_or_numeric");return D(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&D(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),P.runKernel(Vp,n,{axis:t})}}),sd=L({step_:function QIe(e,t=0){let n={x:N(e,"x","step")};return P.runKernel(Ko,n,{alpha:t})}}),zT=L({stridedSlice_:function JIe(e,t,n,r,a=0,i=0,s=0,o=0,l=0){let u={x:N(e,"x","stridedSlice","string_or_numeric")};return P.runKernel(ef,u,{begin:t,end:n,strides:r,beginMask:a,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:l})}}),BT=L({tan_:function e1e(e){let t={x:N(e,"x","tan","float32")};return P.runKernel(zc,t)}});function Tt(e,t){Iu(e);let n=ys(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Qo(e,null,n,t)}function Is(e,t,n){if(Iu(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=ys(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Qo(e,t,r,n)}function Z0(e,t,n){if(Iu(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=ys(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Qo(e,t,r,n)}function ll(e,t,n){if(Iu(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=ys(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Qo(e,t,r,n)}function CG(e,t,n){if(Iu(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=ys(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Qo(e,t,r,n)}function EG(e,t,n){if(Iu(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=ys(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Qo(e,t=t||r,r,n)}var Y0={};function VT(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(i+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(i+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(i+" update.rank != "+(a+e.length-r));for(let s=0;s<a;++s)if(n.shape[s]!==t.shape[s])throw new Error(i+` updates.shape[${s}] (${n.shape[s]}) != indices.shape[${s}] (${t.shape[s]}).`);for(let s=0;s<n.rank-a;++s)if(n.shape[s+a]!==e[s+r])throw new Error(i+` updates.shape[${s+a}] (${n.shape[s+a]}) != shape[${s+a}] (${e[s+a]})`)}function Q0(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}VT(n,t,e)}function kG(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,i=n.length,s=1;for(let h=a;h<i;++h)s*=n[h];let o=a<1?1:a;return{sliceRank:a,numUpdates:Mt(t.shape)/o,sliceSize:s,strides:[...ep(n.slice(0,a)),1],outputSize:Mt(n)}}je(Y0,{calculateShapes:()=>kG,validateInput:()=>Q0,validateUpdateShape:()=>VT});var NG=L({tensorScatterUpdate_:function t1e(e,t,n){let r=N(e,"tensor","tensorScatterupdate"),a=N(t,"indices","tensorScatterupdate","int32"),i=N(n,"updates","tensorScatterupdate");if(Q0(i,a,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);return P.runKernel(Gp,{tensor:r,indices:a,updates:i},{})}}),UT=L({topk_:function n1e(e,t=1,n=!0){let r=N(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let i={x:r},s={k:t,sorted:n},[o,l]=P.runKernel(tf,i,s);return{values:o,indices:l}}}),J0=L({truncatedNormal_:function r1e(e,t=0,n=1,r,a){if(Sa(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let i=new OT(t,n,r,!0,a),s=Je(e,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}}),WT=L({unique_:function a1e(e,t=0){let n=N(e,"x","unique","string_or_numeric");D(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[i,s]=P.runKernel(wy,r,a);return{values:i,indices:s}}}),eI=L({unsortedSegmentSum_:function i1e(e,t,n){let r=N(e,"x","unsortedSegmentSum"),a=N(t,"segmentIds","unsortedSegmentSum","int32");return D(Jh(n),()=>"numSegments must be of dtype int"),P.runKernel(xy,{x:r,segmentIds:a},{numSegments:n})}}),vn=L({unstack_:function s1e(e,t=0){let n=N(e,"x","unstack","string_or_numeric");return D(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),P.runKernel(rf,{value:n},{axis:t})}});function TG(e,t){return z0(e,t,"right")}function jT(e,t=!0,n,r){return P.makeVariable(e,t,n,r)}function DG(e,t){let n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);let r=Je(e,"int32"),a=Je([n.length,e.length],"int32");for(let i=0;i<n.length;i++){let s=r.indexToLoc(n[i]);a.values.set(s,i*e.length)}return a.toTensor()}function HT(){return HT=F(function*(e){let t=N(e,"condition","whereAsync","bool"),n=yield t.data(),r=DG(t.shape,n);return e!==t&&t.dispose(),r}),HT.apply(this,arguments)}var GT=function o1e(e){return HT.apply(this,arguments)};function qT(){return qT=F(function*(e,t,n){let r=N(e,"tensor","boolMask"),a=N(t,"mask","boolMask","bool"),i=n??0,s=a.rank,o=r.shape;D(s>0,()=>"mask cannot be scalar"),Fr(o.slice(i,i+s),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+s;m++)l*=o[m];let u=o.slice(0,i).concat([l],o.slice(i+s)),c=B(r,u),h=B(a,[-1]),d=yield GT(h),p=ol(d,[1]),f=wf(c,p,i);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}),qT.apply(this,arguments)}var AG=function l1e(e,t,n){return qT.apply(this,arguments)},tt=L({transpose_:function u1e(e,t,n){let r=N(e,"x","transpose");if(null==t&&(t=r.shape.map((s,o)=>o).reverse()),D(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(s=>{D(s>=0&&s<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},i={perm:t};return"complex64"===r.dtype?V(()=>{let s=Sf(r),o=Vy(r);return s=P.runKernel(eo,{x:s},i),o=P.runKernel(eo,{x:o},i),n&&(o=Yt(o)),to(s,o)}):P.runKernel(eo,a,i)}}),MG=L({movingAverage_:function c1e(e,t,n,r,a=!0){let i=N(e,"v","movingAverage"),s=N(t,"x","movingAverage"),o=N(n,"decay","movingAverage");fH(i,s),D(Js(i.shape,s.shape),()=>"Shape mismatch in v and x");let l=ke(1),u=ye(l,o),c=z(ye(s,i),u);if(a){D(null!=r,()=>"When using zeroDebias: true, step is required.");let h=N(r,"step","movingAverage");c=ve(c,ye(l,io(o,h)))}return J(i,c)}}),RG=L({scatterND_:function d1e(e,t,n){Sa(n);let r=N(e,"indices","scatterND","int32"),a=N(t,"updates","scatterND");return Q0(a,r,n),P.runKernel(Hp,{indices:r,updates:a},{shape:n})}}),FG=L({sparseToDense_:function p1e(e,t,n,r=0){Sa(n);let a=N(e,"sparseIndices","sparseToDense","int32"),i=N(t,"sparseValues","sparseToDense","string_or_numeric"),s=N(r,"defaultValue","sparseToDense",i.dtype);return function h1e(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,i,n,s),P.runKernel(Jp,{sparseIndices:a,sparseValues:i,defaultValue:s},{outputShape:n})}}),OG=L({gatherND_:function f1e(e,t){let n=N(t,"indices","gatherND","int32"),r={params:N(e,"x","gatherND","string_or_numeric"),indices:n};return P.runKernel(_p,r)}}),KT=L({dropout_:function g1e(e,t,n,r){let a=N(e,"x","dropout");if(D("float32"===a.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof Ze?a.clone():a;let i=function m1e(e,t){if(null==t)return e.shape.slice();if(Js(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)n.push(null==t[r]&&null!=e.shape[r]?e.shape[r]:t[r]);return n}return t}(a,n),s=1-t,o=ve(bf(J(il(i,0,1,"float32",r),s)),s);return z(a,o)}});function XT(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function tI(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let i=0;i<e;++i){let s=2*Math.PI*i/(e+r-1);a[i]=t-n*Math.cos(s)}return Tt(a,"float32")}function ZT(){return ZT=F(function*(e,t,n=1){let r=N(e,"predictions","inTopK"),a=N(t,"targets","inTopK");D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),Fr(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let i=r.shape[r.shape.length-1];D(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);let s=yield r.data(),o=yield a.data(),[l,u]=[s.length/i,i],c=Hj("bool",l);for(let h=0;h<l;h++){let d=h*u,p=s.subarray(d,d+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[h]=0;for(let m=0;m<n;m++)if(f[m].index===o[h]){c[h]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),$r(c,a.shape,"bool")}),ZT.apply(this,arguments)}var $G=function y1e(e,t){return ZT.apply(this,arguments)},Nf={};je(Nf,{conv2d:()=>w1e,depthwiseConv2d:()=>_1e,matMul:()=>E1e});var YT=L({conv2DBackpropFilter_:function v1e(e,t,n,r,a,i="NHWC",s){let o=e;3===e.rank&&(o=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),D(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return D(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),D(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Pr("conv2dDerFilter",a,s),P.runKernel(a0,{x:o,dy:l},{strides:r,pad:a,dataFormat:i,dimRoundingMode:s,filterShape:n})}});function nI(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return z(e,sd(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rI(e,t){let n=t,r=Nn(e.shape,t.shape);return r.length>0&&(n=xe(n,r)),B(n,e.shape)}function aI(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Rt(e);if("elu"===t)return gf(e);if("relu6"===t)return V0(e);if("prelu"===t)return Ky(e,n);if("leakyrelu"===t)return Uy(e,r);if("sigmoid"===t)return mi(e);throw new Error(`Unknown fused activation ${t}.`)}var iI=(e,t)=>!(e>0)||"linear"===t,w1e=L({fusedConv2d_:function b1e({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===iI(P.state.gradientDepth,l=l||"linear")){D("NHWC"===a,()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=Lr(e,t,n,r,a,i,s);return null!=o&&(C=J(C,o)),aI(C,l,u,c)}let h=N(e,"x","conv2d","float32"),d=N(t,"filter","conv2d","float32"),p=h,f=!1;3===h.rank&&(f=!0,p=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),D(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),D(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Pr("fused conv2d",r,s);let m="NHWC"===a?p.shape[3]:p.shape[1];D(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),D(bs(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let y,v,g=Oy(p.shape,d.shape,n,i,r,s);if(null!=o&&(y=N(o,"bias","fused conv2d"),[y]=pn(y,h),"NHWC"===a?Bt(g.outShape,y.shape):(D(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),D(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=u){let C=u.shape;if(D(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)D(1===C[0]||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===C.length)try{Bt(C,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}v=N(u,"prelu weights","fused conv2d")}let b=(C,k)=>{D("NHWC"===a,()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[T,A,R,M]=k,_=nI(C,R,l);D(nl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);let j=[oT(A.shape,_,T,n,r),YT(A,_,T.shape,n,r)];if(null!=M){let G=rI(M,_);j.push(G)}return j},w={x:p,filter:d,bias:y,preluActivationWeights:v},x={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s,activation:l,leakyreluAlpha:c};return null==o?ws((C,k,T)=>{let A=P.runKernel(Uc,w,x);return T([k,C,A]),f&&(A=B(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,d):ws((C,k,T,A)=>{let R=P.runKernel(Uc,w,x);return A([k,C,R,T]),f&&(R=B(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(p,d,y)}}),PG=L({depthwiseConv2dNativeBackpropFilter_:function x1e(e,t,n,r,a,i=[1,1],s){let o=e;3===e.rank&&(o=B(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;return 3===l.rank&&(l=B(t,[1,t.shape[0],t.shape[1],t.shape[2]])),P.runKernel(s0,{x:o,dy:l},{strides:r,pad:a,dimRoundingMode:s,dilations:i,filterShape:n})}}),LG=L({depthwiseConv2dNativeBackpropInput_:function I1e(e,t,n,r,a,i=[1,1],s){let o=t,l=!1;3===t.rank&&(l=!0,o=B(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h=P.runKernel(o0,{dy:o,filter:n},{strides:r,pad:a,dimRoundingMode:s,dilations:i,inputShape:e});return l?B(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),_1e=L({fusedDepthwiseConv2d_:function S1e({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===iI(P.state.gradientDepth,l)){let x=ed(e,t,n,r,a,i,s);return null!=o&&(x=J(x,o)),aI(x,l,u,c)}let h=N(e,"x","depthwiseConv2d","float32"),d=N(t,"filter","depthwiseConv2d","float32"),p=h,f=!1;3===h.rank&&(f=!0,p=B(h,[1,h.shape[0],h.shape[1],h.shape[2]])),D(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),D(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),D(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),D(bs(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Pr("fused depthwiseConv2d",r,s);let g,y,m=Oy(p.shape,d.shape,n,i,r,s,!0);null!=o&&(g=N(o,"bias","fused conv2d"),[g]=pn(g,h),Bt(m.outShape,g.shape)),null!=u&&(y=N(u,"prelu weights","fused depthwiseConv2d"));let v=(x,C)=>{D(nl(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[k,T,A,R]=C,M=nI(x,A,l),_=LG(T.shape,M,k,n,r,i,s),$=PG(T,M,k.shape,n,r,i,s);return null!=R?[_,$,rI(g,M)]:[_,$]},b={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:s,activation:l,leakyreluAlpha:c};return null==o?ws((x,C,k)=>{let T=P.runKernel(Wc,b,w);return k([C,x,T]),f&&(T=B(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:v}})(p,d):ws((x,C,k,T)=>{let A=P.runKernel(Wc,b,w);return T([C,x,A,k]),f&&(A=B(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:v}})(p,d,g)}}),E1e=L({fusedMatMul_:function C1e({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:i="linear",preluActivationWeights:s,leakyreluAlpha:o=.2}){if(!1===iI(P.state.gradientDepth,i)){let R=et(e,t,n,r);return null!=a&&(R=J(R,a)),aI(R,i,s,o)}let l=N(e,"a","fused matMul"),u=N(t,"b","fused matMul");[l,u]=pn(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Mt(f),y=Mt(m);D(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let x,C,v=Bt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),b=B(l,n?[g,c,d]:[g,d,c]),w=B(u,r?[y,p,h]:[y,h,p]);null!=a&&(x=N(a,"bias","fused matMul"),[x]=pn(x,l),Bt(v,x.shape)),null!=s&&(C=N(s,"prelu weights","fused matMul"));let k=(R,M)=>{let K,X,[_,$,U,j]=M,G=nI(B(R,U.shape),U,i);return n||r?!n&&r?(K=et(G,$,!1,!1),X=et(G,_,!0,!1)):n&&!r?(K=et($,G,!1,!0),X=et(_,G,!1,!1)):(K=et($,G,!0,!0),X=et(G,_,!0,!0)):(K=et(G,$,!1,!0),X=et(_,G,!0,!1)),null!=a?[K,X,rI(j,G)]:[K,X]},T={a:b,b:w,bias:x,preluActivationWeights:C},A={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:o};return null==a?ws((R,M,_)=>{let $=P.runKernel(Vc,T,A);return _([R,M,$]),{value:B($,v),gradFunc:k}})(b,w):ws((R,M,_,$)=>{let U=P.runKernel(Vc,T,A);return $([R,M,U,_]),{value:B(U,v),gradFunc:k}})(b,w,x)}}),N1e=L({hammingWindow_:function k1e(e){return tI(e,.54,.46)}}),zG=L({hannWindow_:function T1e(e){return tI(e,.5,.5)}}),BG=L({frame_:function D1e(e,t,n,r=!1,a=0){let i=0,s=[];for(;i+t<=e.size;)s.push(ct(e,i,t)),i+=n;if(r)for(;i<e.size;){let o=i+t-e.size,l=zt([ct(e,i,t-o),_a([o],a)]);s.push(l),i+=n}return 0===s.length?Is([],[0,t]):B(zt(s),[s.length,t])}}),M1e=L({stft_:function A1e(e,t,n,r,a=zG){null==r&&(r=XT(t));let i=BG(e,t,n),s=z(i,a(t));return Yy(s,r)}}),F1e=L({cropAndResize_:function R1e(e,t,n,r,a="bilinear",i=0){let s=N(e,"image","cropAndResize"),o=N(t,"boxes","cropAndResize","float32"),l=N(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return D(4===s.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`),D(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),D(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),D(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D("bilinear"===a||"nearest"===a,()=>`method must be bilinear or nearest, but was ${a}`),P.runKernel(mp,{image:s,boxes:o,boxInd:l},{method:a,extrapolationValue:i,cropSize:r})}}),$1e=L({flipLeftRight_:function O1e(e){let t=N(e,"image","flipLeftRight","float32");return D(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),P.runKernel(Ip,{image:t},{})}}),L1e=L({grayscaleToRGB_:function P1e(e){let t=N(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Ea(t,a)}}),B1e=L({rgbToGrayscale_:function z1e(e){let t=N(e,"image","RGBToGrayscale"),r=t.shape[t.rank-1];D(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),D(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o,a=t.dtype,i=de(t,"float32"),s=Tt([.2989,.587,.114]);switch(t.rank){case 2:o=td("ij,j->i",i,s);break;case 3:o=td("ijk,k->ij",i,s);break;case 4:o=td("ijkl,l->ijk",i,s);break;case 5:o=td("ijklm,m->ijkl",i,s);break;case 6:o=td("ijklmn,n->ijklm",i,s);break;default:throw new Error("Not a valid tensor rank.")}return o=nr(o,-1),de(o,a)}}),U1e=L({rotateWithOffset_:function V1e(e,t,n=0,r=.5){let a=N(e,"image","rotateWithOffset","float32");return D(4===a.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`),P.runKernel(sf,{image:a},{radians:t,fillValue:n,center:r})}});function Tf(e,t,n,r,a,i){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);let s=e.shape[0];return n=Math.min(n,s),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),D(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),D(1===t.rank,()=>"scores must be a 1D tensor"),D(t.shape[0]===s,()=>`scores has incompatible shape with boxes. Expected ${s}, but was ${t.shape[0]}`),D(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i}}var j1e=L({nonMaxSuppression_:function W1e(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let i=N(e,"boxes","nonMaxSuppression","float32"),s=N(t,"scores","nonMaxSuppression","float32"),o=Tf(i,s,n,r,a);return P.runKernel(Pp,{boxes:i,scores:s},{maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:a=o.scoreThreshold})}});function H1e(e,t,n){let r=function G1e(e,t,n){return function K1e(e,t,n){let r=0,a=e.length,i=0,s=!1;for(;r<a;){i=r+(a-r>>>1);let o=n(t,e[i]);o>0?r=i+1:(a=i,s=!o)}return s?r:-r-1}(e,t,n||q1e)}(e,t,n);e.splice(r<0?-(r+1):r,0,t)}function q1e(e,t){return e>t?1:e<t?-1:0}function VG(e,t,n,r,a){return QT(e,t,n,r,a,0)}function UG(e,t,n,r,a,i){return QT(e,t,n,r,a,0,!1,i,!0)}function WG(e,t,n,r,a,i){return QT(e,t,n,r,a,i,!0)}function QT(e,t,n,r,a,i,s=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(jG);let c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){let g=u.pop(),{score:y,boxIndex:v,suppressBeginIndex:b}=g;if(y<a)break;let w=!1;for(let x=h.length-1;x>=b;--x){let C=X1e(e,v,h[x]);if(C>=r){w=!0;break}if(g.score=g.score*Z1e(r,c,C),g.score<=a)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(v),d.push(g.score)):g.score>a&&H1e(u,g,jG))}let p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:h};return s&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function X1e(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),s=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(o-i)*(l-s),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;let m=Math.max(i,u),g=Math.max(s,c),y=Math.min(o,h),v=Math.min(l,d),b=Math.max(y-m,0)*Math.max(v-g,0);return b/(p+f-b)}function Z1e(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function jG(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function JT(){return JT=F(function*(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let i=N(e,"boxes","nonMaxSuppressionAsync"),s=N(t,"scores","nonMaxSuppressionAsync"),o=Tf(i,s,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=yield Promise.all([i.data(),s.data()]),u=l[0],c=l[1],{selectedIndices:h}=VG(u,c,n,r,a);return i!==e&&i.dispose(),s!==t&&s.dispose(),Tt(h,"int32")}),JT.apply(this,arguments)}var eSe=L({nonMaxSuppressionWithScore_:function J1e(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){let s=N(e,"boxes","nonMaxSuppression"),o=N(t,"scores","nonMaxSuppression"),l=Tf(s,o,n,r,a,i),h=P.runKernel(zp,{boxes:s,scores:o},{maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:a=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:h[0],selectedScores:h[1]}}});function eD(){return eD=F(function*(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){let s=N(e,"boxes","nonMaxSuppressionAsync"),o=N(t,"scores","nonMaxSuppressionAsync"),l=Tf(s,o,n,r,a,i);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,i=l.softNmsSigma;let u=yield Promise.all([s.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=WG(c,h,n,r,a,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:Tt(d,"int32"),selectedScores:Tt(p)}}),eD.apply(this,arguments)}var aSe=L({nonMaxSuppressionPadded_:function rSe(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){let s=N(e,"boxes","nonMaxSuppression"),o=N(t,"scores","nonMaxSuppression"),l=Tf(s,o,n,r,a,null),f=P.runKernel(Lp,{boxes:s,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:f[0],validOutputs:f[1]}}});function tD(){return tD=F(function*(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){let s=N(e,"boxes","nonMaxSuppressionAsync"),o=N(t,"scores","nonMaxSuppressionAsync"),l=Tf(s,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=yield Promise.all([s.data(),o.data()]),{selectedIndices:f,validOutputs:m}=UG(d,p,u,c,h,i);return s!==e&&s.dispose(),o!==t&&o.dispose(),{selectedIndices:Tt(f,"int32"),validOutputs:ke(m,"int32")}}),tD.apply(this,arguments)}var HG=L({resizeBilinear_:function oSe(e,t,n=!1,r=!1){let a=N(e,"images","resizeBilinear");D(3===a.rank||4===a.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),D(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=a,s=!1;3===a.rank&&(s=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,u=P.runKernel(Sc,{images:i},{alignCorners:n,halfPixelCenters:r,size:t});return s?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),GG=L({resizeNearestNeighbor_:function lSe(e,t,n=!1,r=!1){let a=N(e,"images","resizeNearestNeighbor");D(3===a.rank||4===a.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),D(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D("float32"===a.dtype||"int32"===a.dtype,()=>"`images` must have `int32` or `float32` as dtype"),D(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=a,s=!1;3===a.rank&&(s=!0,i=B(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,u=P.runKernel(Ic,{images:i},{alignCorners:n,halfPixelCenters:r,size:t});return s?B(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),dSe=L({threshold_:function uSe(e,t="binary",n=!1,r=.5){let c,h,d,p,a=N(e,"image","threshold"),l=a.shape[0]*a.shape[1],u=z(Tt([r]),255);if(D(3===a.rank,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),D(3===a.shape[2]||1===a.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),D("int32"===a.dtype||"float32"===a.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),D("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===a.shape[2]){[c,h,d]=ia(a,[1,1,1],-1);let m=z(c,.2989),g=z(h,.587),y=z(d,.114);p=J(J(m,g),y)}else p=e;"otsu"===t&&(u=function cSe(e,t){let i,s,o,l,u,c,n=Tt([-1]),r=Tt([0]),a=Tt([0]);for(let h=0;h<e.size-1;h++){i=ct(e,0,h+1),s=ct(e,h+1),u=ve(xe(i),t),c=ve(xe(s),t);let d=xe(z(i,id(0,i.size)));o=ve(d,xe(i));let p=_a(s.shape,i.size),f=J(id(0,s.size),p),m=z(s,f);l=ve(xe(m),xe(s));let g=ye(o,l),y=ye(o,l),v=z(u,c);a=z(z(v,g),y);let b=zr(a,r);r=tr(b,a,r),n=tr(b,Tt([h]),n)}return n}(tT(de(U0(p),"int32"),$r([]),256),l));let f=n?rl(p,u):zr(p,u);return de(z(f,255),"int32")}}),pSe=L({transform_:function hSe(e,t,n="nearest",r="constant",a=0,i){let s=N(e,"image","transform","float32"),o=N(t,"transforms","transform","float32");return D(4===s.rank,()=>`Error in transform: image must be rank 4,but got rank ${s.rank}.`),D(2===o.rank&&(o.shape[0]===s.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),P.runKernel(nf,{image:s,transforms:o},{interpolation:n,fillMode:r,fillValue:a,outputShape:i})}}),mSe=L({bandPart_:function fSe(e,t,n){let r=N(e,"a","bandPart");D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o,l,a=r.shape,[i,s]=r.shape.slice(-2);"number"==typeof t?(D(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),o=N(t<0?i:t,"numLower","bandPart")):(D("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=tr(xf(t,0),i,al(t,i))),"number"==typeof n?(D(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),D(n<=s,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${s}).`),l=N(n<0?s:n,"numUpper","bandPart")):(D("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=tr(xf(n,0),s,al(n,s)));let u=B(id(0,i,1,"int32"),[-1,1]),c=id(0,s,1,"int32"),h=ye(u,c),d=gi(rl(h,o),so(h,Yt(l))),p=mn([i,s],r.dtype);return B(Tn(vn(B(r,[-1,i,s])).map(f=>tr(d,f,p))),a)}}),ySe=L({gramSchmidt_:function gSe(e){let t;if(Array.isArray(e)){t=!1,D(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let i=1;i<e.length;++i)D(e[i].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${a})`)}else t=!0,e=ia(e,e.shape[0],0).map(a=>ol(a,[0]));D(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(P.tidy(()=>{let i=r[a];if(a>0)for(let s=0;s<a;++s){let o=z(xe(z(n[s],i)),n[s]);i=ye(i,o)}return ve(i,vf(i,"euclidean"))}));return t?Tn(n,0):n}});function qG(e,t=!1){return P.tidy(()=>{D(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=F0(n),i=vs(e),s=Is([[1]],[1,1]),o=vs(s),l=n>=r?r:n;for(let u=0;u<l;++u){let c=i,h=o,d=a;[o,i,a]=P.tidy(()=>{let p=ct(i,[u,u],[n-u,1]),f=vf(p),m=ct(i,[u,u],[1,1]),g=tr(zr(m,0),Is([[-1]]),Is([[1]])),y=ye(m,z(g,f)),v=ve(p,y);o=1===v.shape[0]?vs(s):zt([s,ct(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let b=Yt(ve(et(g,y),f)),w=ct(i,[u,0],[n-u,r]),x=z(b,o),C=tt(o);if(0===u)i=ye(w,et(x,et(C,w)));else{let A=ye(w,et(x,et(C,w)));i=zt([ct(i,[0,0],[u,r]),A],0)}let k=tt(x),T=ct(a,[0,u],[n,a.shape[1]-u]);if(0===u)a=ye(T,et(et(T,o),k));else{let A=ye(T,et(et(T,o),k));a=zt([ct(a,[0,0],[n,u]),A],1)}return[o,i,a]}),He([c,h,d])}return!t&&n>r&&(a=ct(a,[0,0],[n,r]),i=ct(i,[0,0],[r,r])),[a,i]})}var Br,bSe=L({qr_:function vSe(e,t=!1){if(D(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return qG(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=vn(B(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],i=[];return r.forEach(l=>{let[u,c]=qG(l,t);a.push(u),i.push(c)}),[B(Tn(a,0),e.shape),B(Tn(i,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Br||(Br={}));var oo=L({computeWeightedLoss_:function wSe(e,t,n=Br.SUM_BY_NONZERO_WEIGHTS){let r=N(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=N(t,"weights","computeWeightedLoss"));let i=null==a?r:z(r,a);if(n===Br.NONE)return i;if(n===Br.SUM)return xe(i);if(n===Br.MEAN){if(null==a)return fn(i);{let s=r.size/a.size,o=ve(xe(i),xe(a));return s>1?ve(o,ke(s)):o}}if(n===Br.SUM_BY_NONZERO_WEIGHTS){if(null==a)return ve(xe(i),ke(r.size));{let s=z(a,aa(r.shape)),o=de(xe(ad(s,ke(0))),"float32");return ve(xe(i),o)}}throw Error(`Unknown reduction: ${n}`)}}),ISe=L({absoluteDifference_:function xSe(e,t,n,r=Br.SUM_BY_NONZERO_WEIGHTS){let a=N(e,"labels","absoluteDifference"),i=N(t,"predictions","absoluteDifference"),s=null;null!=n&&(s=N(n,"weights","absoluteDifference")),Fr(a.shape,i.shape,"Error in absoluteDifference: ");let o=kn(ye(a,i));return oo(o,s,r)}}),_Se=L({cosineDistance_:function SSe(e,t,n,r,a=Br.SUM_BY_NONZERO_WEIGHTS){let i=N(e,"labels","cosineDistance"),s=N(t,"predictions","cosineDistance"),o=null;null!=r&&(o=N(r,"weights","cosineDistance")),Fr(i.shape,s.shape,"Error in cosineDistance: ");let l=ke(1),u=ye(l,xe(z(i,s),n,!0));return oo(u,o,a)}}),ESe=L({hingeLoss_:function CSe(e,t,n,r=Br.SUM_BY_NONZERO_WEIGHTS){let a=N(e,"labels","hingeLoss"),i=N(t,"predictions","hingeLoss"),s=null;null!=n&&(s=N(n,"weights","hingeLoss")),Fr(a.shape,i.shape,"Error in hingeLoss: ");let o=ke(1);a=ye(z(ke(2),a),o);let l=Rt(ye(o,z(a,i)));return oo(l,s,r)}}),NSe=L({huberLoss_:function kSe(e,t,n,r=1,a=Br.SUM_BY_NONZERO_WEIGHTS){let i=N(e,"labels","huberLoss"),s=N(t,"predictions","huberLoss"),o=null;null!=n&&(o=N(n,"weights","huberLoss")),Fr(i.shape,s.shape,"Error in huberLoss: ");let l=ke(r),u=kn(ye(s,i)),c=al(u,l),h=ye(u,c),d=J(z(ke(.5),Vt(c)),z(l,h));return oo(d,o,a)}}),DSe=L({logLoss_:function TSe(e,t,n,r=1e-7,a=Br.SUM_BY_NONZERO_WEIGHTS){let i=N(e,"labels","logLoss"),s=N(t,"predictions","logLoss"),o=null;null!=n&&(o=N(n,"weights","logLoss")),Fr(i.shape,s.shape,"Error in logLoss: ");let l=ke(1),u=ke(r),c=Yt(z(i,ka(J(s,u)))),h=z(ye(l,i),ka(J(ye(l,s),u))),d=ye(c,h);return oo(d,o,a)}}),MSe=L({meanSquaredError_:function ASe(e,t,n,r=Br.SUM_BY_NONZERO_WEIGHTS){let a=N(e,"labels","meanSquaredError"),i=N(t,"predictions","meanSquaredError"),s=null;null!=n&&(s=N(n,"weights","meanSquaredError")),Fr(a.shape,i.shape,"Error in meanSquaredError: ");let o=X0(a,i);return oo(o,s,r)}}),OSe=L({sigmoidCrossEntropy_:function FSe(e,t,n,r=0,a=Br.SUM_BY_NONZERO_WEIGHTS){let i=N(e,"multiClassLabels","sigmoidCrossEntropy"),s=N(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=N(n,"weights","sigmoidCrossEntropy")),Fr(i.shape,s.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=ke(r),c=ke(1),h=ke(.5);i=J(z(i,ye(c,u)),z(h,u))}let l=function RSe(e,t){let n=N(e,"labels","sigmoidCrossEntropyWithLogits"),r=N(t,"logits","sigmoidCrossEntropyWithLogits");Fr(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=Rt(r),i=z(r,n),s=Wy(_r(Yt(kn(r))));return J(ye(a,i),s)}(i,s);return oo(l,o,a)}}),LSe=L({softmaxCrossEntropy_:function PSe(e,t,n,r=0,a=Br.SUM_BY_NONZERO_WEIGHTS){let i=N(e,"onehotLabels","softmaxCrossEntropy"),s=N(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=N(n,"weights","softmaxCrossEntropy")),Fr(i.shape,s.shape,"Error in softmaxCrossEntropy: "),r>0){let u=ke(r),c=ke(1),h=ke(i.shape[1]);i=J(z(i,ye(c,u)),ve(u,h))}let l=function $Se(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ws((r,a,i)=>{let s=jy(a,[n],!0),o=ye(de(a,"float32"),s);i([r,o]);let l=Yt(z(o,r));return{value:xe(l,[n]),gradFunc:(u,c)=>{let[h,d]=c,p=nd(u.shape,[n]);return[z(B(u,p),ye(de(h,"float32"),_r(d))),z(B(u,p),ye(_r(d),de(h,"float32")))]}}})(e,t)}(i,s);return oo(l,o,a)}}),BSe=L({sparseFillEmptyRows_:function zSe(e,t,n,r){let a=N(e,"indices","sparseFillEmptyRows","int32"),i=N(t,"values","sparseFillEmptyRows"),s=N(n,"denseShape","sparseFillEmptyRows","int32"),o=N(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${s.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let u=P.runKernel(hy,{indices:a,values:i,denseShape:s,defaultValue:o});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),USe=L({sparseReshape_:function VSe(e,t,n){let r=N(e,"inputIndices","sparseReshape","int32"),a=N(t,"inputShape","sparseReshape","int32"),i=N(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);let o=P.runKernel(Qp,{inputIndices:r,inputShape:a,newShape:i});return{outputIndices:o[0],outputShape:o[1]}}}),jSe=L({sparseSegmentMean_:function WSe(e,t,n){let r=N(e,"data","sparseSegmentMean"),a=N(t,"indices","sparseSegmentMean","int32"),i=N(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return P.runKernel(py,{data:r,indices:a,segmentIds:i})}}),GSe=L({sparseSegmentSum_:function HSe(e,t,n){let r=N(e,"data","sparseSegmentSum"),a=N(t,"indices","sparseSegmentSum","int32"),i=N(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return P.runKernel(fy,{data:r,indices:a,segmentIds:i})}}),KSe=L({stringNGrams_:function qSe(e,t,n,r,a,i,s,o){let l=N(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=N(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let d=P.runKernel(yy,{data:l,dataSplits:u},{separator:n,nGramWidths:r,leftPad:a,rightPad:i,padWidth:s,preserveShortSequences:o});return{nGrams:d[0],nGramsSplits:d[1]}}}),ZSe=L({stringSplit_:function XSe(e,t,n=!0){let r=N(e,"input","stringSplit","string"),a=N(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let o=P.runKernel(vy,{input:r,delimiter:a},{skipEmpty:n});return{indices:o[0],values:o[1],shape:o[2]}}}),QSe=L({stringToHashBucketFast_:function YSe(e,t){let n=N(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return P.runKernel(by,{input:n},r)}}),e_e=L({staticRegexReplace_:function JSe(e,t,n,r=!0){let a=N(e,"input","staticRegexReplace","string");return P.runKernel(gy,{x:a},{pattern:t,rewrite:n,replaceGlobal:r})}}),KG={fft:Zy,ifft:kf,rfft:Yy,irfft:K0},XG={hammingWindow:N1e,hannWindow:zG,frame:BG,stft:M1e},Za={flipLeftRight:$1e,grayscaleToRGB:L1e,resizeNearestNeighbor:GG,resizeBilinear:HG,rgbToGrayscale:B1e,rotateWithOffset:U1e,cropAndResize:F1e,nonMaxSuppression:j1e,nonMaxSuppressionAsync:function Y1e(e,t,n){return JT.apply(this,arguments)},nonMaxSuppressionWithScore:eSe,nonMaxSuppressionWithScoreAsync:function tSe(e,t,n){return eD.apply(this,arguments)},nonMaxSuppressionPadded:aSe,nonMaxSuppressionPaddedAsync:function iSe(e,t,n){return tD.apply(this,arguments)},threshold:dSe,transform:pSe},nD={bandPart:mSe,gramSchmidt:ySe,qr:bSe},ZG={absoluteDifference:ISe,computeWeightedLoss:oo,cosineDistance:_Se,hingeLoss:ESe,huberLoss:NSe,logLoss:DSe,meanSquaredError:MSe,sigmoidCrossEntropy:OSe,softmaxCrossEntropy:LSe},YG={sparseFillEmptyRows:BSe,sparseReshape:USe,sparseSegmentMean:jSe,sparseSegmentSum:GSe},QG={stringNGrams:KSe,stringSplit:ZSe,stringToHashBucketFast:QSe,staticRegexReplace:e_e},ae={};je(ae,{Serializable:()=>JG,SerializationMap:()=>e6,getRegisteredName:()=>n_e,registerClass:()=>t6});var t_e=new Map,rD=new Map,JG=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},e6=class um{constructor(){this.classNameMap={}}static getMap(){return null==um.instance&&(um.instance=new um),um.instance}static register(t){um.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function t6(e,t,n){D(null!=e.className,()=>"Class being registered does not have the static className property defined."),D("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),D(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let a=t+">"+n;return e6.register(e),t_e.set(a,e),rD.set(e,a),e}function n_e(e){return rD.has(e)?rD.get(e):e.className}var lo=class extends JG{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let i=n.map(s=>({name:s.name,tensor:a[s.name]}));this.applyGradients(i)}else this.applyGradients(a);return He(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return JH(e,t)}dispose(){null!=this.iterations_&&He(this.iterations_)}saveIterations(){var e=this;return F(function*(){return null==e.iterations_&&(e.iterations_=0),{name:"iter",tensor:ke(e.iterations_,"int32")}})()}getWeights(){return F(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(e){var t=this;return F(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(e){var t=this;return F(function*(){return t.iterations_=(yield e[0].tensor.data())[0],e.slice(1)})()}};Object.defineProperty(lo,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var aD=class extends lo{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=P.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:V(()=>ft(r).variable(a))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:V(()=>ft(r).variable(a))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;V(()=>{let l=J(z(s,this.rho),z(Vt(i),1-this.rho)),u=z(ve(dr(J(o,this.epsilon)),dr(J(s,this.epsilon))),i),c=J(z(o,this.rho),z(Vt(u),1-this.rho));s.assign(l),o.assign(c);let h=J(z(u,-this.learningRate),r);r.assign(h)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(He(this.accumulatedGrads.map(e=>e.variable)),He(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return F(function*(){let t=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))})()}setWeights(e){var t=this;return F(function*(){let n=(e=yield t.extractIterations(e)).length/2,r=!1;t.accumulatedGrads=e.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),t.accumulatedUpdates=e.slice(n,2*n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},iD=class extends lo{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:V(()=>_a(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[n].variable;V(()=>{let s=J(i,Vt(a));i.assign(s);let o=J(z(ve(a,dr(J(s,P.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&He(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return F(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(e){var t=this;return F(function*(){e=yield t.extractIterations(e),t.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},sD=class extends lo{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],V(()=>{this.accBeta1=ke(t).variable(),this.accBeta2=ke(n).variable()}),null==r&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);V(()=>{let n=ye(1,this.accBeta1),r=ye(1,this.accBeta2);t.forEach((a,i)=>{let s=P.registeredVariables[a],o=!1;null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:V(()=>ft(s).variable(o))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:V(()=>ft(s).variable(o))});let l=Array.isArray(e)?e[i].tensor:e[a];if(null==l)return;let u=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,h=J(z(u,this.beta1),z(l,1-this.beta1)),d=J(z(c,this.beta2),z(Vt(l),1-this.beta2)),p=ve(h,n),f=ve(d,r);u.assign(h),c.assign(d);let m=J(z(ve(p,J(dr(f),this.epsilon)),-this.learningRate),s);s.assign(m)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&He(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&He(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return F(function*(){let t=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))})()}setWeights(e){var t=this;return F(function*(){e=yield t.extractIterations(e),V(()=>{t.accBeta1.assign(io(t.beta1,t.iterations_+1)),t.accBeta2.assign(io(t.beta2,t.iterations_+1))});let n=e.length/2,r=!1;t.accumulatedFirstMoment=e.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),t.accumulatedSecondMoment=e.slice(n,2*n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},oD=class extends lo{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],V(()=>{this.iteration=ke(0).variable(),this.accBeta1=ke(t).variable()}),null==r&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);V(()=>{let n=ye(1,this.accBeta1),r=ve(-this.learningRate,J(z(this.iteration,this.decay),1));t.forEach((a,i)=>{let s=P.registeredVariables[a],o=!1;null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:ft(s).variable(o)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:ft(s).variable(o)});let l=Array.isArray(e)?e[i].tensor:e[a];if(null==l)return;let u=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,h=J(z(u,this.beta1),z(l,1-this.beta1)),d=z(c,this.beta2),p=kn(l),f=xs(d,p);u.assign(h),c.assign(f);let m=J(z(ve(r,n),ve(h,J(f,this.epsilon))),s);s.assign(m)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&He(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&He(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return F(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return F(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},sI=class extends lo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=P.registeredVariables[t];V(()=>{let i=J(z(this.c,r),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Bn(ke(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return F(function*(){return[yield e.saveIterations()]})()}setWeights(e){var t=this;return F(function*(){if(0!==(e=yield t.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},lD=class extends sI{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=ke(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:V(()=>ft(r).variable(!1))});let a=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&V(()=>{let s,o=J(z(this.m,a),i);s=J(z(this.c,this.useNesterov?J(i,z(o,this.m)):o),r),a.assign(o),r.assign(s)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&He(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return F(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(e){var t=this;return F(function*(){e=yield t.extractIterations(e),t.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},uD=class extends lo{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=P.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:V(()=>ft(r).variable(a))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:V(()=>ft(r).variable(a))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:V(()=>ft(r).variable(a))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let s=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;V(()=>{let l=J(z(s,this.decay),z(Vt(i),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=J(z(u,this.decay),z(i,1-this.decay)),h=ve(z(i,this.learningRate),dr(ye(l,J(Vt(c),this.epsilon)))),d=J(z(o,this.momentum),h);s.assign(l),u.assign(c),o.assign(d);let p=ye(r,d);r.assign(p)}else{let u=J(z(s,this.decay),z(Vt(i),1-this.decay)),c=J(z(o,this.momentum),ve(z(i,this.learningRate),dr(J(u,this.epsilon))));s.assign(u),o.assign(c);let h=ye(r,c);r.assign(h)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&He(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&He(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&He(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return F(function*(){let t=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&t.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))})()}setWeights(e){var t=this;return F(function*(){e=yield t.extractIterations(e);let n=t.centered?e.length/3:e.length/2,r=!1;t.accumulatedMeanSquares=e.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),t.accumulatedMoments=e.slice(n,2*n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),t.centered&&(t.accumulatedMeanGrads=e.slice(2*n,3*n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},r_e=[aD,iD,sD,oD,lD,uD,sI],hr={};function n6(e){return new Promise(t=>setTimeout(t)).then(e)}je(hr,{CompositeArrayBuffer:()=>no,browserFiles:()=>d_e,browserHTTPRequest:()=>y_e,concatenateArrayBuffers:()=>Hbe,copyModel:()=>pwe,decodeWeights:()=>IH,decodeWeightsStream:()=>CH,encodeWeights:()=>zbe,fromMemory:()=>b_e,fromMemorySync:()=>l6,getLoadHandlers:()=>Jbe,getModelArtifactsForJSON:()=>NN,getModelArtifactsForJSONSync:()=>TH,getModelArtifactsInfoForJSON:()=>Ry,getSaveHandlers:()=>Qbe,getWeightSpecs:()=>DN,http:()=>mD,isHTTPScheme:()=>fD,listModels:()=>dwe,loadWeights:()=>p_e,moveModel:()=>fwe,registerLoadRouter:()=>Ybe,registerSaveRouter:()=>Zbe,removeModel:()=>hwe,weightsLoaderFactory:()=>i6,withSaveHandler:()=>w_e,withSaveHandlerSync:()=>x_e});var cD=(()=>{let e=class EO{constructor(n){if(!H().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");n.startsWith(EO.URL_SCHEME)&&(n=n.slice(EO.URL_SCHEME.length)),(null==n||0===n.length)&&(n="model"),this.modelJsonFileName=n+".json",this.weightDataFileName=n+".weights.bin"}save(n){var r=this;return F(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let a=no.join(n.weightData),i=window.URL.createObjectURL(new Blob([a],{type:"application/octet-stream"}));if(n.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let o=NH(n,[{paths:["./"+r.weightDataFileName],weights:n.weightSpecs}]),l=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),u=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(u.download=r.modelJsonFileName,u.href=l,yield n6(()=>u.dispatchEvent(new MouseEvent("click"))),null!=n.weightData){let c=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;c.download=r.weightDataFileName,c.href=i,yield n6(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ry(n)}}})()}};return e.URL_SCHEME="downloads://",e})(),l_e=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}load(){var e=this;return F(function*(){return new Promise((t,n)=>{let r=new FileReader;r.onload=a=>{let i=JSON.parse(a.target.result),s=i.modelTopology;if(null==s)return void n(new Error(`modelTopology field is missing from file ${e.jsonFile.name}`));if(null==i.weightsManifest)return void n(new Error(`weightManifest field is missing from file ${e.jsonFile.name}`));if(0===e.weightsFiles.length)return void t({modelTopology:s});let o=NN(i,l=>e.loadWeights(l));t(o)},r.onerror=a=>n(`Failed to read model topology and weights manifest JSON from file '${e.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(e.jsonFile)})})()}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(a).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=i=>{n(i.target.result)},a.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>kH(a.name)),r={};for(let a of e)a.paths.forEach(i=>{let s=kH(i);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[i]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function d_e(e){return new l_e(e)}function r6(e,t,n,r){(function s(l){D(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(e),function o(l,u){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),D(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(n=n??0,r=r??1);let a=0;return Promise.all(e.map(l=>(l.then(u=>{let c=n+ ++a/e.length*(r-n);return t(c),u}),l)))}function a6(e,t){return dD.apply(this,arguments)}function dD(){return dD=F(function*(e,t){null==t&&(t={});let n=null==t.fetchFunc?H().platform.fetch:t.fetchFunc,r=e.map(i=>n(i,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield r6(r,t.onProgress,0,.5)).map(i=>i.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield r6(a,t.onProgress,.5,1)}),dD.apply(this,arguments)}function p_e(e){return hD.apply(this,arguments)}function hD(){return hD=F(function*(e,t="",n,r){return i6(a=>a6(a,{requestInit:r}))(e,t,n)}),hD.apply(this,arguments)}function i6(e){return function(){var t=F(function*(n,r="",a){let i=n.map(()=>!1),s={},o=null!=a?a.map(()=>!1):[],l=[];if(n.forEach((f,m)=>{let g=0;f.weights.forEach(y=>{let b=qc["quantization"in y?y.quantization.dtype:y.dtype]*Mt(y.shape),w=()=>{i[m]=!0,null==s[m]&&(s[m]=[]),s[m].push({manifestEntry:y,groupOffset:g,sizeBytes:b})};null!=a?a.forEach((x,C)=>{x===y.name&&(w(),o[C]=!0)}):w(),l.push(y.name),g+=b})}),!o.every(f=>f)){let f=a.filter((m,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}let u=i.reduce((f,m,g)=>(m&&f.push(g),f),[]),c=[];u.forEach(f=>{n[f].paths.forEach(m=>{let g=r+(r.endsWith("/")?"":"/")+m;c.push(g)})});let h=yield e(c),d={},p=0;return u.forEach(f=>{let m=n[f].paths.length,g=new no(h.slice(p,p+m));s[f].forEach(y=>{let b=IH(g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),[y.manifestEntry]);for(let w in b)d[w]=b[w]}),p+=m}),d});return function(n){return t.apply(this,arguments)}}()}qa.registerSaveRouter(e=>H().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(cD.URL_SCHEME)?function c_e(e="model"){return new cD(e)}(e.slice(cD.URL_SCHEME.length)):null);var pD=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(D("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=H().platform.fetch,D(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}save(e){var t=this;return F(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;let a=NH(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(n.body.append("model.json",new Blob([JSON.stringify(a)],{type:"application/json"}),"model.json"),null!=e.weightData){let s=no.join(e.weightData);n.body.append("model.weights.bin",new Blob([s],{type:"application/octet-stream"}),"model.weights.bin")}let i=yield t.fetch(t.path,n);if(i.ok)return{modelArtifactsInfo:Ry(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})()}loadModelJSON(){var e=this;return F(function*(){let n,t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{n=yield t.json()}catch{let s=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}if(null==n.modelTopology&&null==n.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return n})()}load(){var e=this;return F(function*(){return e.loadOptions.streamWeights?e.loadStream():NN(yield e.loadModelJSON(),n=>e.loadWeights(n))})()}loadStream(){var e=this;return F(function*(){let t=yield e.loadModelJSON(),n=yield e.getWeightUrls(t.weightsManifest),r=DN(t.weightsManifest);return Object.assign(Object.assign({},t),{weightSpecs:r,getWeightStream:()=>function h_e(e,t){var n;let i,r=null==t.fetchFunc?H().platform.fetch:t.fetchFunc,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:(s=F(function*(o){for(var l;a<e.length;){i||(i=(yield r(e[a],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:c}=yield i.read();if(!u)return void o.enqueue(c);a++,i=void 0,null===(l=t.onProgress)||void 0===l||l.call(t,a/e.length)}o.close()}),function(l){return s.apply(this,arguments)})});var s}(n,e.loadOptions)})})()}getWeightUrls(e){var t=this;return F(function*(){let n=Array.isArray(t.path)?t.path[1]:t.path,[r,a]=function g_e(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),i=t.weightPathPrefix||r,s=[],o=[];for(let l of e)for(let u of l.paths)null!=t.weightUrlConverter?o.push(t.weightUrlConverter(u)):s.push(i+u+a);return t.weightUrlConverter&&s.push(...yield Promise.all(o)),s})()}loadWeights(e){var t=this;return F(function*(){let n=yield t.getWeightUrls(e);return[DN(e),yield a6(n,t.loadOptions)]})()}};function fD(e){return null!=e.match(pD.URL_SCHEME_REGEX)}pD.URL_SCHEME_REGEX=/^https?:\/\//;var s6=(e,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(r=>fD(r)):fD(e),n)return mD(e,t)}return null};function mD(e,t){return new pD(e,t)}function y_e(e,t){return mD(e,t)}qa.registerSaveRouter(s6),qa.registerLoadRouter(s6);var gD=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},o6=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},v_e=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function b_e(e,t,n,r){return new v_e(l6(...arguments))}function l6(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new gD(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gD({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gD({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function w_e(e){return new o6(e)}function x_e(e){return new o6(e)}var u6={};je(u6,{confusionMatrix:()=>S_e});var S_e=L({confusionMatrix_:function I_e(e,t,n){let r=N(e,"labels","confusionMatrix"),a=N(t,"predictions","confusionMatrix");D(null==n||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),D(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),D(1===a.rank,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),D(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),D(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let i=If(de(r,"int32"),n),s=If(de(a,"int32"),n),o=tt(i),l=et(o,s);return de(l,"int32")}}),Qy={};je(Qy,{draw:()=>A_e,fromPixels:()=>M_e,fromPixelsAsync:()=>N_e,toPixels:()=>D_e});var od,c6=!1;function d6(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,i=!1,s=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)s=!0;else{if(!(typeof ImageBitmap<"u"&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Sy(y0,P.backendName))return P.runKernel(y0,{pixels:e},{numChannels:t});let c,h,[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(s)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(i||a||o){if(null==od)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");od=new OffscreenCanvas(1,1).getContext("2d")}else od=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});od.canvas.width=l,od.canvas.height=u,od.drawImage(e,0,0,l,u),c=od.getImageData(0,0,l,u).data}if(4===t)h=new Int32Array(c);else{let d=l*u;h=new Int32Array(d*t);for(let p=0;p<d;p++)for(let f=0;f<t;++f)h[p*t+f]=c[4*p+f]}return Z0(h,[u,l,t],"int32")}function N_e(e){return yD.apply(this,arguments)}function yD(){return yD=F(function*(e,t=3){let n=null;if(H().getBool("WRAP_TO_IMAGEBITMAP")&&function k_e(e){return function C_e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(e instanceof ImageBitmap)&&function E_e(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function __e(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let r;try{r=yield createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}n=null!=r&&r.width===e.width&&r.height===e.height?r:e}else n=e;return d6(n,t)}),yD.apply(this,arguments)}function h6(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function D_e(e,t){return vD.apply(this,arguments)}function vD(){return vD=F(function*(e,t){let n=N(e,"img","toPixels");if(!(e instanceof Ze)){let u=n;n=de(u,"int32"),u.dispose()}h6(n);let[r,a]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2],s=yield n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let c=[0,0,0,255];for(let d=0;d<i;d++){let p=s[u*i+d];if("float32"===n.dtype){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if("int32"===n.dtype&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);1===i?(c[0]=p*o,c[1]=p*o,c[2]=p*o):c[d]=p*o}let h=4*u;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(null!=t){c6||null!=Sy(l0,P.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),c6=!0),t.width=a,t.height=r;let u=t.getContext("2d"),c=new ImageData(l,a,r);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}),vD.apply(this,arguments)}function A_e(e,t,n){let r=N(e,"img","draw");if(!(e instanceof Ze)){let s=r;r=de(s,"int32"),s.dispose()}h6(r),function T_e(e){let t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(n?.imageOptions),P.runKernel(l0,{image:r},{canvas:t,options:n})}var M_e=L({fromPixels_:d6}),bD={};function p6(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Mt(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,i=a[a.length-1],s=1;for(let h=0;h<a.length-1;++h)s*=a[h];let o=e.shape,l=a.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=o[h],l.push(o[h]);let c=[...ep(e.shape).map(h=>h/u),1].slice(0,i);return[l,s,u,c]}je(bD,{prepareAndValidate:()=>p6});var Vn={};je(Vn,{assertParamsValid:()=>F_e,computeFlatOffset:()=>z_e,computeOutShape:()=>$_e,getNormalizedAxes:()=>P_e,isSliceContinous:()=>L_e,maskToAxes:()=>O_e,parseSliceParams:()=>I6,sliceInfo:()=>B_e,startForAxis:()=>w6,startIndicesWithElidedDims:()=>y6,stopForAxis:()=>x6,stopIndicesWithElidedDims:()=>v6,stridesForAxis:()=>b6,stridesWithElidedDims:()=>f6});var wD=-2,R_e=-1;function F_e(e,t,n){let r=e.shape.length;D(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),D(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)D(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function O_e(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function $_e(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function f6(e,t,n,r){let a=[...e];for(let i=a.length;i<r.length;i++)a.push(1);for(let i=0;i<n;i++)0===i?a[t]=1:(a.splice(t,0,1),a.pop());return a}function m6(e,t,n){return n<=e?n:n-(t-1)}function g6(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function P_e(e,t,n,r,a,i,s,o,l){let u=e.length,c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){let p=t[0],f=n+1;c=y6(s,p,f,r,e),h=v6(o,p,f,a,e),d=f6(i,p,f,e)}else for(let p=0;p<u;p++)c[p]=w6(s,r,i,e,p,l),h[p]=x6(o,a,i,e,p,l),d[p]=b6(i,p,l);return{begin:c,end:h,strides:d}}function y6(e,t,n,r,a){let i=[...a],s=g6(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=0;else{let l=m6(t,n,o),u=r[l];e&1<<l&&(u=0),i[o]=u}return i}function v6(e,t,n,r,a){let i=[...a],s=g6(n,t);for(let o=0;o<i.length;o++)if(s.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{let l=m6(t,n,o),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[o]=u}for(let o=0;o<i.length;o++)i[o]<0&&(i[o]+=a[o]),i[o]=Qg(0,i[o],a[o]);return i}function b6(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function w6(e,t,n,r,a,i){let s=t[a];(e&1<<a||i&1<<a||null==s)&&(s=(n[a]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return s<0&&(s+=l),s=Qg(0,s,l-1),s}function x6(e,t,n,r,a,i){let s=t[a],o=n[a]||1;(e&1<<a||i&1<<a||null==s)&&(s=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return s<0&&(s+=l),s=o>0?Qg(0,s,l):Qg(-1,s,l-1),s}function L_e(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function z_e(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function I6(e,t,n){let r,i,a=e.shape.length;return r="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach(s=>{D(-1!==s,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,i=i.map((s,o)=>s>=0?s:(D(-1===s,()=>`Negative size values should be exactly -1 but got ${s} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,i]}function B_e(e,t,n,r,a,i,s,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=s&&s&s-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:i,ellipsisMask:s,newAxisMask:o,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)c&&1<<v&o&&h.numAddAxisAfterEllipsis++,1<<v&s&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function V_e(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(wD),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(R_e),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0,g=[],y=[];for(let v=0;v<e.length;++v){if(0===d.strides[v])throw Error(`strides[${v}] must be non-zero`);let b=!!(d.shrinkAxisMask&1<<v),w=e[v];if(-1===w){g.push(b?1:-1);continue}let x=[d.beginMask&1<<v,d.endMask&1<<v],C=[d.strides[v]>0?0:-1,d.strides[v]>0?w:w-1];if(b&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[v];let k=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(b){let M=d.begin[v]<0?w+d.begin[v]:d.begin[v];if(d.begin[v]=M,d.end[v]=d.begin[v]+1,M<0||M>=w)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=S6(d.begin[v],0,d.strides[v],w,x,C),d.end[v]=S6(d.end[v],1,d.strides[v],w,x,C);let R=1===d.strides[v]&&0===d.begin[v]&&d.end[v]===w;p=p&&R,f=f&&(0===v&&1===d.strides[v]||R)}else p=p&&1===d.strides[v]&&k,f=f&&(0===v&&1===d.strides[v]||k);let T,A=!1;if(d.beginValid&&d.endValid?(T=d.end[v]-d.begin[v],A=!0):b?(T=1,A=!0):k&&w>=0&&(T=d.strides[v]<0?-w:w,A=!0),A){let R;R=0===T||T<0!=d.strides[v]<0?0:Math.trunc(T/d.strides[v])+(T%d.strides[v]!=0?1:0),g.push(R)}else g.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){let b=d.finalShapeGatherIndices[v];b>=0?y.push(g[b]):b===wD&&y.push(1)}return{finalShapeSparse:y.filter((v,b)=>d.finalShapeGatherIndices[b]!==wD),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function S6(e,t,n,r,a,i){if(a[t])return n>0?i[t]:i[t+1&1];{let s=e<0?r+e:e;return s<i[0]?i[0]:s>i[1]?i[1]:s}}var U_e="4.16.0",_6=class{static sgd(e){return new sI(e)}static momentum(e,t,n=!1){return new lD(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new uD(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new sD(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new aD(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new oD(e,t,n,r,a)}static adagrad(e,t=.1){return new iD(e,t)}},ld=_6,W_e=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function xD(){return new Promise(e=>W_e(()=>e()))}var Ss,E={};function j_e(e,t){let n=e[0].length;e.forEach((a,i)=>{D(a.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),D(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,i)=>{for(let s=0;s<n;s++)D(s===t||a[s]===r[s],()=>`Error in concat${n}D: Shape of tensors[${i}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function H_e(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function G_e(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let i=n[a],s=r[r.length-n.length+a],o=r[s];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${i} but shape[${a+e}] = ${o}`)}else r[s]=i}return r}function q_e(e){let t={FIRST_DIM_SIZE:Ss.FIRST_DIM_SIZE,VALUE_ROWIDS:Ss.VALUE_ROWIDS,ROW_LENGTHS:Ss.ROW_LENGTHS,ROW_SPLITS:Ss.ROW_SPLITS,ROW_LIMITS:Ss.ROW_LIMITS,ROW_STARTS:Ss.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function K_e(e){return 0===e.length?0:e[0]===Ss.FIRST_DIM_SIZE?e.length-1:e.length}function X_e(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let i=e[a],s=t[a+1];if(i>=0&&s>=0&&1!==i&&i!==s)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${i} but ragged tensor input.flatValues.shape[${a-e.length}] = ${s}`)}}je(E,{ERF_A1:()=>aCe,ERF_A2:()=>iCe,ERF_A3:()=>sCe,ERF_A4:()=>oCe,ERF_A5:()=>lCe,ERF_P:()=>rCe,PARALLELIZE_THRESHOLD:()=>ID,RowPartitionType:()=>Ss,SELU_SCALE:()=>E6,SELU_SCALEALPHA:()=>C6,applyActivation:()=>aI,assertAndGetBroadcastShape:()=>Bt,assertAxesAreInnerMostDims:()=>Bxe,assertParamsConsistent:()=>j_e,assignToTypedArray:()=>fCe,axesAreInnerMostDims:()=>mT,calculateShapes:()=>kG,checkEinsumDimSizes:()=>wCe,checkPadOnDimRoundingMode:()=>Pr,combineLocations:()=>KH,combineRaggedTensorToTensorShapes:()=>G_e,complexWithEvenIndex:()=>dCe,complexWithOddIndex:()=>hCe,computeConv2DInfo:()=>Oy,computeConv3DInfo:()=>zH,computeDefaultPad:()=>XN,computeDilation2DInfo:()=>Lwe,computeOptimalWindowSize:()=>Z_e,computeOutAndReduceShapes:()=>XH,computeOutShape:()=>H_e,computePool2DInfo:()=>LH,computePool3DInfo:()=>zwe,convertConv2DDataFormat:()=>BH,decodeEinsumEquation:()=>vCe,eitherStridesOrDilationsAreOne:()=>bs,expandShapeToKeepDim:()=>nd,exponent:()=>gCe,exponents:()=>mCe,fromStringArrayToUint8:()=>VCe,fromUint8ToStringArray:()=>BCe,getAxesPermutation:()=>ZH,getBroadcastDims:()=>GH,getComplexWithIndex:()=>pCe,getEinsumComputePath:()=>xCe,getEinsumPermutation:()=>bCe,getFusedBiasGradient:()=>rI,getFusedDyActivation:()=>nI,getImageCenter:()=>Y_e,getInnerMostAxes:()=>Vxe,getPermuted:()=>J_e,getRaggedRank:()=>K_e,getReductionAxes:()=>Nn,getReshaped:()=>Q_e,getReshapedPermuted:()=>eCe,getRowPartitionTypesHelper:()=>q_e,getSliceBeginCoords:()=>tCe,getSliceSize:()=>nCe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>CCe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ECe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>kCe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>DCe,getSparseReshapeInputOutputMismatchErrorMessage:()=>MCe,getSparseReshapeInputOutputMultipleErrorMessage:()=>ACe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>NCe,getSparseReshapeNegativeOutputDimErrorMessage:()=>TCe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>$Ce,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>RCe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>FCe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>OCe,getUndoAxesPermutation:()=>gT,isIdentityPermutation:()=>ICe,log:()=>Kve,mergeRealAndImagArrays:()=>uCe,prepareAndValidate:()=>p6,prepareSplitSize:()=>_Ce,segment_util:()=>T6,shouldFuse:()=>iI,slice_util:()=>Vn,splitRealAndImagArrays:()=>cCe,stridesOrDilationsArePositive:()=>Zc,tupleValuesAreOne:()=>nl,upcastType:()=>Ga,validateDefaultValueShape:()=>X_e,validateInput:()=>Q0,validateUpdateShape:()=>VT,warn:()=>Xo}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Ss||(Ss={}));var ID=30;function Z_e(e){return e<=ID?e:e0(e,Math.floor(Math.sqrt(e)))}function Y_e(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Q_e(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let i=t.length;for(let s=0;s<i;++s)a=a.concat([e[s+1]/t[s],t[s]]);a=a.concat(e.slice(i+1))}return a}function J_e(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],i=[];for(let s=1;s<e;++s)s>=2*t+1||s%2==1?i.push(s):a.push(s);r.push(...a),r.push(0),r.push(...i)}return r}function eCe(e,t,n,r=!0){let a=[];a.push(r?e[0]/n:e[0]*n);for(let i=1;i<e.length;++i)a.push(i<=t.length?r?t[i-1]*e[i]:e[i]/t[i-1]:e[i]);return a}function tCe(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function nCe(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var C6=1.7580993408473768,E6=1.0507009873554805,rCe=.3275911,aCe=.254829592,iCe=-.284496736,sCe=1.421413741,oCe=-1.453152027,lCe=1.061405429;function uCe(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function cCe(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function dCe(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function hCe(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function pCe(e,t){return{real:e[2*t],imag:e[2*t+1]}}function fCe(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function mCe(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let i=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(i),r[a]=Math.sin(i)}return{real:n,imag:r}}function gCe(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var SD="->",yCe=/->/g,k6=",",N6="...";function vCe(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(yCe,"").length)/SD.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${SD}").`);let[r,a]=e.split(SD);D(-1===r.indexOf(N6),()=>`The ellipsis notation ("${N6}") is not supported yet.`);let i=r.split(k6),s=i.length;if(t!==s)throw new Error(`Expected ${s} input tensors, received ${t}`);if(s>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let p=a[d];if(!i.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===o.indexOf(p)&&o.push(p)}for(let d=0;d<r.length;++d){let p=r[d];-1===o.indexOf(p)&&p!==k6&&o.push(p)}let l=new Array(i.length);for(let d=0;d<s;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<i[d].length;++p)l[d].push(o.indexOf(i[d][p]))}let u=o.length,h=[];for(let d=a.length;d<u;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function bCe(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter(a=>-1!==a),{permutationIndices:n,expandDims:r}}function wCe(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let i=n[a].shape;for(let s=0;s<t[a].length;++s)void 0===r[t[a][s]]?r[t[a][s]]=i[s]:D(r[t[a][s]]===i[s],()=>`Expected dimension ${r[t[a][s]]} at axis ${s} of input shaped ${JSON.stringify(i)}, but got dimension ${i[s]}`)}}function xCe(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let s=0;s<a;++s)r.push([]);let i=[];for(let s=0;s<n.length;++s){let l=SCe(t,n[s]);for(let u of l)-1===i.indexOf(u)&&(r[s].push(u),i.push(u))}return{path:n,steps:r}}function ICe(e){return e.every((t,n)=>t===n)}function SCe(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function _Ce(e,t,n=0){let r=[];if("number"==typeof t)D(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{D(t.reduce((s,o)=>(-1===o&&(s+=1),s),0)<=1,()=>"There should be only one negative value in split array.");let i=t.indexOf(-1);if(-1!==i){let s=t.reduce((o,l)=>l>0?o+l:o);t[i]=e.shape[n]-s}D(e.shape[n]===t.reduce((s,o)=>s+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function CCe(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function ECe(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function kCe(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function NCe(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function TCe(e,t){return`size ${e} must be non-negative, not ${t}`}function DCe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ACe(e,t){return`Input to reshape is a SparseTensor with ${Mt(e)}\n  dense values, but the requested shape requires a multiple of ${Mt(t)}. inputShape=${e} outputShape= ${t}`}function MCe(e,t){return`Input to reshape is a tensor with ${Mt(e)} dense values, but the requested shape has ${Mt(t)}. inputShape=${e} outputShape=${t}`}function RCe(){return"segment ids must be >= 0"}function FCe(){return"segment ids are not increasing"}function OCe(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function $Ce(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var T6={};function PCe(e,t){let r,n=!1;for(e<=ID?(r=e,n=!0):r=e0(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=e0(e,r+1);return r}function LCe(e,t,n){let r=[],a=e.length;for(let i=0;i<a;i++)r.push(i!==t?e[i]:n);return r}function zCe(e,t,n,r){let a=t.shape.length,i=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let s=e.shape[n],o=[],l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<a;h++)o.push(t.shape[h]);for(let h=n+1;h<i;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:s,outputShape:o}}function BCe(e){try{return e.map(t=>x0(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function VCe(e){return e.map(t=>ky(t))}je(T6,{collectGatherOpShapeInfo:()=>zCe,computeOutShape:()=>LCe,segOpComputeOptimalWindowSize:()=>PCe});var _s={};je(_s,{nonMaxSuppressionV3Impl:()=>VG,nonMaxSuppressionV4Impl:()=>UG,nonMaxSuppressionV5Impl:()=>WG,whereImpl:()=>DG}),function a_e(){for(let e of r_e)t6(e)}();var D6={kernelName:np,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,sd(de(n,"float32"),-1))}}},UCe={kernelName:Su,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Vt(de(n,"float32")),a=dr(ye(ke(1),r));return Yt(ve(e,a))}}}},WCe={kernelName:_u,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=dr(ye(Vt(de(n,"float32")),1));return ve(e,r)}}}},jCe={kernelName:Ho,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=e,s=Nn(n.shape,a);return s.length>0&&(i=xe(i,s)),B(i,n.shape)},b:()=>{let i=e,s=Nn(r.shape,a);return s.length>0&&(i=xe(i,s)),B(i,r.shape)}}}},HCe={kernelName:Cu,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},GCe={kernelName:ip,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ft(n)}}},qCe={kernelName:sp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ft(n)}}},KCe={kernelName:Eu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,dr(ye(ke(1),Vt(de(n,"float32")))))}}},XCe={kernelName:ku,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=dr(J(ke(1),Vt(de(n,"float32"))));return ve(e,r)}}}},ZCe={kernelName:Du,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=J(Vt(n),Vt(r)),s=z(e,ve(r,i)),o=Nn(n.shape,a);return o.length>0&&(s=xe(s,o)),B(s,n.shape)},b:()=>{let i=J(Vt(n),Vt(r)),s=Yt(z(e,ve(n,i))),o=Nn(r.shape,a);return o.length>0&&(s=xe(s,o)),B(s,r.shape)}}}},YCe={kernelName:Nu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,J(Vt(de(n,"float32")),1))}}},QCe={kernelName:Tu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,ye(ke(1),Vt(de(n,"float32"))))}}},eEe=L({avgPool3dGrad_:function JCe(e,t,n,r,a,i){let s=N(e,"dy","avgPool3dGrad"),o=N(t,"input","avgPool3dGrad"),l=s,u=o,c=!1;4===o.rank&&(c=!0,l=B(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),u=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),D(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Pr("avgPool3dGrad",a,i);let p=P.runKernel(ny,{dy:l,input:u},{filterSize:n,strides:r,pad:a,dimRoundingMode:i});return c?B(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),tEe={kernelName:op,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:s,dimRoundingMode:o}=n;return{x:()=>eEe(e,r,a,i,s,o)}}},rEe=L({avgPoolGrad_:function nEe(e,t,n,r,a){let i=N(e,"dy","avgPoolGrad"),s=N(t,"input","avgPoolGrad");D(s.rank===i.rank,()=>`Rank of input (${s.rank}) does not match rank of dy (${i.rank})`);let o=s,l=i,u=!1;3===s.rank&&(u=!0,o=B(s,[1,s.shape[0],s.shape[1],s.shape[2]]),l=B(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),D(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let d=P.runKernel(ty,{dy:l,input:o},{filterSize:n,strides:r,pad:a});return u?B(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),aEe={kernelName:Au,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:s}=n;return{x:()=>rEe(e,r,a,i,s)}}},iEe={kernelName:Mu,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:i,transposeB:s}=n;return i||s?!i&&s?{a:()=>et(e,a,!1,!1),b:()=>et(e,r,!0,!1)}:i&&!s?{a:()=>et(a,e,!1,!0),b:()=>et(r,e,!1,!1)}:{a:()=>et(a,e,!0,!0),b:()=>et(e,r,!0,!0)}:{a:()=>et(e,a,!1,!0),b:()=>et(r,e,!0,!1)}}},sEe={kernelName:lp,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>qy(e,r,a)}}},oEe={kernelName:tH,gradFunc:(e,t,n)=>{let a=n.inputShape,i=n.shape,s=Array.from(i);for(let l=a.length-1;l>=0;l--)if(a[l]===i[l])s[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${i}].`);let o=[];for(let l=0;l<s.length;l++)s[l]>1&&o.push(l);return{x:()=>xe(e,o,!0)}}},lEe={kernelName:Ru,gradFunc:e=>({x:()=>e.clone()})},uEe={kernelName:Fu,gradFunc:e=>({x:()=>ft(e)})},cEe={kernelName:Go,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:i}=n;return{x:()=>tr(gi(so(r,a),rl(r,i)),e,ft(e))}}},dEe={kernelName:ay,inputsToSave:["x"],gradFunc:D6.gradFunc},hEe={kernelName:dp,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,i=pi(a,t[0].shape)[0],s=r.map(o=>o[i]);return ia(e,s,i).map(o=>()=>o)}},pEe={kernelName:Ou,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:i,strides:s,pad:o,dataFormat:l}=n;return D(nl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>oT(r.shape,e,a,s,o,l),filter:()=>YT(r,e,a.shape,s,o,l)}}},fEe={kernelName:$u,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:i,pad:s,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Lr(e,a,i,s,o,1,l),filter:()=>YT(e,r,a.shape,i,s,o,l)}}},gEe=L({conv3DBackpropFilter_:function mEe(e,t,n,r,a){let i=e;4===e.rank&&(i=B(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let s=t;return 4===s.rank&&(s=B(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),D(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),D(5===s.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`),D(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),D(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),D(s.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${n[4]}).`),P.runKernel(hp,{x:i,dy:s},{strides:r,pad:a,filterShape:n})}}),yEe={kernelName:Pu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i}=n;D(nl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[s,o]=t;return{x:()=>jH(s.shape,e,o,a,i),filter:()=>gEe(s,e,o.shape,a,i)}}},vEe={kernelName:Lu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Yt(H0(de(n,"float32"))),e)}}},bEe={kernelName:zu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(G0(de(n,"float32")),e)}}},wEe={kernelName:Bu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:i,reverse:s}=n;return{x:()=>{let o=ZH([a],r.rank),l=M0(e,a,i,!s);return null!=o&&(l=tt(l,o)),l}}}},xEe={kernelName:Vu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i,dimRoundingMode:s}=n,o=r??[1,1];D(nl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return D(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),D(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),D(bs(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),Pr("depthwiseConv2d",i,s),{x:()=>LG(l.shape,e,u,a,i,o,s),filter:()=>PG(l,e,u.shape,a,i,o,s)}}},IEe={kernelName:Uu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,i={x:r,filter:a,dy:e},s={x:r,filter:a,dy:e};return{x:()=>P.runKernel(yp,i,n),filter:()=>P.runKernel(vp,s,n)}}},SEe={kernelName:ju,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>P.runKernel(bp,r)}}},_Ee={kernelName:Hu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(_r(Yt(Vt(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,r)}}},CEe={kernelName:Gu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},EEe={kernelName:xp,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>B(e,n.shape)}}},kEe={kernelName:qu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,_r(n))}}},NEe={kernelName:Ku,gradFunc:e=>({x:()=>ft(e)})},TEe={kernelName:Xu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=ve(e,de(r,"float32")),s=Nn(n.shape,a);return s.length>0?B(xe(i,s),n.shape):i},b:()=>{let i=z(e,de(n,"float32")),s=Nn(r.shape,a);s.length>0&&(i=B(xe(i,s),r.shape));let o=Vt(r);return Yt(ve(i,de(o,"float32")))}}}},DEe={kernelName:Zu,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,i,s,o]=t,l=o??ke(1),u=Nn(i.shape,a.shape),c=[];if(1===i.rank){for(let m=0;m<a.shape.length-1;++m)c.push(a.shape[m]);c.push(1)}let h=ye(a,i),d=z(e,l),p=W0(J(s,ke(r))),f=z(z(z(p,p),p),ke(-.5));return{x:()=>B(z(z(e,1===i.rank?Ea(B(p,[1,1,1,i.shape[0]]),c):p),l),a.shape),mean:()=>{let m=z(z(p,ke(-1)),d);return 1===i.rank&&(m=xe(m,u)),B(m,i.shape)},variance:()=>{let m=z(z(f,h),d);return 1===i.rank&&(m=xe(m,u)),B(m,i.shape)},scale:()=>{let m=z(h,p),g=z(e,m);return 1===i.rank&&(g=xe(g,u)),B(g,i.shape)},offset:()=>{let m=e;return 1===i.rank&&(m=xe(m,u)),B(m,i.shape)}}}},AEe={kernelName:Sp,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:i,batchDims:s}=n,o=pi(i,r.shape)[0],l=(u,c,h)=>()=>{let d=u.shape,p=c.size,f=d.slice(0,o),m=f.length,g=d.slice(i,d.length).slice(1),y=g.length,v=A6(0,m),b=A6(m+1,m+1+y),w=M6([f,[p],g]),x=B(h,w),C=B(c,[p]),k=M6([[m],v,b]),T=tt(x,k),A=eI(T,C,u.shape[o]),R=gT(k);return A=tt(A,R),A};if(1===s){let c=r.split(r.shape[0],0);return{x:()=>Tn(c.map((h,d)=>l(h,a.slice(d,1),e.slice(d,1))())).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function A6(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function M6(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var MEe={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>ft(n),b:()=>ft(r)}}},REe={kernelName:Qu,gradFunc:e=>({x:()=>de(e,"float32")})},FEe={kernelName:Ju,gradFunc:e=>({x:()=>ft(e)})},OEe={kernelName:ec,gradFunc:e=>({x:()=>ft(e)})},$Ee={kernelName:tc,gradFunc:e=>({x:()=>ft(e)})},PEe={kernelName:nc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,i=zr(r,0);return{x:()=>tr(i,e,z(e,a))}}},LEe={kernelName:ac,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,J(n,1))}}},zEe={kernelName:rc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,de(n,"float32"))}}},BEe={kernelName:rH,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let i=_r(r);return ye(e,z(xe(e,a,!0),i))}}}},UEe=L({localResponseNormalizationBackprop_:function VEe(e,t,n,r=5,a=1,i=1,s=.5){return P.runKernel(Mp,{x:e,y:t,dy:n},{depthRadius:r,bias:a,alpha:i,beta:s})}}),WEe={kernelName:ic,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:i,bias:s,alpha:o,beta:l}=n;return{x:()=>UEe(r,a,e,i,s,o,l)}}};function R6(e,t,n,r){return t.rank<n.rank&&(t=B(t,nd(t.shape,r))),e.rank<n.rank&&(e=B(e,nd(e.shape,r))),{x:()=>z(e,de(Ca(n,t),e.dtype))}}var F6={kernelName:sc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,i=t[0],l=R6(e,t[1],i,pi(a,i.shape));return{x:()=>l.x()}}},jEe={kernelName:oc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,de(so(n,r),"float32")),b:()=>z(e,de(xf(n,r),"float32"))}}},GEe=L({maxPool3dGrad_:function HEe(e,t,n,r,a,i,s){let o=N(e,"dy","maxPool3dGrad"),l=N(t,"input","maxPool3dGrad"),u=N(n,"output","maxPool3dGrad"),c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=B(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=B(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=B(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),D(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),D(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),D(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Pr("maxPool3dGrad",i,s);let g=P.runKernel(uy,{dy:c,input:h,output:d},{filterSize:r,strides:a,pad:i,dimRoundingMode:s});return p?B(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),qEe={kernelName:Rp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=n;return{x:()=>GEe(e,r,a,i,s,o,l)}}},XEe=L({maxPoolGrad_:function KEe(e,t,n,r,a,i,s){let o=N(e,"dy","maxPoolGrad"),l=N(t,"input","maxPoolGrad"),u=N(n,"output","maxPoolGrad");return D(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),D(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),D(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Pr("maxPoolGrad",i,s),P.runKernel(ly,{dy:o,input:l,output:u},{filterSize:r,strides:a,pad:i,dimRoundingMode:s})}}),ZEe={kernelName:lc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:s,pad:o}=n;return{x:()=>XEe(e,r,a,i,s,o)}}},YEe={kernelName:uc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=pi(a,r.shape),o=Mt(XH(r.shape,i)[1]);return{x:()=>{let l=r.shape.slice();i.forEach(c=>{l[c]=1});let u=B(e,l);return ve(z(u,aa(r.shape,"float32")),o)}}}},QEe={kernelName:cc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[i,s]=t,l=R6(e,s,i,pi(a,i.shape));return{x:()=>l.x()}}},JEe={kernelName:dc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,de(rl(n,r),"float32")),b:()=>z(e,de(zr(n,r),"float32"))}}},eke={kernelName:hc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map(s=>s[0]);return{x:()=>ct(e,i,r.shape)}}},tke={kernelName:pc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=Nn(n.shape,a);return i.length>0?B(xe(e,i),n.shape):e},b:()=>{let i=z(e,Yt(bf(ve(n,r)))),s=Nn(r.shape,a);return s.length>0?B(xe(i,s),r.shape):i}}}},nke={kernelName:fc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=z(e,de(r,"float32")),s=Nn(n.shape,a);return s.length>0?B(xe(i,s),n.shape):i},b:()=>{let i=z(e,de(n,"float32")),s=Nn(r.shape,a);return s.length>0?B(xe(i,s),r.shape):i}}}},rke={kernelName:Op,gradFunc:e=>({x:()=>Yt(e)})},ike={kernelName:Bp,gradFunc:e=>({x:()=>ft(e)})},ske={kernelName:Vp,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return vn(e,r).map(a=>()=>a)}},O6={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map(s=>s[0]);return{x:()=>ct(e,i,r.shape)}}},oke={kernelName:yc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,i=n,s=r,o=Bt(i.shape,s.shape);return{a:()=>{let l=de(s,"float32"),u=z(e,z(l,io(i,ye(l,ke(1))))),c=Nn(i.shape,o);return c.length>0&&(u=xe(u,c)),B(u,i.shape)},b:()=>{let l=zr(i,0),u=tr(l,ka(i),ft(i)),c=z(e,z(a,u)),h=Nn(s.shape,o);return h.length>0&&(c=xe(c,h)),B(c,s.shape)}}}},lke={kernelName:vc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=zr(n,0);return{x:()=>tr(a,e,z(e,r)),alpha:()=>{let i=tr(a,ft(e),z(e,n)),s=Nn(r.shape,e.shape);return s.length>0&&(i=xe(i,s)),B(i,r.shape)}}}};var dke={kernelName:bc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=[];return i=null==a?r.shape.map((s,o)=>o):"number"==typeof a?[a]:a,{x:()=>function cke(e,t,n){let r=e.shape.length,a=r-n.length,i=E.getAxesPermutation(n,r),s=e;null!=i&&(s=tt(e,i));let o=s.shape.slice(),l=o.splice(r-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);let c=function uke(e,t,n){let r=e.shape.slice();r[n]=1;let a=B(t,r),i=By(e,n,!0,!1),s=By(e,n,!0,!0),o=z(i,s);return z(a,o)}(s.reshape(o),t,a);if(c=c.reshape(s.shape),null!=i){let h=E.getUndoAxesPermutation(i);c=tt(c,h)}return c}(r,e,i)}}},hke={kernelName:Wu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=ve(e,de(r,"float32")),s=Nn(n.shape,a);return s.length>0?B(xe(i,s),n.shape):i},b:()=>{let i=z(e,de(n,"float32")),s=Nn(r.shape,a);s.length>0&&(i=B(xe(i,s),r.shape));let o=Vt(r);return Yt(ve(i,de(o,"float32")))}}}},pke={kernelName:wc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,Yt(Vt(n)))}}},fke={kernelName:_c,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(rl(n,6),sd(n));return{x:()=>z(e,de(r,"float32"))}}},mke={kernelName:xc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,de(sd(n),"float32"))}}},gke={kernelName:Up,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>B(e,n.shape)}}},yke={kernelName:Sc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>P.runKernel(jp,a,n)}}},vke={kernelName:Ic,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>P.runKernel(Wp,a,n)}}},bke={kernelName:Cc,gradFunc:(e,t,n)=>{let{dims:r}=n,a=pi(r,e.shape);return{x:()=>Xa(e,a)}}},wke={kernelName:Ec,gradFunc:e=>({x:()=>ft(e)})},xke={kernelName:kc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yt(ve(e,z(io(n,1.5),2)))}}},Ike={kernelName:Kp,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>de(ft(n),"float32"),t:()=>z(e,de(n,e.dtype)),e:()=>z(e,de(Hy(n),e.dtype))}}},Ske={kernelName:Nc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=zr(n,ke(0)),a=ke(C6),i=ke(E6),s=z(e,i),o=z(z(e,a),_r(de(n,"float32")));return tr(r,s,o)}}}},_ke={kernelName:Mc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,ye(ke(1),n)))}}},Cke={kernelName:Ac,gradFunc:e=>({x:()=>ft(e)})},Eke={kernelName:Tc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(zy(de(n,"float32")),e)}}},kke={kernelName:Dc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(A0(de(n,"float32")),e)}}},Nke={kernelName:Xp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:i}=n,s=r.shape,[o,l]=I6(r,a,i),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],s[c]-o[c]-l[c]]);return{x:()=>Wi(e,u)}}},Tke={kernelName:$c,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=z(e,r);return{logits:()=>ye(s,z(xe(s,[a],!0),r))}}},Dke={kernelName:Rc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,mi(n))}}},$6={kernelName:Zp,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>Ly(e,r,a)}}},P6={kernelName:Yp,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>zt(e,r)}}},Ake={kernelName:Fc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,z(dr(de(n,"float32")),2))}}},Mke={kernelName:my,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(de(n,"float32"),2))}}},Rke={kernelName:Pc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ke(2);return{a:()=>z(e,z(a,ye(n,r))),b:()=>z(e,z(a,ye(r,n)))}}},Fke={kernelName:Ko,gradFunc:e=>({x:()=>ft(e)})},Oke={kernelName:Lc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bt(n.shape,r.shape);return{a:()=>{let i=e,s=Nn(n.shape,a);return s.length>0&&(i=xe(i,s)),B(i,n.shape)},b:()=>{let i=e,s=Nn(r.shape,a);return s.length>0&&(i=xe(i,s)),B(Yt(i),r.shape)}}}},$ke={kernelName:Oc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:i}=n;pi(i,r.shape).forEach(l=>{a[l]=1});let s=B(e,a),o=z(s,aa(r.shape,"float32"));return{x:()=>o}}},Pke={kernelName:zc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ve(e,Vt(zy(n)))}}},Lke={kernelName:Bc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(ye(ke(1),Vt(n)),e)}}},zke={kernelName:qo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let i=ft(r);if(1===r.rank)for(let s=0;s<a[0];++s)i=J(i,ct(e,[s*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let s=0;s<a[0];++s)for(let o=0;o<a[1];++o)i=J(i,ct(e,[s*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let s=0;s<a[0];++s)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)i=J(i,ct(e,[s*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let s=0;s<a[0];++s)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let u=0;u<a[3];++u)i=J(i,ct(e,[s*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},Bke={kernelName:eo,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,i=gT(a);return{x:()=>tt(e,i)}}},Vke={kernelName:rf,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Tn(e,a)}}},Uke={kernelName:xy,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function Wke(e,t){let n=xs(t,ft(t)),r=wf(e,n),a=so(t,ke(0,"int32")),i=r.rank-a.rank;for(let o=0;o<i;++o)a=nr(a,o+1);a=gi(a,aa(r.shape,"bool"));let s=ft(r);return tr(a,r,s)}(e,n)}}},jke={kernelName:af,gradFunc:e=>({x:()=>ft(e)})},Hke=[D6,UCe,WCe,jCe,HCe,GCe,qCe,KCe,XCe,ZCe,YCe,QCe,tEe,aEe,iEe,sEe,oEe,lEe,uEe,cEe,dEe,hEe,fEe,pEe,yEe,vEe,bEe,wEe,xEe,IEe,hke,SEe,_Ee,CEe,EEe,kEe,TEe,NEe,DEe,AEe,MEe,REe,FEe,OEe,$Ee,PEe,LEe,zEe,BEe,WEe,F6,F6,jEe,qEe,ZEe,YEe,QEe,JEe,eke,tke,nke,rke,{kernelName:mc,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>mn(n.shape,"float32")}}},ike,ske,O6,O6,oke,lke,dke,pke,fke,mke,gke,yke,vke,bke,wke,xke,Ike,Ske,_ke,Cke,Eke,kke,Nke,Tke,Dke,$6,$6,P6,P6,Ake,Rke,Mke,Fke,Oke,$ke,Pke,Lke,zke,Bke,Vke,Uke,jke];for(let e of Hke)aH(e);Q().prototype.abs=function(){return this.throwIfDisposed(),kn(this)},Q().prototype.acos=function(){return this.throwIfDisposed(),VN(this)},Q().prototype.acosh=function(){return this.throwIfDisposed(),UN(this)},Q().prototype.add=function(e){return this.throwIfDisposed(),J(this,e)},Q().prototype.all=function(e,t){return this.throwIfDisposed(),N0(this,e,t)},Q().prototype.any=function(e,t){return this.throwIfDisposed(),Fy(this,e,t)},Q().prototype.argMax=function(e){return this.throwIfDisposed(),Xc(this,e)},Q().prototype.argMin=function(e){return this.throwIfDisposed(),WN(this,e)},Q().prototype.asScalar=function(){return this.throwIfDisposed(),D(1===this.size,()=>"The array must have only 1 element."),B(this,[])},Q().prototype.asType=function(e){return this.throwIfDisposed(),de(this,e)},Q().prototype.as1D=function(){return this.throwIfDisposed(),B(this,[this.size])},Q().prototype.as2D=function(e,t){return this.throwIfDisposed(),B(this,[e,t])},Q().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),B(this,[e,t,n])},Q().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),B(this,[e,t,n,r])},Q().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),B(this,[e,t,n,r,a])},Q().prototype.asin=function(){return this.throwIfDisposed(),jN(this)},Q().prototype.asinh=function(){return this.throwIfDisposed(),HN(this)},Q().prototype.atan=function(){return this.throwIfDisposed(),GN(this)},Q().prototype.atan2=function(e){return this.throwIfDisposed(),qN(this,e)},Q().prototype.atanh=function(){return this.throwIfDisposed(),KN(this)},Q().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),ao(this,e,t,n,r)},Q().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Ly(this,e,t)},Q().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),Qc(this,e,t,n,r,a)},Q().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Jc(this,e)},Q().prototype.cast=function(e){return this.throwIfDisposed(),de(this,e)},Q().prototype.ceil=function(){return this.throwIfDisposed(),nT(this)},Q().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Sr(this,e,t)},Q().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ze&&(e=[e]),zt([this,...e],t)},Q().prototype.conv1d=function(e,t,n,r,a,i){return this.throwIfDisposed(),T0(this,e,t,n,r,a,i)},Q().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),D0(this,e,t,n,r,a)},Q().prototype.conv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),Lr(this,e,t,n,r,a,i)},Q().prototype.cos=function(){return this.throwIfDisposed(),zy(this)},Q().prototype.cosh=function(){return this.throwIfDisposed(),A0(this)},Q().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),By(this,e,t,n)},Q().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),M0(this,e,t,n)},Q().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),cT(this,e,t)},Q().prototype.depthwiseConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),ed(this,e,t,n,r,a,i)},Q().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),dT(this,e,t,n,r,a)},Q().prototype.divNoNan=function(e){return this.throwIfDisposed(),hT(this,e)},Q().prototype.div=function(e){return this.throwIfDisposed(),ve(this,e)},Q().prototype.dot=function(e){return this.throwIfDisposed(),pT(this,e)},Q().prototype.elu=function(){return this.throwIfDisposed(),gf(this)},Q().prototype.equal=function(e){return this.throwIfDisposed(),Ca(this,e)},Q().prototype.erf=function(){return this.throwIfDisposed(),fT(this)},Q().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),yT(this,e,t)},Q().prototype.exp=function(){return this.throwIfDisposed(),_r(this)},Q().prototype.expandDims=function(e){return this.throwIfDisposed(),nr(this,e)},Q().prototype.expm1=function(){return this.throwIfDisposed(),vT(this)},Q().prototype.fft=function(){return this.throwIfDisposed(),Zy(this)},Q().prototype.flatten=function(){return this.throwIfDisposed(),B(this,[this.size])},Q().prototype.floor=function(){return this.throwIfDisposed(),bf(this)},Q().prototype.floorDiv=function(e){return this.throwIfDisposed(),k0(this,e)},Q().prototype.gather=function(e,t,n){return this.throwIfDisposed(),wf(this,e,t,n)},Q().prototype.greaterEqual=function(e){return this.throwIfDisposed(),so(this,e)},Q().prototype.greater=function(e){return this.throwIfDisposed(),zr(this,e)},Q().prototype.ifft=function(){return this.throwIfDisposed(),kf(this)},Q().prototype.irfft=function(){return this.throwIfDisposed(),K0(this)},Q().prototype.isFinite=function(){return this.throwIfDisposed(),bT(this)},Q().prototype.isInf=function(){return this.throwIfDisposed(),wT(this)},Q().prototype.isNaN=function(){return this.throwIfDisposed(),xT(this)},Q().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Uy(this,e)},Q().prototype.lessEqual=function(e){return this.throwIfDisposed(),rl(this,e)},Q().prototype.less=function(e){return this.throwIfDisposed(),xf(this,e)},Q().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),IT(this,e,t,n,r)},Q().prototype.logSigmoid=function(){return this.throwIfDisposed(),ST(this)},Q().prototype.logSoftmax=function(e){return this.throwIfDisposed(),$0(this,e)},Q().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),jy(this,e,t)},Q().prototype.log=function(){return this.throwIfDisposed(),ka(this)},Q().prototype.log1p=function(){return this.throwIfDisposed(),Wy(this)},Q().prototype.logicalAnd=function(e){return this.throwIfDisposed(),gi(this,e)},Q().prototype.logicalNot=function(){return this.throwIfDisposed(),Hy(this)},Q().prototype.logicalOr=function(e){return this.throwIfDisposed(),P0(this,e)},Q().prototype.logicalXor=function(e){return this.throwIfDisposed(),_T(this,e)},Q().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),et(this,e,t,n)},Q().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),rr(this,e,t,n,r)},Q().prototype.max=function(e,t){return this.throwIfDisposed(),Ka(this,e,t)},Q().prototype.maximum=function(e){return this.throwIfDisposed(),xs(this,e)},Q().prototype.mean=function(e,t){return this.throwIfDisposed(),fn(this,e,t)},Q().prototype.min=function(e,t){return this.throwIfDisposed(),yf(this,e,t)},Q().prototype.minimum=function(e){return this.throwIfDisposed(),al(this,e)},Q().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),ET(this,e,t)},Q().prototype.mod=function(e){return this.throwIfDisposed(),kT(this,e)},Q().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)},Q().prototype.neg=function(){return this.throwIfDisposed(),Yt(this)},Q().prototype.norm=function(e,t,n){return this.throwIfDisposed(),vf(this,e,t,n)},Q().prototype.notEqual=function(e){return this.throwIfDisposed(),ad(this,e)},Q().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),If(this,e,t,n)},Q().prototype.onesLike=function(){return this.throwIfDisposed(),Na(this)},Q().prototype.pad=function(e,t){return this.throwIfDisposed(),Wi(this,e,t)},Q().prototype.pool=function(e,t,n,r,a,i){return this.throwIfDisposed(),NT(this,e,t,n,r,a,i)},Q().prototype.pow=function(e){return this.throwIfDisposed(),io(this,e)},Q().prototype.prelu=function(e){return this.throwIfDisposed(),Ky(this,e)},Q().prototype.prod=function(e,t){return this.throwIfDisposed(),TT(this,e,t)},Q().prototype.reciprocal=function(){return this.throwIfDisposed(),$T(this)},Q().prototype.relu=function(){return this.throwIfDisposed(),Rt(this)},Q().prototype.relu6=function(){return this.throwIfDisposed(),V0(this)},Q().prototype.reshapeAs=function(e){return this.throwIfDisposed(),B(this,e.shape)},Q().prototype.reshape=function(e){return this.throwIfDisposed(),B(this,e)},Q().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),HG(this,e,t,n)},Q().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),GG(this,e,t,n)},Q().prototype.reverse=function(e){return this.throwIfDisposed(),Xa(this,e)},Q().prototype.rfft=function(){return this.throwIfDisposed(),Yy(this)},Q().prototype.round=function(){return this.throwIfDisposed(),U0(this)},Q().prototype.rsqrt=function(){return this.throwIfDisposed(),W0(this)},Q().prototype.selu=function(){return this.throwIfDisposed(),j0(this)},Q().prototype.separableConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),_f(this,e,t,n,r,a,i)},Q().prototype.sigmoid=function(){return this.throwIfDisposed(),mi(this)},Q().prototype.sign=function(){return this.throwIfDisposed(),LT(this)},Q().prototype.sin=function(){return this.throwIfDisposed(),H0(this)},Q().prototype.sinh=function(){return this.throwIfDisposed(),G0(this)},Q().prototype.slice=function(e,t){return this.throwIfDisposed(),ct(this,e,t)},Q().prototype.softmax=function(e){return this.throwIfDisposed(),sl(this,e)},Q().prototype.softplus=function(){return this.throwIfDisposed(),rd(this)},Q().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),qy(this,e,t)},Q().prototype.split=function(e,t){return this.throwIfDisposed(),ia(this,e,t)},Q().prototype.sqrt=function(){return this.throwIfDisposed(),dr(this)},Q().prototype.square=function(){return this.throwIfDisposed(),Vt(this)},Q().prototype.squaredDifference=function(e){return this.throwIfDisposed(),X0(this,e)},Q().prototype.squeeze=function(e){return this.throwIfDisposed(),ol(this,e)},Q().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Ze?[this,e]:[this,...e];return Tn(n,t)},Q().prototype.step=function(e){return this.throwIfDisposed(),sd(this,e)},Q().prototype.stridedSlice=function(e,t,n,r,a,i,s,o){return this.throwIfDisposed(),zT(this,e,t,n,r,a,i,s,o)},Q().prototype.sub=function(e){return this.throwIfDisposed(),ye(this,e)},Q().prototype.sum=function(e,t){return this.throwIfDisposed(),xe(this,e,t)},Q().prototype.tan=function(){return this.throwIfDisposed(),BT(this)},Q().prototype.tanh=function(){return this.throwIfDisposed(),Yc(this)},Q().prototype.tile=function(e){return this.throwIfDisposed(),Ea(this,e)},Q().prototype.toBool=function(){return this.throwIfDisposed(),de(this,"bool")},Q().prototype.toFloat=function(){return this.throwIfDisposed(),de(this,"float32")},Q().prototype.toInt=function(){return this.throwIfDisposed(),de(this,"int32")},Q().prototype.topk=function(e,t){return this.throwIfDisposed(),UT(this,e,t)},Q().prototype.transpose=function(e){return this.throwIfDisposed(),tt(this,e)},Q().prototype.unique=function(e){return this.throwIfDisposed(),WT(this,e)},Q().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),eI(this,e,t)},Q().prototype.unstack=function(e){return this.throwIfDisposed(),vn(this,e)},Q().prototype.where=function(e,t){return this.throwIfDisposed(),tr(e,this,t)},Q().prototype.zerosLike=function(){return this.throwIfDisposed(),ft(this)};var ul=class lQ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,lQ.prototype)}},Cs=class uQ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,uQ.prototype)}},W=class cQ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,cQ.prototype)}},nt=class dQ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,dQ.prototype)}},Gke=class hQ extends Error{constructor(t){super(t),Object.setPrototypeOf(this,hQ.prototype)}},L6=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function ud(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function Es(e,t){if(!e)throw new Gke(t)}function z6(e,t){let n=0;for(let r of e)r===t&&n++;return n}function sa(e){return 1===e.length?e[0]:e}function Ft(e){return Array.isArray(e)?e:[e]}function uo(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function cd(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var yi={};function _D(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function CD(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(t=>CD(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?CD(r):e[n]=r.value)}}}function Jy(e,t={},n={},r="object",a=!1){if("string"==typeof e){let s;if(e in n)s=n[e];else if(e in yi)s=yi[e];else if(s=t[e],null==s)throw new W(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{let i=e;if(null==i.className||null==i.config)throw new W(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);let o,l,s=i.className;if(s in n?[o,l]=n[s]:s in yi?[o,l]=yi.className:s in t&&([o,l]=t[s]),null==o)throw new W(`Unknown ${r}: ${s}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){let u={};for(let p of Object.keys(yi))u[p]=yi[p];for(let p of Object.keys(n))u[p]=n[p];i.config.customObjects=u;let h=Object.assign({},yi);for(let p of Object.keys(n))yi[p]=n[p];CD(i.config);let d=l(o,i.config,n,a);return yi=Object.assign({},h),d}{let u=Object.assign({},yi);for(let h of Object.keys(n))yi[h]=n[h];let c=new o(i.config);return yi=Object.assign({},u),c}}}function oI(e,t){return-1*function qke(e,t){return e<t?-1:e>t?1:0}(e,t)}function cl(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function Kke(e){if(null==e)throw new W(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function dd(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new W(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function ED(e,t,n=0,r=1/0){return Es(n>=0),Es(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function ar(e,t){Array.isArray(e)?(I.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>ar(n,`element ${r+1} of ${t}`))):I.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${B6(e)}.`)}function B6(e){return null===e?"null":Array.isArray(e)?"["+e.map(t=>B6(t)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function V6(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var Zke=0;function U6(){return Zke++}var lI={};function uI(e=""){return e in lI||(lI[e]=0),lI[e]+=1,e+lI[e].toString()}var Yke=["channelsFirst","channelsLast"],Qke=["nearest","bilinear"],Jke=["valid","same","causal"],eNe=["max","avg"],tNe=["sum","mul","concat","ave"],Df=new Map;function bn(e){dd(Yke,"DataFormat",e)}function Ya(e){dd(Jke,"PaddingMode",e)}function W6(e){dd(eNe,"PoolMode",e)}var ev=[];function hd(e,t){ev.push(e);try{let n=t();return ev.pop(),n}catch(n){throw ev.pop(),n}}function H6(e){if(!q6(e))throw new Error("Not a valid tensor name: '"+e+"'");return function rNe(){return 0===ev.length?"":ev.join("/")+"/"}()+e}function G6(e){if(!q6(e))throw new Error("Not a valid tensor name: '"+e+"'");Df.has(e)||Df.set(e,0);let t=Df.get(e);if(Df.set(e,Df.get(e)+1),t>0){let n=`${e}_${t}`;return Df.set(n,1),n}return e}var kD,aNe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function q6(e){return!!e.match(aNe)}function iNe(e){return e===parseInt(e.toString(),10)}function dl(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function Af(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function hl(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function ji(e,t){if(t<e)throw new W(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Un(){return null==kD&&(kD=IN().epsilon()),kD}function co(e,t){return de(e,t)}function tv(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),B(e,n)}function pd(e,t,n){return V(()=>{switch(e.rank){case 1:return Xy(e,t,n);case 2:return q0(e,[t,0],[n,e.shape[1]]);case 3:return Cf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Ef(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ct(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ct(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new W(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function ND(e,t,n){return V(()=>{switch(e.rank){case 1:return Xy(e,t,n);case 2:return q0(e,[0,t],[e.shape[0],n]);case 3:return Cf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Ef(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new W(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cI(e,t,n,r){return V(()=>{switch(e.rank){case 1:return Xy(e,t,n);case 2:switch(r){case 1:return pd(e,t,n);case 2:return ND(e,t,n);default:throw new W(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return pd(e,t,n);case 2:return Cf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ND(e,t,n);default:throw new W(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return pd(e,t,n);case 2:return Ef(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Ef(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ND(e,t,n);default:throw new W(`The axis is not within the rank of the tensor ${r}`)}default:throw new W(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function TD(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),zt(e,t)}function K6(e,t){switch(e.rank){case 1:return rT([e,t]);case 2:return aT([e,t],0);case 3:return iT([e,t],0);case 4:return sT([e,t],0);default:throw new W(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function DD(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new W(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ea(e,t)}function dI(e,t=0,n=1,r,a){return B0(e,t,n,r,a)}function ks(e,t,n,r){if(e.rank<2||t.rank<2)throw new nt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return Nf.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?AD(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),i=a.pop();e=B(e,[-1,i]);let s=t.shape.slice(),o=s.pop(),l=s.pop(),u=[...s,o],c=Array.from({length:t.rank},(d,p)=>0===p?t.rank-2:p<=t.rank-2?p-1:p);t=B(tt(t,c),[l,-1]);let h=[...a,...u];return B(Nf.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?AD(e.rank,r,"channelsLast"):null,activation:n}),h)}}function X6(e,t,n){return V(()=>(t=Array.isArray(t)?Tt(t,"int32"):de(t,"int32"),wf(e,t,n)))}function nv(e){return z(e,e)}function AD(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new W(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return B(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return B(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===e){if("channelsFirst"===n)return B(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return B(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===e){if("channelsFirst"===n)return B(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return B(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(e<3)return t;throw new W(`Unsupported input rank by biasAdd: ${t.rank}`)}function Gi(e,t,n){return V(()=>(null==n&&(n="channelsLast"),bn(n),J(e,AD(e.rank,t,n))))}function Z6(e,t,n,r){return V(()=>KT(e,t,n,r))}function rv(e,t,n=!1){return n?e():t()}var hNe=["fanIn","fanOut","fanAvg"],pNe=["normal","uniform","truncatedNormal"],vi=class extends ae.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},MD=class extends vi{apply(e,t){return mn(e,t)}};MD.className="Zeros",ae.registerClass(MD);var RD=(()=>{let e=class extends vi{apply(t,n){return aa(t,n)}};return e.className="Ones",e})();ae.registerClass(RD);var Y6=(()=>{let e=class extends vi{constructor(t){if(super(),"object"!=typeof t)throw new W(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new W(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return V(()=>z(ke(this.value),aa(t,n)))}getConfig(){return{value:this.value}}};return e.className="Constant",e})();ae.registerClass(Y6);var Q6=(()=>{let e=class extends vi{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return il(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};return e.className="RandomUniform",e})();ae.registerClass(Q6);var J6=(()=>{let e=class extends vi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new nt(`randomNormal does not support dType ${n}.`);return dI(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};return e.className="RandomNormal",e})();ae.registerClass(J6);var e5=(()=>{let e=class extends vi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new nt(`truncatedNormal does not support dType ${n}.`);return J0(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};return e.className="TruncatedNormal",e})();ae.registerClass(e5);var t5=(()=>{let e=class extends vi{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,n){return V(()=>{if(2!==t.length||t[0]!==t[1])throw new W("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,F0(t[0]))})}getConfig(){return{gain:this.gain}}};return e.className="Identity",e})();ae.registerClass(t5);var Ta=(()=>{let e=class extends vi{constructor(t){if(super(),t.scale<0)throw new W(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,function fNe(e){dd(hNe,"FanMode",e)}(this.mode),this.distribution=null==t.distribution?"normal":t.distribution,function mNe(e){dd(pNe,"Distribution",e)}(this.distribution),this.seed=t.seed}apply(t,n){let r=function gNe(e,t="channelsLast"){let n,r;if(bn(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let a=dl(e,2);n=e[1]*a,r=e[0]*a}else if("channelsLast"===t){let a=dl(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=dl(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}(t),a=r[0],i=r[1],s=this.scale;if(s/="fanIn"===this.mode?Math.max(1,a):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(a+i)/2),"normal"===this.distribution){let o=Math.sqrt(s);if("float32"!==(n=n||"float32")&&"int32"!==n)throw new nt(`${this.getClassName()} does not support dType ${n}.`);return J0(t,0,o,n,this.seed)}{let o=Math.sqrt(3*s);return il(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};return e.className="VarianceScaling",e})();ae.registerClass(Ta);var FD=(()=>{let e=class extends Ta{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="GlorotUniform",e})();ae.registerClass(FD);var OD=(()=>{let e=class extends Ta{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="GlorotNormal",e})();ae.registerClass(OD);var $D=(()=>{let e=class extends Ta{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="HeNormal",e})();ae.registerClass($D);var PD=(()=>{let e=class extends Ta{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="HeUniform",e})();ae.registerClass(PD);var LD=(()=>{let e=class extends Ta{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="LeCunNormal",e})();ae.registerClass(LD);var zD=(()=>{let e=class extends Ta{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Ta.className}};return e.className="LeCunUniform",e})();ae.registerClass(zD);var n5=(()=>{let e=class extends vi{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return V(()=>{if(t.length<2)throw new nt("Shape must be at least 2D.");if("int32"!==n&&"float32"!==n&&void 0!==n)throw new TypeError(`Unsupported data type ${n}.`);let r=I.sizeFromShape(t.slice(0,-1)),a=t[t.length-1],i=r*a;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let o=dI([Math.max(a,r),Math.min(a,r)],0,1,n,this.seed),l=nD.qr(o,!1),u=l[0],c=l[1].flatten().stridedSlice([0],[Math.min(a,r)*Math.min(a,r)],[Math.min(a,r)+1]);return u=z(u,c.sign()),r<a&&(u=u.transpose()),z(ke(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}};return e.className="Orthogonal",e})();ae.registerClass(n5);var r5={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function a5(e,t={}){return Jy(e,ae.SerializationMap.getMap().classNameMap,t,"initializer")}function gn(e){return _D(e)}function on(e){if("string"==typeof e){let t=e in r5?r5[e]:e;if("GlorotNormal"===t)return new OD;if("GlorotUniform"===t)return new FD;if("HeNormal"===t)return new $D;if("HeUniform"===t)return new PD;if("LeCunNormal"===t)return new LD;if("LeCunUniform"===t)return new zD;{let n={};return n.className=t,n.config={},a5(n)}}return e instanceof vi?e:a5(e)}function BD(e){return Array.isArray(e)&&Array.isArray(e[0])}function hI(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Pe(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new W(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function bt(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new W(`Expected exactly 1 Shape; got ${e.length}`)}return e}function pI(e){let t=0;for(let n of e)t+=0===n.shape.length?1:n.shape.reduce((r,a)=>r*a);return t}var i5="Variable",s5=class{constructor(e,t="float32",n=i5,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=U6(),this.originalName=H6(n=n??i5),this.name=G6(this.originalName),this.trainable_=r,this.constraint=a,this.val=jT(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function yNe(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function VD(e){return e.map(t=>t.read())}function UD(e){e.forEach(t=>{t[0].write(t[1])})}var Dn=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,this.ndim=null!=e.shape?e.shape.length:e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},qi=class{constructor(e,t,n,r,a,i,s){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=s,this.id=U6(),null!=i&&(this.originalName=H6(i),this.name=G6(this.originalName)),this.rank=t.length}},vNe=0,fI=class{constructor(e,t){this.callArgs=t,this.id=vNe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)e.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},bNe=0,it=class extends ae.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=bNe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=uo(n)+"_"+uI(n)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let n;if(null!=e.batchInputShape)n=e.batchInputShape;else if(null!=e.inputShape){let a=null;null!=e.batchSize&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;null==r&&(r=e.inputDType),null==r&&(r="float32"),this.dtype=r}this.initialWeights=null!=e.weights?e.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Cs(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new W(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return sa(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return sa(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ul(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ul(`Layer ${this.name} is not connected, no input to return.`);return sa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ul(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ul(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return sa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Ft(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=Ft(this.inputSpec);if(t.length!==n.length)throw new W(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let a=t[r],i=n[r];if(null==i)continue;let s=a.rank;if(null!=i.ndim&&s!==i.ndim)throw new W(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${s}`);if(null!=i.maxNDim&&s>i.maxNDim)throw new W(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${s}`);if(null!=i.minNDim&&s<i.minNDim)throw new W(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${s}.`);if(null!=i.dtype&&a.dtype!==i.dtype)throw new W(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){let o=a.shape;for(let l in i.axes){let u=Number(l),c=i.axes[l];if(null!=c&&-1===[c,null].indexOf(u>=0?o[u]:o[o.length+u]))throw new W(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(null!=i.shape)for(let o=0;o<i.shape.length;++o){let l=i.shape[o],u=a.shape[o];if(null!=l&&null!=u&&l!==u)throw new W(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Ft(e),r=function INe(e){let t=!0;for(let n of Ft(e))if(!(n instanceof qi)){t=!1;break}return t}(e),a=function SNe(e){let t=!0;for(let n of Ft(e))if(n instanceof qi){t=!1;break}return t}(e);if(r===a)throw new W("Arguments to apply() must be all SymbolicTensors or all Tensors");return hd(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let i=[];for(let s of Ft(e))i.push(s.shape);this.build(sa(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,i);let s=Ft(i),o=[];for(let l of s)-1!==n.indexOf(l)&&(l=l.clone()),o.push(l);if(i=sa(o),null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{let o,i=function wNe(e){e=Ft(e);let t=[];for(let n of e)t.push(n.shape);return sa(t)}(e),s=this.computeOutputShape(i),l="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),o=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((u,c)=>new qi(l,u,this,Ft(e),t,this.name,c)):new qi(l,s,this,Ft(e),t,this.name),this.addInboundNode(e,o,null,null,i,s,t),this._refCount++,null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ul(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new ul(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Cs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return pI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return VD(e?this.trainableWeights:this.weights)}setWeights(e){V(()=>{let t=this.weights;if(t.length!==e.length)throw new W(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=VD(t);for(let a=0;a<r.length;++a){let i=r[a],s=t[a],o=e[a];if(!I.arraysEqual(i.shape,o.shape))throw new W(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([s,o])}UD(n)})}addWeight(e,t,n,r,a,i,s,o){if(-1!==this._addedWeightNames.indexOf(e))throw new W(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():on("zeros"));let l=r.apply(t,n),u=new s5(l,n,e,i,s);return l.dispose(),null!=a&&this.addLoss(()=>a.apply(u.read())),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Ft(e),null!=this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(n=>{if(null!=n)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=Ft(t),i=Ft(r);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let s=0;s<a.length;s++)a[s].kerasMask=i[s]}addInboundNode(e,t,n,r,a,i,s=null){let o=Ft(e);t=Ft(t),n=Ft(n),r=Ft(r),a=hI(a),i=hI(i);let l=[],u=[],c=[];for(let h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new fI({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:i},s);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function o5(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let r=t.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;{let a=[];for(let i=0;i<r.inboundLayers.length;i++){let u=o5(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(let c of u)-1===a.indexOf(c)&&a.push(c)}return a}}}var av=(()=>{let e=class extends it{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:uI("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new W("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(null==n){if(null==t.inputShape)throw new W("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new W("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];let a=new qi(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new fI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new W(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};return e.className="InputLayer",e})();function l5(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new W("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new av({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}ae.registerClass(av);var Mf=class pQ{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof pQ)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(null==t)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(null!=this.id2Value[t.id])throw new W(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function _Ne(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return de(t,e.dtype)}catch{throw new W(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(t,n),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof qi){if(null==this.id2Value[t.id])throw new W(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{let n=this.name2Id[t];if(null==n)throw new W(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof qi){if(null==this.id2Value[t.id])throw new W(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{let n=this.name2Id[t];if(null==n)throw new W(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){null!=this.id2Mask&&He(this.id2Mask)}},mI=new L6,gI=new L6;function iv(e,t,n,r){let a=null!=n&&n.training,i=Array.isArray(e),s=i?e:[e],o=s.map(f=>f.name),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let d,c=o.join(",")+"|"+t.names().sort().join(","),h=mI.get(c);if(null==h){let f=function ENe(e,t){I.assert(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){let a=u5(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let i of e){let{sorted:s,recipientMap:o}=u5(i,t);for(let l of s)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)null==r[l]&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:kNe(r)}}(s,t);h=f.sorted,d=f.recipientCounts,mI.put(c,h),gI.put(c,d)}d={},a||Object.assign(d,gI.get(c));let p=new Mf(t);for(let f=0;f<h.length;++f){if(null!=r){let A=_0().numTensors;A>r.maxNumTensors&&(r.maxNumTensors=A),A<r.minNumTensors&&(r.minNumTensors=A)}let m=h[f],g=m.sourceLayer;if(g instanceof av)continue;let y=[],v=[],b=[],w=!1;for(let A of m.inputs){let R=p.getValue(A),M=p.getMask(A);y.push(R),v.push(M),null!=M&&(w=!0),a||(d[A.name]--,0===d[A.name]&&!t.hasKey(A)&&-1===o.indexOf(A.name)&&!R.isDisposed&&!0!==A.sourceLayer.stateful&&b.push(R))}w&&((n=n||{}).mask=v[0]);let x=Ft(g.apply(y,n)),C=null;g.supportsMasking&&(C=g.computeMask(y,v));let k=NNe(m),T=Array.isArray(k)?k:[k];for(let A=0;A<T.length;++A){p.hasKey(T[A])||p.add(T[A],x[A],Array.isArray(C)?C[0]:C);let R=o.indexOf(T[A].name);-1!==R&&(l[R]=x[A])}a||He(b)}return p.disposeMasks(),i?l:l[0]}function kNe(e){let t={};for(let n in e)t[n]=e[n].size;return t}function u5(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let i=[],s=[];for(i.push(e);i.length>0;){let o=i[i.length-1];if(n.has(o.name)){i.pop();continue}let l=s[s.length-1]===i.length-1;if(0===o.inputs.length||l)i.pop(),r.push(o),n.add(o.name),l&&s.pop();else{s.push(i.length-1);for(let u of o.inputs)null==a[u.name]&&(a[u.name]=new Set),a[u.name].add(o.name),!n.has(u.name)&&i.push(u)}}return{sorted:r,recipientMap:a}}function NNe(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}H().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function CNe(e){mI?.setMaxEntries(e),gI?.setMaxEntries(e)});var c5={};function WD(e,t){return V(()=>dr(xe(z(e,e),t,!0)))}je(c5,{maxNorm:()=>DNe,minMaxNorm:()=>RNe,nonNeg:()=>MNe,unitNorm:()=>ANe});var sv=class extends ae.Serializable{getConfig(){return{}}},jD=class extends sv{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return V(()=>{let t=WD(e,this.axis),n=Sr(t,0,this.maxValue);return z(e,ve(n,J(Un(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};jD.className="MaxNorm",ae.registerClass(jD);var d5=(()=>{let e=class extends sv{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return V(()=>ve(t,J(Un(),WD(t,this.axis))))}getConfig(){return{axis:this.axis}}};return e.className="UnitNorm",e})();ae.registerClass(d5);var h5=(()=>{let e=class extends sv{apply(t){return Rt(t)}};return e.className="NonNeg",e})();ae.registerClass(h5);var p5=(()=>{let e=class extends sv{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return V(()=>{let n=WD(t,this.axis),r=J(z(this.rate,Sr(n,this.minValue,this.maxValue)),z(1-this.rate,n));return z(t,ve(r,J(Un(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};return e.className="MinMaxNorm",e})();ae.registerClass(p5);var f5={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Wn(e){return _D(e)}function m5(e,t={}){return Jy(e,ae.SerializationMap.getMap().classNameMap,t,"constraint")}function jn(e){return null==e?null:"string"==typeof e?m5({className:e in f5?f5[e]:e,config:{}}):e instanceof sv?e:m5(e)}function DNe(e){return new jD(e)}function ANe(e){return new d5(e)}function MNe(){return new h5}function RNe(e){return new p5(e)}var g5={};function FNe(){return new MD}function ONe(){return new RD}function $Ne(e){return new Y6(e)}function PNe(e){return new Q6(e)}function LNe(e){return new J6(e)}function zNe(e){return new e5(e)}function BNe(e){return new t5(e)}function VNe(e){return new Ta(e)}function UNe(e){return new FD(e)}function WNe(e){return new OD(e)}function jNe(e){return new $D(e)}function HNe(e){return new PD(e)}function GNe(e){return new LD(e)}function qNe(e){return new zD(e)}function KNe(e){return new n5(e)}je(g5,{constant:()=>$Ne,glorotNormal:()=>WNe,glorotUniform:()=>UNe,heNormal:()=>jNe,heUniform:()=>HNe,identity:()=>BNe,leCunNormal:()=>GNe,leCunUniform:()=>qNe,ones:()=>ONe,orthogonal:()=>KNe,randomNormal:()=>LNe,randomUniform:()=>PNe,truncatedNormal:()=>zNe,varianceScaling:()=>VNe,zeros:()=>FNe});var b5,y5={};function pl(e){return HD.apply(this,arguments)}function HD(){return HD=F(function*(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let i=e[a];if("number"!=typeof i){let s=i;t.push(s.data()),n.push(a),r.push(s)}}if(t.length>0){let a=yield Promise.all(t);for(let i=0;i<a.length;++i)e[n[i]]=a[i][0];He(r)}}),HD.apply(this,arguments)}function v5(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}je(y5,{Layer:()=>it,RNN:()=>gl,RNNCell:()=>dv,activation:()=>BDe,add:()=>XDe,alphaDropout:()=>MAe,average:()=>ZDe,averagePooling1d:()=>DA,averagePooling2d:()=>AA,averagePooling3d:()=>MA,avgPool1d:()=>iAe,avgPool2d:()=>oAe,avgPool3d:()=>uAe,avgPooling1d:()=>sAe,avgPooling2d:()=>lAe,avgPooling3d:()=>cAe,batchNormalization:()=>nAe,bidirectional:()=>_Ae,categoryEncoding:()=>PAe,centerCrop:()=>OAe,concatenate:()=>YDe,conv1d:()=>ADe,conv2d:()=>MDe,conv2dTranspose:()=>RDe,conv3d:()=>FDe,conv3dTranspose:()=>ODe,convLstm2d:()=>wAe,convLstm2dCell:()=>xAe,cropping2D:()=>PDe,dense:()=>VDe,depthwiseConv2d:()=>zDe,dot:()=>tAe,dropout:()=>UDe,elu:()=>CDe,embedding:()=>KDe,flatten:()=>jDe,gaussianDropout:()=>AAe,gaussianNoise:()=>DAe,globalAveragePooling1d:()=>dAe,globalAveragePooling2d:()=>hAe,globalMaxPool1d:()=>EAe,globalMaxPool2d:()=>kAe,globalMaxPooling1d:()=>eq,globalMaxPooling2d:()=>tq,gru:()=>fAe,gruCell:()=>mAe,input:()=>U5,inputLayer:()=>_De,layerNormalization:()=>rAe,leakyReLU:()=>kDe,lstm:()=>gAe,lstmCell:()=>yAe,masking:()=>RAe,maxPool1d:()=>NAe,maxPool2d:()=>TAe,maxPooling1d:()=>nq,maxPooling2d:()=>rq,maxPooling3d:()=>pAe,maximum:()=>QDe,minimum:()=>JDe,multiply:()=>eAe,permute:()=>qDe,prelu:()=>NDe,randomWidth:()=>LAe,reLU:()=>EDe,repeatVector:()=>HDe,rescaling:()=>FAe,reshape:()=>GDe,resizing:()=>$Ae,rnn:()=>IAe,separableConv2d:()=>$De,simpleRNN:()=>vAe,simpleRNNCell:()=>bAe,softmax:()=>TDe,spatialDropout1d:()=>WDe,stackedRNNCells:()=>SAe,thresholdedReLU:()=>DDe,timeDistributed:()=>CAe,upSampling2d:()=>LDe,zeroPadding2d:()=>aAe}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(b5||(b5={}));var Rf=class{constructor(){this.validationData=null}setParams(e){this.params=e}onEpochBegin(e,t){return F(function*(){})()}onEpochEnd(e,t){return F(function*(){})()}onBatchBegin(e,t){return F(function*(){})()}onBatchEnd(e,t){return F(function*(){})()}onTrainBegin(e){return F(function*(){})()}onTrainEnd(e){return F(function*(){})()}setModel(e){}},w5=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}onEpochBegin(e,t){var n=this;return F(function*(){null==t&&(t={});for(let r of n.callbacks)yield r.onEpochBegin(e,t)})()}onEpochEnd(e,t){var n=this;return F(function*(){null==t&&(t={});for(let r of n.callbacks)yield r.onEpochEnd(e,t)})()}onBatchBegin(e,t){var n=this;return F(function*(){null==t&&(t={});for(let r of n.callbacks)yield r.onBatchBegin(e,t)})()}onBatchEnd(e,t){var n=this;return F(function*(){null==t&&(t={});for(let r of n.callbacks)yield r.onBatchEnd(e,t)})()}onTrainBegin(e){var t=this;return F(function*(){null==e&&(e={});for(let n of t.callbacks)yield n.onTrainBegin(e)})()}onTrainEnd(e){var t=this;return F(function*(){null==e&&(e={});for(let n of t.callbacks)yield n.onTrainEnd(e)})()}},ZNe=class extends Rf{constructor(){super()}onEpochBegin(e){var t=this;return F(function*(){t.seen=0,t.totals={}})()}onBatchEnd(e,t){var n=this;return F(function*(){null==t&&(t={});let r=null==t.size?0:t.size;n.seen+=r;for(let a in t){let i=t[a];if("number"==typeof i)n.totals.hasOwnProperty(a)||(n.totals[a]=0),n.totals[a]=n.totals[a]+i*r;else{let s;a in n.totals?s=n.totals[a]:n.totals[a]=0;let o=V(()=>J(n.totals[a],z(i,r)));n.totals[a]=o,s?.dispose()}}})()}onEpochEnd(e,t){var n=this;return F(function*(){if(null!=t)for(let r of n.params.metrics)null!=n.totals[r]&&("number"==typeof n.totals[r]?t[r]=n.totals[r]/n.seen:V(()=>{let a=z(ve(1,n.seen),n.totals[r]);t[r]=a,n.totals[r].dispose(),Bn(t[r])}))})()}},x5=class extends Rf{onTrainBegin(e){var t=this;return F(function*(){t.epoch=[],t.history={}})()}onEpochEnd(e,t){var n=this;return F(function*(){null==t&&(t={}),n.epoch.push(e);for(let r in t)null==n.history[r]&&(n.history[r]=[]),n.history[r].push(t[r])})()}syncData(){var e=this;return F(function*(){let t=[],n=[],r=[];for(let i in e.history){let s=e.history[i];for(let o=0;o<s.length;++o)"number"!=typeof s[o]&&(t.push(s[o].data()),n.push(i),r.push(o))}let a=yield Promise.all(t);for(let i=0;i<a.length;++i)e.history[n[i]][r[i]].dispose(),e.history[n[i]][r[i]]=a[i][0]})()}},I5=class extends Rf{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||xD,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");I.isNumber(this.yieldEvery)&&(this.maybeWait=function Xke(e,t,n){let a,r=null!=n?n():I.now();return(...i)=>{let s=null!=n?n():I.now();return s-r<t||(r=s,a=e(...i)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}maybeWait(e,t,n){var r=this;return F(function*(){let a=[];null!=r.yield&&(yield pl(n),a.push(r.yield(e,t,n))),a.push(r.nextFrameFunc()),yield Promise.all(a)})()}onEpochBegin(e,t){var n=this;return F(function*(){n.currentEpoch=e,null!=n.epochBegin&&(yield pl(t),yield n.epochBegin(e,t))})()}onEpochEnd(e,t){var n=this;return F(function*(){let r=[];null!=n.epochEnd&&(yield pl(t),r.push(n.epochEnd(e,t))),"epoch"===n.yieldEvery&&r.push(n.nextFrameFunc()),yield Promise.all(r)})()}onBatchBegin(e,t){var n=this;return F(function*(){null!=n.batchBegin&&(yield pl(t),yield n.batchBegin(e,t))})()}onBatchEnd(e,t){var n=this;return F(function*(){let r=[];null!=n.batchEnd&&(yield pl(t),r.push(n.batchEnd(e,t))),"batch"===n.yieldEvery?r.push(n.nextFrameFunc()):I.isNumber(n.yieldEvery)&&r.push(n.maybeWait(n.currentEpoch,e,t)),yield Promise.all(r)})()}onTrainBegin(e){var t=this;return F(function*(){null!=t.trainBegin&&(yield pl(e),yield t.trainBegin(e))})()}onTrainEnd(e){var t=this;return F(function*(){null!=t.trainEnd&&(yield pl(e),yield t.trainEnd(e))})()}};function S5(e,t){return null==e&&(e={}),e instanceof Rf?[e]:Array.isArray(e)&&e[0]instanceof Rf?e:Ft(e).map(n=>new I5(n,t))}var _5=(()=>{let e=class Os{constructor(){}static registerCallbackConstructor(n,r){I.assert(n>=0&&Number.isInteger(n),()=>`Verbosity level is expected to be an integer >= 0, but got ${n}`),Os.checkForDuplicate(r),null==Os.constructors[n]&&(Os.constructors[n]=[]),Os.constructors[n].push(r)}static checkForDuplicate(n){for(let r in Os.constructors)Os.constructors[+r].forEach(a=>{if(a===n)throw new W("Duplicate callback constructor.")})}static clear(){Os.constructors={}}static createCallbacks(n){let r=[];for(let a in Os.constructors){let i=+a;n>=i&&r.push(...Os.constructors[i])}return r.map(a=>new a)}};return e.constructors={},e})();function C5(e,t,n,r,a,i,s,o,l){let u=new x5,c=[new ZNe,..._5.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);let h=new w5(c);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:i,batchSize:s,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function Ki(e,t={},n=!1){return Jy(e,ae.SerializationMap.getMap().classNameMap,t,"layer",n)}function yI(e,t){return V(()=>{"float32"!==e.dtype&&(e=de(e,"float32"));let n=xe(nv(e),t,!0),r=_a(n.shape,Un()),a=dr(xs(n,r));return ve(e,a)})}function fd(e,t){return V(()=>fn(nv(ye(t,e)),-1))}function vI(e,t){return V(()=>fn(kn(ye(t,e)),-1))}function Ff(e,t){return V(()=>{let n=ye(e,t),r=Sr(kn(e),Un(),Number.MAX_VALUE),a=kn(ve(n,r));return z(100,fn(a,-1))})}function ov(e,t,n=!1){return V(()=>{if(n)t=sl(t);else{let r=xe(t,t.shape.length-1,!0);t=ve(t,r)}return t=Sr(t,Un(),1-Un()),Yt(xe(z(de(e,"float32"),ka(t)),t.shape.length-1))})}function bI(e,t,n=!1){return V(()=>{let r=de(bf(function oNe(e){let t=[dl(e.shape)];return B(e,t)}(e)),"int32"),a=(t=Sr(t,Un(),1-Un())).shape;return ov(B(If(r,a[a.length-1]),a),t,n)})}function wI(e,t){return V(()=>{let n;return n=Sr(t,Un(),1-Un()),n=ka(ve(n,ye(1,n))),fn(function nTe(e,t){if(!I.arraysEqual(e.shape,t.shape))throw new W(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return V(()=>{let n=Rt(t),r=Yt(kn(t));return J(ye(n,z(t,e)),Wy(_r(r)))})}(e,n),-1)})}function GD(e,t){return V(()=>{let n=yI(e,-1),r=yI(t,-1),a=z(n,r);return Yt(xe(a,-1))})}var xI={meanSquaredError:fd,meanAbsoluteError:vI,meanAbsolutePercentageError:Ff,meanSquaredLogarithmicError:function YNe(e,t){return V(()=>{let n=Sr(t,Un(),Number.MAX_VALUE),r=ka(J(1,n)),a=Sr(e,Un(),Number.MAX_VALUE),i=ka(J(1,a));return fn(nv(ye(r,i)),-1)})},squaredHinge:function QNe(e,t){return V(()=>{let n=xs(0,ye(1,z(e,t)));return fn(nv(n),-1)})},hinge:function JNe(e,t){return V(()=>{let n=xs(0,ye(1,z(e,t)));return fn(n,-1)})},categoricalHinge:function eTe(e,t){return V(()=>{let n=xe(z(e,t),-1),r=Ka(z(ye(1,e),t),-1);return xs(0,J(1,ye(r,n)))})},logcosh:function tTe(e,t){return V(()=>{let n=Math.log(2),r=ye(t,e),a=ye(J(r,rd(z(-2,r))),n);return fn(a,-1)})},categoricalCrossentropy:ov,sparseCategoricalCrossentropy:bI,binaryCrossentropy:wI,kullbackLeiblerDivergence:function rTe(e,t){return V(()=>{let n=Sr(e,Un(),1),r=Sr(t,Un(),1);return xe(z(e,ka(ve(n,r))),-1)})},poisson:function aTe(e,t){return V(()=>{let n=ka(J(Un(),t));return fn(ye(t,z(e,n)),-1)})},cosineProximity:GD};function qD(e){if("string"==typeof e){if(e in xI)return xI[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new W(t)}return e}function KD(e,t){return V(()=>{let n=z(.5,Na(t)),r=co(zr(t,n),e.dtype);return fn(Ca(e,r),-1)})}function XD(e,t){return V(()=>co(Ca(Xc(e,-1),Xc(t,-1)),"float32"))}function E5(e,t){return V(()=>de(xe(gi(Ca(e,1),Ca(t,1))),"float32"))}function k5(e,t){return V(()=>{let n=E5(e,t),r=function sTe(e,t){return V(()=>de(xe(gi(Ca(e,0),Ca(t,1))),"float32"))}(e,t),a=J(n,r);return de(tr(zr(a,0),ve(n,a),0),"float32")})}function N5(e,t){return wI(e,t)}function T5(e,t){return e.rank===t.rank&&(e=ol(e,[e.rank-1])),(t=Xc(t,-1)).dtype!==e.dtype&&(t=de(t,e.dtype)),de(Ca(e,t),"float32")}var ZD=ov,D5=bI,II={binaryAccuracy:KD,categoricalAccuracy:XD,precision:k5,categoricalCrossentropy:ZD,sparseCategoricalCrossentropy:D5,mse:fd,MSE:fd,mae:vI,MAE:vI,mape:Ff,MAPE:Ff,cosine:GD};function mTe(e){if("string"==typeof e&&e in II)return II[e];if("string"!=typeof e&&null!=e)return e;throw new W(`Unknown metric ${e}`)}function SI(e){if(Es(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(xI))if(xI[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(II))if(II[n]===e){t=n;break}return void 0!==t?t:e.name}}function A5(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!YD(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function YD(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!YD(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!YD(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function _I(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function wTe(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}_I([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function xTe(e,t,n,r){let a,i;try{i=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let s=[];for(let h of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(h)))for(let d=0;d<h.inboundLayers.length;++d)s.push(`${h.inboundLayers[d].name}[${h.nodeIndices[d]}][${h.tensorIndices[d]}]`);let o=e.name,l=e.getClassName(),u=0===s.length?"":s[0];_I([`${o} (${l})`,i,a,e.countParams().toString(),u],t,r);for(let h=1;h<s.length;++h)_I(["","","","",s[h]],t,r)}function M5(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function lv(e,t){if(null===e)return null;if("string"==typeof e)return cd(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let i=e[a];M5(t,a,i)?n.push(i):n.push(lv(i,t))}return n}{let n={};for(let r of Object.keys(e)){let a=e[r];if("name"===r&&"string"==typeof a)n[r]=a;else{let i=cd(r);n[i]=lv(a,i)}}return n}}function QD(e,t){if(null==e)return null;if("string"==typeof e)return uo(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let i=e[a];M5(t,a,i)?n.push(i):n.push(QD(i,t))}return n}{let n={};for(let r of Object.keys(e)){let a=e[r];n[uo(r)]="name"!==r&&"className"!==r||"string"!=typeof a?QD(a,r):a}return n}}var JD="4.16.0",STe=class $s extends it{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let v=this.getClassName().toLowerCase();this.name=uI(v)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],cl(this.inputs).length!==this.inputs.length)throw new W(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);cl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let v of this.outputs){let w=v.nodeIndex,x=v.tensorIndex;this.outputLayers.push(v.sourceLayer),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(x)}for(let v of this.inputs){let b=v.sourceLayer,w=v.nodeIndex,x=v.tensorIndex;Es(0===w,"input layer has >1 nodes"),Es(0===x,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){let b=this.inputLayers[v];if(!(b instanceof av))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);let n={},r={},a={},i={},s={},o=[],l=(v,b,w,x,C,k)=>{(null==x||null==C||null==k)&&(x=v.sourceLayer,C=v.nodeIndex,k=v.tensorIndex);let T=x.inboundNodes[C];if(-1!==w.indexOf(T))throw new Cs(`The tensor ${v.name} at layer "${x.name}" is part of a cycle.`);if(-1!==b.indexOf(T))return;this.containerNodes.add($s.nodeKey(x,C)),x.id in s||(s[x.id]=Object.keys(s).length),-1===w.indexOf(T)&&w.push(T);let A=T.inboundLayers.length;for(let R=0;R<A;R++)l(T.inputTensors[R],b,w,T.inboundLayers[R],T.nodeIndices[R],T.tensorIndices[R]);for(b.push(T);w.indexOf(T)>=0;)w.splice(w.indexOf(T),1);o.push(T)},u=[],c=[];for(let v of this.outputs)l(v,u,c);let h=o.slice().reverse();for(let v of h){r[v.id]=v,v.id in n||(n[v.id]=0);let b=n[v.id];b=Math.max(b,null==a[v.outboundLayer.id]?0:a[v.outboundLayer.id]),a[v.outboundLayer.id]=b,i[v.outboundLayer.id]=v.outboundLayer,n[v.id]=b;for(let x=0;x<v.inboundLayers.length;x++){let T=v.inboundLayers[x].inboundNodes[v.nodeIndices[x]];n[T.id]=Math.max(b+1,null==n[T.id]?0:n[T.id]),r[T.id]=T}}let d={};for(let v in n){let b=n[v];b in d||(d[b]=[]),d[b].push(r[v])}let p={};for(let v in a){let b=a[v];b in p||(p[b]=[]),p[b].push(i[v])}let f=Object.keys(p).map(v=>parseInt(v,10)).sort(oI);this.layers=[];for(let v of f){let b=p[v];b.sort((w,x)=>{let C=s[w.id],k=s[x.id];return C<k?-1:C>k?1:0});for(let w of b)w instanceof $s&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(d).map(v=>parseInt(v,10)).sort(oI);let m=this.inputs.slice(),g=[];for(let v of f)for(let b of d[v]){let w=b.outboundLayer;if(null!=w){for(let x of b.inputTensors)if(-1===m.indexOf(x))throw new Cs(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(let x of b.outputTensors)m.push(x);g.push(w.name)}}this.nodesByDepth=d;let y=this.layers.map(v=>v.name);for(let v of y){let b=y.filter(w=>w===v).length;if(1!==b)throw new Cs(`The name "${v}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new fI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new W("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},a=0,i=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(t);i&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let c=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(null!=r[c])throw new W(`Duplicate weight name: ${c}`);r[c]=u,a++}let s=[];for(let o in t){let l=o;if(null==r[o]){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=r[l])s.push([r[l],t[o]]);else if(n)throw new W(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new W(`${o.length} of ${a} weights are not set: ${o}`)}UD(s)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),a=["vars","layer_checkpoint_dependencies"],i=r.map(s=>s.startsWith("_")?s.slice(1):s).filter(s=>!a.includes(s)).join("/");i!==n&&(t[i]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${JD}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=QD(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return V(()=>{t=Ft(t);let r=new Mf;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return iv(this.outputs,r,n)})}computeMask(t,n){return V(()=>{let r;return t=Ft(t),r=null==n?ud(null,t.length):Ft(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=hI(t);if(n.length!==this.inputLayers.length)throw new W(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++)r[this.inputLayers[o].name+"_0_0"]=n[o];let a=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(oI);if(a.length>1)for(let o of a){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(c.id))continue;let h=[];for(let m=0;m<u.inboundLayers.length;m++)h.push(r[`${u.inboundLayers[m].name}_${u.nodeIndices[m]}_${u.tensorIndices[m]}`]);let p=hI(c.computeOutputShape(sa(h))),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++)r[`${c.name}_${f}_${m}`]=p[m]}}let i=[],s=[];for(let o=0;o<this.outputLayers.length;o++)s.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<s.length;o++){let l=s[o];Es(l in r),i.push(r[l])}return sa(i)}runInternalGraph(t,n){null==n&&(n=ud(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],n[l]];let a=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(oI);for(let l of a){let u=this.nodesByDepth[l];for(let c of u){let h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(let m of d)m.id in r&&f.push(r[m.id]);if(f.length===d.length){let g,y,v,b,m={};if(null!=c.callArgs&&(m=c.callArgs),1===f.length){let[w,x]=f[0];null==m.mask&&(m.mask=x),v=Ft(h.call(w,m)),b=Ft(h.computeMask(w,x)),g=[w],y=[x]}else g=f.map(w=>w[0]),y=f.map(w=>w[1]),null==m.mask&&(m.mask=y),v=Ft(h.call(g,m)),b=Ft(h.computeMask(g,y));if(h.activityRegularizer)throw new nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w)r[p[w].id]=[v[w],b[w]]}}}let i=[],s=[],o=[];for(let l of this.outputs){Es(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];o.push(u.shape),i.push(u),s.push(c)}return[i,s,o]}buildNodeConversionMap(t){let r,n={};for(let a of this.layers){r=a instanceof $s?1:0;for(let i=0;i<a.inboundNodes.length;i++){let s=$s.nodeKey(a,i);this.containerNodes.has(s)&&(n[s]=r,r+=1)}}return n}getLayer(t,n){if(null!=n)return this.findLayer(n);if(null==t)throw new W("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new W(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new W(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return V(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=$s.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let s of this.layers){let o=s.getClassName(),l=s.getConfig(),u=[];for(let h=0;h<s.inboundNodes.length;h++){let d=s.inboundNodes[h],p=$s.nodeKey(s,h),f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){let m=[];for(let g=0;g<d.inboundLayers.length;g++){let y=d.inboundLayers[g],b=d.tensorIndices[g],x=n[$s.nodeKey(y,d.nodeIndices[g])];null==x&&(x=0),m.push([y.name,x,b,f])}u.push(m)}}}let c={};c.name=s.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;let a=[];for(let s=0;s<this.inputLayers.length;s++){let o=this.inputLayers[s],u=$s.nodeKey(o,this.inputLayersNodeIndices[s]);if(!this.containerNodes.has(u))continue;let c=n[u];null==c&&(c=0),a.push([o.name,c,this.inputLayersTensorIndices[s]])}t.inputLayers=a;let i=[];for(let s=0;s<this.outputLayers.length;s++){let o=this.outputLayers[s],u=$s.nodeKey(o,this.outputLayersNodeIndices[s]);if(!this.containerNodes.has(u))continue;let c=n[u];null==c&&(c=0),i.push([o.name,c,this.outputLayersTensorIndices[s]])}return t.outputLayers=i,t}static fromConfig(t,n,r={},a=!1){let i={},s={};function o(g,y){g.name in s?s[g.name].push(y):s[g.name]=[y]}function l(g,y){let b,v=[];for(let w of y){let x=w[0],C=w[1],k=w[2];if(b=null==w[3]?{}:w[3],!(x in i))return void o(g,y);let T=i[x];if(T.inboundNodes.length<=C)return void o(g,y);v.push(T.inboundNodes[C].outputTensors[k])}v.length>0&&g.apply(sa(v),b)}function u(g){let y=g.name,v=Ki(g,null!=n.customObjects?n.customObjects:{});v.setFastWeightInitDuringBuild(a),i[y]=v,g.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new W(`Corrupted configuration, expected array for nodeData: ${b}`);o(v,b)})}let c=n.name,h=n.layers;for(let g of h)u(g);for(;!Kke(s);)for(let g of h){let y=i[g.name];if(y.name in s){let v=s[y.name];delete s[y.name];for(let b of v)l(y,b)}}let d=[],p=[],f=n.inputLayers;for(let g of f){let y=g[0],v=g[1],b=g[2];Es(y in i),d.push(i[y].inboundNodes[v].outputTensors[b])}let m=n.outputLayers;for(let g of m){let y=g[0],v=g[1],b=g[2];Es(y in i),p.push(i[y].inboundNodes[v].outputTensors[b])}return new t({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new W("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){V(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function R5(e,t){return function _Te(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(a=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let a=[];return t.forEach(i=>{a.push(i in e?e[i]:null)}),a}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}function F5(e,t,n,r){return eA.apply(this,arguments)}function eA(){return eA=F(function*(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let a=V(()=>{if(1===e.shape.length)return vs(e);if(2===e.shape.length){if(e.shape[1]>1)return Xc(e,1);if(1===e.shape[1])return B(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield a.data());He(a);let s=[];return i.forEach(o=>{if(null==n[o])throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);s.push(n[o])}),Tt(s,"float32")}return null}),eA.apply(this,arguments)}function CTe(e,t){return z(e,t)}function O5(e,t){let n,r;n=t.xs,r=t.ys,I.assert(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let i=$5("input",e.inputNames,n),s=$5("output",e.outputNames,r),o=i[0].shape[0];I.assert(i.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),I.assert(s.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<i.length;l++)I.assert(i[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<s.length;l++)I.assert(s[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:i,ys:s}}function $5(e,t,n){if(n instanceof Ze)return[n];if(Array.isArray(n))return I.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(null==n[a])throw new W(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function tA(){return tA=F(function*(e,t,n){let r=null!=n.batchesPerEpoch;if(I.assert(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),I.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),I.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),I.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),I.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let i,s,a=null!=n.validationData;if(a)if(P5(n.validationData))I.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=function kTe(e){if(3===e.length)throw new nt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);i=g.xs,s=g.ys}let u,o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();u=a?l.slice().concat(l.map(g=>"val_"+g)):l.slice();let c=S5(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=C5(c,h,n.epochs,null,null,function TTe(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,a,u);d.setModel(e),e.history=p,yield d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield t.iterator();for(;f<n.epochs;){let g={};yield d.onEpochBegin(f);let y=0,v=0;for(r||(m=yield t.iterator());!r||y<n.batchesPerEpoch;){let b=yield m.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=b.value){let{xs:w,ys:x}=O5(e,b.value),C={};C.batch=v,C.size=w[0].shape[0],yield d.onBatchBegin(v,C);let k=[];if(null!=n.classWeight){let R=R5(n.classWeight,e.outputNames);for(let M=0;M<R.length;++M)k.push(yield F5(x[M],null,R[M]))}let T=w.concat(x).concat(k),A=o(T);He(T);for(let R=0;R<l.length;++R){let _=A[R];C[l[R]]=_,Bn(_)}yield d.onBatchEnd(v,C),v5(C),v++,y++}if(r?y>=n.batchesPerEpoch:b.done){if(a){let w;w=P5(n.validationData)?Ft(yield e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Ft(e.evaluate(i,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let x=0;x<e.metricsNames.length;++x)g[`val_${e.metricsNames[x]}`]=w[x]}break}if(e.stopTraining_)break}if(yield d.onEpochEnd(f,g),f++,e.stopTraining_)break}return yield d.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}}),tA.apply(this,arguments)}function P5(e){return"function"==typeof e.iterator}function nA(){return nA=F(function*(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,i=[];if(n.verbose>0)throw new nt("Verbose mode is not implemented yet.");I.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let s=function DTe(e){return"function"==typeof e.next}(t)?t:yield t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=yield s.next();if(i=V(()=>{if(u.value){let{xs:c,ys:h}=O5(e,u.value),d=c.concat(h),p=V(()=>a(d));if(He(d),0===l)for(let m=0;m<p.length;++m)i.push(ke(0));let f=d[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],y=i[m];i[m]=V(()=>J(i[m],z(f,g))),l>0&&He(y)}He(p),o+=f,++l}return i}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){let c=i[u];i[u]=ve(i[u],o),He(c)}return sa(i)}),nA.apply(this,arguments)}function rA(e){I.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function uv(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(r=>pd(r,t,n-t)):pd(e,t,n-t)}function aA(e,t){return V(()=>null==e?null:Array.isArray(e)?e.map(n=>aA(n,t)):X6(e,"int32"===t.dtype?t:de(t,"int32")))}function iA(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function L5(e){let t=[];e instanceof Ze&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(tv(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Xi(e,t){if(null==e)return;let n=[];if(t instanceof Ze)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(null!=t)for(let a in t)n.push(t[a].id);let r=[];if(e instanceof Ze)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{-1===n.indexOf(a.id)&&r.push(a)});else if(null!=e)for(let a in e){let i=e[a];-1===n.indexOf(i.id)&&r.push(i)}r.forEach(a=>{a.isDisposed||a.dispose()})}function sA(e){return Array.isArray(e)}function z5(e){return!function MTe(e){return e instanceof Ze}(e)&&!sA(e)}function B5(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let s=!1;if(sA(e)&&e.length>0)s=!0;else if(z5(e)){for(let o in e)if(e.hasOwnProperty(o)){s=!0;break}}else s=!0;if(s)throw new W(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(s=>null);let i;if(z5(e)){i=[];for(let s of t){if(null==e[s])throw new W(`No data provided for "${s}". Need data for each key in: ${t}`);i.push(e[s])}}else if(sA(e)){if(e.length!==t.length)throw new W(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(t.length>1)throw new W(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=L5(i),null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;let o=i[s];if(o.shape.length!==n[s].length)throw new W(`Error when checking ${a}: expected ${t[s]} to have ${n[s].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[s].length;++l){if(0===l&&!r)continue;let c=n[s][l];if(null!=c&&c>=0&&o.shape[l]!==c)throw new W(`${a} expected a batch of elements where each example has shape [${n[s].slice(1,n[s].length)}] (i.e.,tensor shape [*,${n[s].slice(1,n[s].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function V5(e,t,n,r=!0,a=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new W(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new W(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(null!=n)for(let s=0;s<t.length;++s){if(null==n[s])continue;let o=i[s];if(o.shape.length!==n[s].length)throw new W(`Error when checking ${a}: expected ${t[s]} to have ${n[s].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[s].length;++l){if(0===l&&!r)continue;let c=n[s][l];if(null!=c&&c!==o.shape[l])throw new W(`Error when checking ${a}: expected ${t[s]} to have shape ${JSON.stringify(n[s])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}var ho=class extends STe{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new W("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function yTe(e,t,n,r=console.log){let s,a=function bTe(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let i=!1;for(let s of a.inboundNodes)if(-1!==r.indexOf(s)){if(i){t=!1;break}i=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c))),!a){i.push("Receives inputs"),s=[];for(let c in e.nodesByDepth)s.push(...e.nodesByDepth[c])}r("_".repeat(t)),_I(i,n,r),r("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)a?wTe(o[c],n,r):xTe(o[c],n,s,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function vTe(e){let t;return t=pI(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),t}(e),u=pI(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function gTe(e){let t={Adagrad:()=>ld.adagrad(.01),Adadelta:()=>ld.adadelta(1,.95,Un()),Adam:()=>ld.adam(.001,.9,.999,Un()),Adamax:()=>ld.adamax(.002,.9,.999,Un(),0),RMSProp:()=>ld.rmsprop(.001,.9,0,Un()),SGD:()=>ld.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new W(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof lo))throw new W("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new W(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>qD(i))}else{let i=qD(e.loss);this.outputs.forEach(s=>{t.push(i)})}else{e.loss=e.loss;for(let i in e.loss)if(-1===this.outputNames.indexOf(i))throw new W(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)null==e.loss[i]&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(qD(e.loss[i]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let s=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(s),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],hd("loss",()=>{for(let i=0;i<this.outputs.length;++i)-1===n.indexOf(i)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[i],i]),this.metricsNames.push(this.outputNames[i]+"_loss"))});let r=function OTe(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(r=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let i=n.hasOwnProperty(a)?n[a]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),a=(i,s,o)=>{this.outputNames.length>1&&(s=this.outputNames[i]+"_"+s),this.metricsNames.push(s),this.metricsTensors.push([o,i])};hd("metric",()=>{for(let i=0;i<this.outputs.length;++i)-1===n.indexOf(i)&&(o=>{let u,c,h;for(let d of o){if("string"==typeof d&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(d)){let m,f=this.internalOutputShapes[i];1===f[f.length-1]||this.lossFunctions[i]===wI?-1!==["accuracy","acc"].indexOf(d)?c=KD:-1!==["crossentropy","ce"].indexOf(d)&&(c=N5):this.lossFunctions[i]===bI?-1!==["accuracy","acc"].indexOf(d)?c=T5:-1!==["crossentropy","ce"].indexOf(d)&&(c=D5):-1!==["accuracy","acc"].indexOf(d)?c=XD:-1!==["crossentropy","ce"].indexOf(d)&&(c=ZD),-1!==["accuracy","acc"].indexOf(d)?m="acc":-1!==["crossentropy","ce"].indexOf(d)&&(m="ce"),h=c,u=""+m}else h=mTe(d),u=""+SI(d);let p;hd(u,()=>{p=h}),a(i,u,p)}})(r[i])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;rA(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let i=a[0].concat(a[1]);return this.makeTestFunction(),sa(this.testLoop(this.testFunction,i,r,n.verbose,n.steps))}finally{Xi(a[0],e),Xi(a[1],t)}}evaluateDataset(e,t){var n=this;return F(function*(){return n.makeTestFunction(),function ATe(e,t,n){return nA.apply(this,arguments)}(n,e,t)})()}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new W(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new W(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new W("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=this.retrieveSymbolicTensors(n?t:[t]),i=new Mf;if(e instanceof Ze&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new W(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)i.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(null==l)throw new W(`No value is provided for the model's input ${o.name}`);i.add(o,l)}let s=iv(a,i);return n?s:s[0]}retrieveSymbolicTensors(e){let t=ud(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],i=a.map(s=>s.name);for(let s=0;s<e.length;++s){let o=i.indexOf(e[s]);if(-1!==o&&(t[s]=a[o],n--),0===n)break}if(0===n)break}if(n>0){let r=[];throw t.forEach((a,i)=>{null==a&&r.push(e[i])}),new W(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return V(()=>{let r=this.checkNumSamples(e);if(n)throw new nt("Verbose predictLoop() is not implemented yet.");let a=iA(r,t),i=this.outputs.map(s=>[]);for(let s=0;s<a.length;++s)V(()=>{let u=uv(e,a[s][0],a[s][1]),c=[];if(Array.isArray(u))for(let d=0;d<u.length;++d)c.push({key:this.inputs[d],value:u[d]});else c.push({key:this.inputs[0],value:u});let h=new Mf(c);return iv(this.outputs,h)}).forEach((o,l)=>i[l].push(o));return sa(i.map(s=>zt(s,0)))})}predict(e,t={}){let n=L5(e);V5(n,this.inputNames,this.feedInputShapes,!1);try{let r=null==t.batchSize?32:t.batchSize;return rA(r),this.predictLoop(n,r)}finally{Xi(n,e)}}predictOnBatch(e){V5(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new Cs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let i=0;i<this.feedOutputShapes.length;++i){let s=this.feedOutputShapes[i];a.push(this.feedLossFns[i]===bI?s.slice(0,s.length-1).concat([1]):s)}if(function RTe(e,t,n){let r=cl(e.map(i=>i.shape[0]));r.sort();let a=cl(t.map(i=>i.shape[0]));if(a.sort(),r.length>1)throw new W(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(a.length>1)throw new W(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&a.length>0&&!I.arraysEqual(r,a))throw new W(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}(e=B5(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=B5(t,this.feedOutputNames,a,!1,"target")),function FTe(e,t,n){let r=[fd,wI,ov];for(let a=0;a<e.length;++a){let i=e[a],s=t[a],o=n[a];if(null!=s){if(s===ov&&1===i.shape[i.shape.length-1])throw new W(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(s)){let l=i.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let d=u[c];if(null!=d&&l[c]!==d)throw new W(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new W(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}standardizeUserData(e,t,n,r,a=!0,i){var s=this;return F(function*(){let[o,l]=s.standardizeUserDataXY(e,t,a,i);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){let c=R5(r,s.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(yield F5(l[h],null,c[h]))}return[o,l,u]})()}testLoop(e,t,n,r=0,a){return V(()=>{let i=this.checkNumSamples(t,n,a,"steps"),s=[];if(r>0)throw new nt("Verbose mode is not implemented yet.");if(null!=a)throw new nt("steps mode in testLoop() is not implemented yet");{let o=iA(i,n),l=Tt(ji(0,i));for(let u=0;u<o.length;++u){let c=o[u][0],h=o[u][1],d=pd(l,c,h-c),p=aA(t,d),f=e(p);if(0===u)for(let m=0;m<f.length;++m)s.push(ke(0));for(let m=0;m<f.length;++m)s[m]=J(s[m],z(h-c,f[m]))}for(let u=0;u<s.length;++u)s[u]=ve(s[u],i)}return s})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;z6(e,r)>1&&(a+=`_${z6(e.slice(0,n),r)}`),t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(()=>{let l=[];for(let d=0;d<this.inputs.length;++d)l.push({key:this.inputs[d],value:n[d]});let h,u=new Mf(l),c=iv(this.outputs,u,{training:!0});for(let d=0;d<this.lossFunctions.length;++d){let f=(0,this.lossFunctions[d])(r[d],c[d]);null!=a[d]&&(f=CTe(f,a[d]));let m=fn(f);t.push(m),h=0===d?f:J(h,f)}for(let d=0;d<this.metricsTensors.length;++d){let p;if(this.outputs.length>1&&d<this.outputs.length)p=t[d];else{let m=this.metricsTensors[d][1];p=fn((0,this.metricsTensors[d][0])(r[m],c[m]))}Bn(p),i.push(p)}return h=fn(h),this.calculateLosses().forEach(d=>{h=J(h,d)}),h},!0,o)].concat(i)}}makeTestFunction(){this.testFunction=e=>V(()=>{let n,t=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:r[l]});let s=new Mf(i),o=iv(this.outputs,s);for(let l=0;l<this.lossFunctions.length;++l){let c=fn((0,this.lossFunctions[l])(a[l],o[l]));n=0===l?c:J(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][1],h=fn((0,this.metricsTensors[l][0])(a[c],o[c]));t.push(h)}return t})}fit(e,t,n={}){var r=this;return F(function*(){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let a,i,s,o,l,u,c,h,d;r.isTraining=!0;try{let p=null==n.batchSize?32:n.batchSize;rA(p);let f=yield r.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,p);a=f[0],i=f[1],d=f[2];let g,m=!1;if(null!=n.validationData&&n.validationData.length>0){if(m=!0,2!==n.validationData.length)throw 3===n.validationData.length?new nt("validationData including sample weights is not supported yet."):new W(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);l=n.validationData[0],u=n.validationData[1];let k=yield r.standardizeUserData(l,u,null,null,!0,p);c=k[0],h=k[1],g=c.concat(h)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){m=!0;let k=Math.floor(a[0].shape[0]*(1-n.validationSplit)),T=a[0].shape[0];c=uv(a,k,T),s=a,a=uv(a,0,k),h=uv(i,k,T),o=i,i=uv(i,0,k),g=c.concat(h)}else null!=n.validationSteps&&(m=!0);let y=a.concat(i).concat(d);r.checkTrainableWeightsConsistency();let w,x,v=r.makeTrainFunction(),b=r.getDedupedMetricsNames();m?(r.makeTestFunction(),w=r.testFunction,x=b.slice().concat(b.map(k=>"val_"+k))):(w=null,g=[],x=b.slice());let C=S5(n.callbacks,n.yieldEvery);return yield r.fitLoop(v,y,b,p,n.epochs,n.verbose,C,w,g,n.shuffle,x,n.initialEpoch,null,null)}finally{r.isTraining=!1,Xi(a,e),Xi(i,t),Xi(s,e),Xi(o,t),Xi(c,l),Xi(h,u),null!=d&&He(d)}})()}fitLoop(e,t,n,r,a,i,s,o,l,u,c,h,d,p){var f=this;return F(function*(){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==h&&(h=0);let m=!1;if(null!=o&&null!=l&&(m=!0),null!=p&&(m=!0,null==d))throw new W("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y,g=f.checkNumSamples(t,r,d,"steps_per_epoch");null!=g&&(y=ji(0,g)),null==i&&(i=1);let{callbackList:v,history:b}=C5(s,i,a,h,g,d,r,m,c);v.setModel(f),f.history=b,yield v.onTrainBegin(),f.stopTraining_=!1;for(let w=h;w<a;++w){yield v.onEpochBegin(w);let x={};if(null!=d)throw new nt("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new nt("batch shuffling is not implemneted yet");u&&I.shuffle(y);let C=Tt(y),k=iA(g,r);for(let T=0;T<k.length;++T){let A={};if(yield v.onBatchBegin(T,A),V(()=>{let R=k[T][0],M=k[T][1],_=pd(C,R,M-R);A.batch=T,A.size=M-R;let $=aA(t,_),U=e($);for(let j=0;j<n.length;++j){let K=U[j];A[n[j]]=K,Bn(K)}if(T===k.length-1&&m){let j=f.testLoop(o,l,r);for(let G=0;G<n.length;++G){let K=n[G],X=j[G];Bn(X),x["val_"+K]=X}}}),yield v.onBatchEnd(T,A),v5(A),f.stopTraining_)break}C.dispose()}if(yield v.onEpochEnd(w,x),f.stopTraining_)break}return yield v.onTrainEnd(),yield f.history.syncData(),f.history})()}fitDataset(e,t){var n=this;return F(function*(){return function NTe(e,t,n){return tA.apply(this,arguments)}(n,e,t)})()}trainOnBatch(e,t){var n=this;return F(function*(){let r=yield n.standardizeUserData(e,t),a=r[0],i=r[1],s=n.makeTrainFunction()(a.concat(i)),o=[];for(let l of s){let u=yield l.data();o.push(u[0])}return He(s),Xi(r[0],e),Xi(r[1],t),sa(o)})()}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||t.push({name:r[i].originalName,tensor:a[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=_0().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-_0().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=uo(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>uo(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=uo(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[uo(SI(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>uo(SI(e)));{let e={};for(let t in this.metrics)e[t]=uo(SI(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let r,a,n=Ki(lv(e.optimizer_config));if("string"==typeof e.loss)r=cd(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>cd(i));else if(null!=e.loss){r={};for(let i in e.loss)r[i]=cd(e.loss[i])}if(Array.isArray(e.metrics))a=e.metrics.map(i=>cd(i));else if(null!=e.metrics){a={};for(let i in e.metrics)a[i]=cd(e.metrics[i])}this.compile({loss:r,metrics:a,optimizer:n})}save(e,t){var n=this;return F(function*(){if("string"==typeof e){let i=hr.getSaveHandlers(e);if(0===i.length)throw new W(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new W(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(null==e.save)throw new W("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let r=yield hr.encodeWeights(n.getNamedWeights(t)),a={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${JD}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=n.optimizer){a.trainingConfig=n.getTrainingConfig();let i="optimizer",{data:s,specs:o}=yield hr.encodeWeights(yield n.optimizer.getWeights(),i);r.specs.push(...o),r.data=hr.concatenateArrayBuffers([r.data,s])}return null!=n.userDefinedMetadata&&(A5(n.userDefinedMetadata,n.name,!0),a.userDefinedMetadata=n.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)})()}setUserDefinedMetadata(e){A5(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};ho.className="Model",ae.registerClass(ho);var PTe=(()=>{let e=class extends ho{};return e.className="Functional",e})();function LTe(e,t){return oA.apply(this,arguments)}function oA(){return oA=F(function*(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let a=Ki(lv(n),t);if(null!=e.weightsManifest){let i=yield hr.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),s={};for(let o of a.weights)s[o.originalName]=i[o.originalName];a.loadWeights(s),He(i)}return a}),oA.apply(this,arguments)}function zTe(e,t){return lA.apply(this,arguments)}function lA(){return lA=F(function*(e,t){if(null==t&&(t={}),"string"==typeof e){let n=hr.getLoadHandlers(e,t);if(0===n.length)n.push(hr.browserHTTPRequest(e,t));else if(n.length>1)throw new W(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return function BTe(e,t,n){return uA.apply(this,arguments)}(e,void 0,t)}),lA.apply(this,arguments)}function uA(){return uA=F(function*(e,t,n){if(null==n&&(n={}),null==e.load)throw new W("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=yield e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let i=null==n.strict||n.strict,s=null!=r.weightData&&null!=r.weightSpecs&&i,o=Ki(lv(a),t,s),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new W("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=function VTe(e,t){let n=hr.decodeWeights(e,t),r={},a=[];return t.forEach(i=>{"optimizer"===i.group?a.push({name:i.name,tensor:n[i.name]}):r[i.name]=n[i.name]}),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(u,i),null!=o.optimizer&&c.length>0&&(yield o.optimizer.setWeights(c)),He(u),He(c.map(h=>h.tensor))}return o}),uA.apply(this,arguments)}ae.registerClass(PTe);var cA=(()=>{let e=class kO extends ho{constructor(n){if(super({inputs:[],outputs:[]}),n=n||{},this.trainable=!0,this.built=!1,this.name=null!=n.name?n.name:uI("sequential_"),null!=n.layers)for(let r of n.layers)this.add(r)}checkShape(n){if(n.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new W(`Negative dimension size caused by adding layer ${n.name} with input shape [${n.inboundNodes[0].inputTensors[0].shape}]`)}add(n){let a,r=n instanceof kO||n instanceof ho;if(r){if(a=n,1!==a.outputs.length)throw new W("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==a.inputs.length)throw new W("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===n.inboundNodes.length){if(null==n.batchInputShape)throw new W("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let i=l5({batchShape:n.batchInputShape,dtype:n.dtype,name:n.name+"_input"});n.apply(i)}if(r)this.outputs=a.outputs,this.inputs=a.inputs;else{if(1!==n.inboundNodes.length)throw new W(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${n.name} which has ${n.inboundNodes.length} pre-existing inbound connections.`);if(1!==n.inboundNodes[0].outputTensors.length)throw new W("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(n),this.outputs=[n.inboundNodes[0].outputTensors[0]],this.inputs=o5(this.outputs[0])}this.inboundNodes=[],new fI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ud(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{let i=n.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(n),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(n),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let n=this.layers.length-1;this.layers[n].outboundNodes=[],this.outputs=[this.layers[n].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(n,r){return null==this.model&&this.build(),this.model.call(n,r)}build(n){if(bt(n),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ho({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(n,r,a=console.log){this.built||this.build(),super.summary(n,r,a)}setWeights(n){null==this.model&&this.build(),this.model.setWeights(n)}evaluate(n,r,a={}){if(!this.built)throw new Cs("The model needs to be compiled before being used.");return this.model.evaluate(n,r,a)}evaluateDataset(n,r){var a=this;return F(function*(){if(!a.built)throw new Cs("The model needs to be compiled before being used.");return a.model.evaluateDataset(n,r)})()}predict(n,r={}){return null==this.model&&this.build(),this.model.predict(n,r)}predictOnBatch(n){return null==this.model&&this.build(),this.model.predictOnBatch(n)}compile(n){this.build(),this.model.compile(n),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(n){this.model.optimizer=n}fit(n,r,a={}){var i=this;return F(function*(){if(!i.built)throw new Cs("The model needs to be compiled before being used.");return i.model.fit(n,r,a)})()}fitDataset(n,r){var a=this;return F(function*(){if(!a.built)throw new Cs("The model needs to be compiled before being used.");return a.model.fitDataset(n,r)})()}trainOnBatch(n,r){var a=this;return F(function*(){return a.model.trainOnBatch(n,r)})()}static fromConfig(n,r,a={},i=!1){let s,o={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new W("Legacy serialization format not supported yet.");s=r}else I.assert(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=r.layers,delete r.layers,o=r;let l=new n(o);if(!(l instanceof kO))throw new nt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(let u of s){let c=Ki(u,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),l.add(c)}return l}set stopTraining(n){if(null==this.model)throw new W("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=n}get stopTraining(){if(null==this.model)throw new W("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let n=[];for(let r of this.layers){let a={};a.className=r.getClassName(),a.config=r.getConfig(),n.push(a)}return{name:this.name,layers:n}}};return e.className="Sequential",e})();function UTe(e){return new ho(e)}function WTe(e){return new cA(e)}function U5(e){return l5(e)}function jTe(e,t){_5.registerCallbackConstructor(e,t)}ae.registerClass(cA);var oa=class extends ae.Serializable{getConfig(){return{}}},W5=class extends oa{apply(e,t=1){return function uNe(e,t=1){if(1!==t)throw new nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return gf(e)}(e,t)}};W5.className="elu",ae.registerClass(W5);var HTe=(()=>{let e=class extends oa{apply(t){return j0(t)}};return e.className="selu",e})();ae.registerClass(HTe);var GTe=(()=>{let e=class extends oa{apply(t){return Rt(t)}};return e.className="relu",e})();ae.registerClass(GTe);var qTe=(()=>{let e=class extends oa{apply(t){return V(()=>al(6,Rt(t)))}};return e.className="relu6",e})();ae.registerClass(qTe);var KTe=(()=>{let e=class extends oa{apply(t){return t}};return e.className="linear",e})();ae.registerClass(KTe);var XTe=(()=>{let e=class extends oa{apply(t){return mi(t)}};return e.className="sigmoid",e})();ae.registerClass(XTe);var ZTe=(()=>{let e=class extends oa{apply(t){return function dNe(e){return V(()=>{let t=J(.5,z(.2,e));return Sr(t,0,1)})}(t)}};return e.className="hardSigmoid",e})();ae.registerClass(ZTe);var YTe=(()=>{let e=class extends oa{apply(t){return rd(t)}};return e.className="softplus",e})();ae.registerClass(YTe);var QTe=(()=>{let e=class extends oa{apply(t){return function cNe(e){return V(()=>ve(e,J(kn(e),1)))}(t)}};return e.className="softsign",e})();ae.registerClass(QTe);var JTe=(()=>{let e=class extends oa{apply(t){return Yc(t)}};return e.className="tanh",e})();ae.registerClass(JTe);var j5=(()=>{let e=class extends oa{apply(t,n=-1){return sl(t,n)}};return e.className="softmax",e})();ae.registerClass(j5);var eDe=(()=>{let e=class extends oa{apply(t,n=-1){return $0(t,n)}};return e.className="logSoftmax",e})();ae.registerClass(eDe);var tDe=(()=>{let e=class extends oa{apply(t,n=1){return V(()=>z(mi(z(t,n)),t))}};return e.className="swish",e})();ae.registerClass(tDe);var nDe=(()=>{let e=class extends oa{apply(t){return V(()=>z(t,Yc(rd(t))))}};return e.className="mish",e})();function fl(e){return e.getClassName()}function dA(e,t={}){return Jy(e,ae.SerializationMap.getMap().classNameMap,t,"activation")}function ml(e){if(null==e){return dA({className:"linear",config:{}})}if("string"==typeof e){let t={};return t.className=e,t.config={},dA(t)}return e instanceof oa?e:dA(e)}function hA(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}ae.registerClass(nDe);var H5=class extends ae.Serializable{},cv=class extends H5{constructor(e){super(),hA(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return V(()=>{let t=mn([1]);return this.hasL1&&(t=J(t,xe(z(this.l1,kn(e))))),this.hasL2&&(t=J(t,xe(z(this.l2,nv(e))))),B(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};cv.className="L1L2",ae.registerClass(cv);var G5={l1l2:"L1L2"};function Gt(e){return _D(e)}function q5(e,t={}){return Jy(e,ae.SerializationMap.getMap().classNameMap,t,"regularizer")}function ln(e){return null==e?null:"string"==typeof e?q5({className:e in G5?G5[e]:e,config:{}}):e instanceof H5?e:q5(e)}var K5=(()=>{let e=class extends it{constructor(t){super(t??{}),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,n){t=Pe(t);let r=Rt(t);return null!=this.maxValue&&(r=Sr(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}};return e.className="ReLU",e})();ae.registerClass(K5);var X5=(()=>{let e=class extends it{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,n){let r=Pe(t);return Uy(r,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};return e.className="LeakyReLU",e})();ae.registerClass(X5);var Z5=(()=>{let e=class extends it{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=on(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ln(t.alphaRegularizer),this.alphaConstraint=jn(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new W(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){let n=(t=bt(t)).slice(1);if(null!=this.sharedAxes)for(let a of this.sharedAxes)n[a-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let r={};if(null!=this.sharedAxes)for(let a=1;a<t.length;++a)r[a]=t[a];this.inputSpec=[new Dn({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=Pe(t),Ky(t,this.alpha.read())}getConfig(){let t={alphaInitializer:gn(this.alphaInitializer),alphaRegularizer:Gt(this.alphaRegularizer),alphaConstraint:Wn(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}};return e.className="PReLU",e})();ae.registerClass(Z5);var Y5=(()=>{let e=class extends it{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new nt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,n){let r=Pe(t);return gf(r)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};return e.className="ELU",e})();ae.registerClass(Y5);var Q5=(()=>{let e=class extends it{constructor(t){super(t??{}),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,n){let r=Pe(t);return z(r,de(zr(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}};return e.className="ThresholdedReLU",e})();ae.registerClass(Q5);var J5=(()=>{let e=class extends it{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new j5).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,n){return V(()=>{let r=Pe(t),a=n.mask;if(null!=a){let i=z(ye(aa(r.shape),de(a,r.dtype)),ke(-1e9));r=J(r,i)}return this.axis instanceof Array?this.axis.length>1?_r(ye(r,jy(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Softmax",e})();function Of(e,t,n){if("number"==typeof e)return ud(e,t);if(e.length!==t)throw new W(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!iNe(a))throw new W(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Zi(e,t,n,r,a=1){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*(a-1))+1,Math.floor((s+r-1)/r)}function Ns(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+hl([n-t,0]);else{if("same"!==r)throw new W(`Unsupport padding mode: ${r}.`);e*=t}return e}function pA(e,t){return V(()=>(bn(t),"channelsFirst"===t?tt(e,[0,2,3,1]):e))}function e8(e,t){return V(()=>(bn(t),"channelsFirst"===t?tt(e,[0,2,3,4,1]):e))}function t8(e,t,n,r=[1,1],a="valid",i,s,o=null){return V(()=>{if(null==i&&(i="channelsLast"),bn(i),3!==e.rank&&4!==e.rank)throw new W(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new W(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=pA(e,i);if("causal"===a)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Nf.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:s,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=tt(l,[0,3,1,2])),l})}ae.registerClass(J5);var n8=class fQ extends it{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",fQ.verifyArgs(n),this.rank=t,ar(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Of(n.kernelSize,t,"kernelSize"),this.strides=Of(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,Ya(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,bn(this.dataFormat),this.activation=ml(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=on(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=jn(n.biasConstraint),this.biasRegularizer=ln(n.biasRegularizer),this.activityRegularizer=ln(n.activityRegularizer),this.dilationRate=Of(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new W(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new W(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new W(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Es("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!ED(t.kernelSize,"number",1,3))throw new W(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:fl(this.activation),useBias:this.useBias,biasInitializer:gn(this.biasInitializer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),biasConstraint:Wn(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},CI=class mQ extends n8{constructor(t,n){super(t,n),this.kernel=null,mQ.verifyArgs(n),this.filters=n.filters,ar(this.filters,"filters"),this.kernelInitializer=on(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=jn(n.kernelConstraint),this.kernelRegularizer=ln(n.kernelRegularizer)}build(t){t=bt(t);let n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new W(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return V(()=>{t=Pe(t);let r,a=null==this.bias?null:this.bias.read(),i=V6(this.activation.getClassName());if(null!=i&&2===this.rank)r=t8(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function iDe(e,t,n,r=1,a="valid",i,s=1){return V(()=>{if(null==i&&(i="channelsLast"),bn(i),3!==e.shape.length)throw new W(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new W(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new W(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(e=tt(e,[0,2,1])),"causal"===a)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=T0(e,t,r,"same"===a?"same":"valid","NWC",s);return null!=n&&(o=Gi(o,n)),o})}(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=t8(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new nt("convolutions greater than 3D are not implemented yet.");r=function sDe(e,t,n,r=[1,1,1],a="valid",i,s){return V(()=>{if(null==i&&(i="channelsLast"),bn(i),4!==e.rank&&5!==e.rank)throw new W(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new W(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=e8(e,i);if("causal"===a)throw new nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=lT(o,t,r,"same"===a?"same":"valid","NDHWC",s),null!=n&&(o=Gi(o,n)),"channelsFirst"===i&&(o=tt(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=bt(t);let n=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){let s=Zi(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);n.push(s)}let a=[t[0]];return"channelsLast"===this.dataFormat?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){let t={filters:this.filters,kernelInitializer:gn(this.kernelInitializer),kernelRegularizer:Gt(this.kernelRegularizer),kernelConstraint:Wn(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new W(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},EI=class gQ extends CI{constructor(t){super(2,t),gQ.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!ED(t.kernelSize,"number",1,2))throw new W(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};EI.className="Conv2D",ae.registerClass(EI);var fA=(()=>{let e=class yQ extends CI{constructor(n){super(3,n),yQ.verifyArgs(n)}getConfig(){let n=super.getConfig();return delete n.rank,n}static verifyArgs(n){if("number"!=typeof n.kernelSize&&(!Array.isArray(n.kernelSize)||1!==n.kernelSize.length&&3!==n.kernelSize.length))throw new W(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(n.kernelSize)}.`)}};return e.className="Conv3D",e})();ae.registerClass(fA);var r8=(()=>{let e=class extends EI{constructor(t){if(super(t),this.inputSpec=[new Dn({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new W(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=bt(t)).length)throw new W("Input should have rank 4; Received input shape: "+JSON.stringify(t));let n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new W("The channel dimension of the inputs should be defined. Found `None`.");let r=t[n],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Dn({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return V(()=>{let r=Pe(t);if(4!==r.shape.length)throw new W(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let s,o,a=r.shape;"channelsFirst"===this.dataFormat?(s=2,o=3):(s=1,o=2);let u=a[o],h=this.kernelSize[1],p=this.strides[1],g=[a[0],Ns(a[s],this.strides[0],this.kernelSize[0],this.padding),Ns(u,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=tt(r,[0,2,3,1]));let y=D0(r,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=tt(y,[0,3,1,2])),null!=this.bias&&(y=Gi(y,this.bias.read(),this.dataFormat)),null!=this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(t){let r,a,i,n=(t=bt(t)).slice();"channelsFirst"===this.dataFormat?(r=1,a=2,i=3):(r=3,a=1,i=2);let s=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[a]=Ns(n[a],l,s,this.padding),n[i]=Ns(n[i],u,o,this.padding),n}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};return e.className="Conv2DTranspose",e})();ae.registerClass(r8);var a8=(()=>{let e=class extends fA{constructor(t){if(super(t),this.inputSpec=[new Dn({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new W(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=bt(t)).length)throw new W("Input should have rank 5; Received input shape: "+JSON.stringify(t));let n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new W("The channel dimension of the inputs should be defined. Found `None`.");let r=t[n],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Dn({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return V(()=>{let r=Pe(t);if(5!==r.shape.length)throw new W(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let s,o,l,a=r.shape;"channelsFirst"===this.dataFormat?(l=2,s=3,o=4):(l=1,s=2,o=3);let c=a[s],h=a[o],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[1],y=this.strides[2],x=[a[0],Ns(a[l],this.strides[0],this.kernelSize[0],this.padding),Ns(c,g,p,this.padding),Ns(h,y,f,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=tt(r,[0,2,3,4,1]));let C=uT(r,this.kernel.read(),x,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(C=tt(C,[0,4,1,2,3])),null!==this.bias&&(C=Gi(C,this.bias.read(),this.dataFormat)),null!==this.activation&&(C=this.activation.apply(C)),C})}computeOutputShape(t){let r,a,i,s,n=(t=bt(t)).slice();"channelsFirst"===this.dataFormat?(r=1,a=2,i=3,s=4):(r=4,a=1,i=2,s=3);let o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return n[r]=this.filters,n[a]=Ns(n[a],c,o,this.padding),n[i]=Ns(n[i],h,l,this.padding),n[s]=Ns(n[s],d,u,this.padding),n}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};return e.className="Conv3DTranspose",e})();ae.registerClass(a8);var oDe=(()=>{let e=class extends CI{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==n.filters)throw new W("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new W("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new W(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,this.depthwiseInitializer=on(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ln(n.depthwiseRegularizer),this.depthwiseConstraint=jn(n.depthwiseConstraint),this.pointwiseInitializer=on(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ln(n.pointwiseRegularizer),this.pointwiseConstraint=jn(n.pointwiseConstraint)}build(t){if((t=bt(t)).length<this.rank+2)throw new W(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n]||t[n]<0)throw new W(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);let r=t[n],a=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(r*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):null,this.inputSpec=[new Dn({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return V(()=>{let r;if(t=Pe(t),1===this.rank)throw new nt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=tt(t,[0,2,3,1])),r=_f(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Gi(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),"channelsFirst"===this.dataFormat&&(r=tt(r,[0,3,1,2])),r})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=gn(this.depthwiseInitializer),t.pointwiseInitializer=gn(this.pointwiseInitializer),t.depthwiseRegularizer=Gt(this.depthwiseRegularizer),t.pointwiseRegularizer=Gt(this.pointwiseRegularizer),t.depthwiseConstraint=Wn(this.depthwiseConstraint),t.pointwiseConstraint=Wn(this.pointwiseConstraint),t}};return e.className="SeparableConv",e})(),i8=(()=>{let e=class extends oDe{constructor(t){super(2,t)}};return e.className="SeparableConv2D",e})();ae.registerClass(i8);var s8=(()=>{let e=class vQ extends CI{constructor(n){super(1,n),vQ.verifyArgs(n),this.inputSpec=[{ndim:3}]}getConfig(){let n=super.getConfig();return delete n.rank,delete n.dataFormat,n}static verifyArgs(n){if("number"!=typeof n.kernelSize&&!ED(n.kernelSize,"number",1,1))throw new W(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(n.kernelSize)}.`)}};return e.className="Conv1D",e})();ae.registerClass(s8);var o8=(()=>{let e=class extends it{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return V(()=>{if(t=Pe(t),"channelsLast"===this.dataFormat){let r=cI(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return cI(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let r=cI(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return cI(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Cropping2D",e})();ae.registerClass(o8);var l8=(()=>{let e=class extends it{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,bn(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,function nNe(e){dd(Qke,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,n){return V(()=>{let r=Pe(t),a=r.shape;if("channelsFirst"===this.dataFormat){r=tt(r,[0,2,3,1]);let i=this.size[0]*a[2],s=this.size[1]*a[3],o="nearest"===this.interpolation?Za.resizeNearestNeighbor(r,[i,s]):Za.resizeBilinear(r,[i,s]);return tt(o,[0,3,1,2])}{let i=this.size[0]*a[1],s=this.size[1]*a[2];return"nearest"===this.interpolation?Za.resizeNearestNeighbor(r,[i,s]):Za.resizeBilinear(r,[i,s])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}};return e.className="UpSampling2D",e})();ae.registerClass(l8);var u8=(()=>{let e=class extends n8{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=on(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=jn(t.depthwiseConstraint),this.depthwiseRegularizer=ln(t.depthwiseRegularizer)}build(t){if((t=bt(t)).length<4)throw new W(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let n="channelsFirst"===this.dataFormat?1:3;if(null==t[n]||t[n]<0)throw new W(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);let r=t[n];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,n){return V(()=>{let r=function lDe(e,t,n=[1,1],r="valid",a,i){return V(()=>{null==a&&(a="channelsLast"),bn(a);let s=pA(e,a);if(4!==e.rank)throw new W(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new W(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=ed(s,t,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===a&&(s=tt(s,[0,3,1,2])),s})}(t=Pe(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Gi(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=bt(t);let r="channelsFirst"===this.dataFormat?t[3]:t[2],a="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=Zi("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),s=Zi(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],a,i,s]:[t[0],i,s,a]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=gn(this.depthwiseInitializer),t.depthwiseRegularizer=Gt(this.depthwiseRegularizer),t.depthwiseConstraint=Wn(this.depthwiseRegularizer),t}};return e.className="DepthwiseConv2D",e})();function c8(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new W("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function d8(e,t,n,r=!1,a,i,s=!1,o=!1){return V(()=>{let l=t.shape.length;if(l<3)throw new W(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(ji(2,l));if(t=tt(t,u),null!=i)throw new nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");s&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=de(de(a,"bool"),"float32")).rank===l-1&&(a=nr(a,-1)),a=tt(a,u)),r&&(t=Xa(t,0),null!=a&&(a=Xa(a,0)));let h,m,g,c=[],d=n,p=t.shape[0],f=vn(t);null!=a&&(m=vn(a));for(let y=0;y<p;++y){let v=f[y],b=V(()=>e(v,d));if(null==a)h=b[0],d=b[1];else{let w=V(()=>{let x=m[y],C=ye(Na(x),x);return{output:J(z(b[0],x),z(d[0],C)),newStates:d.map((A,R)=>J(z(b[1][R],x),z(A,C)))}});h=w.output,d=w.newStates}o&&c.push(h)}return o&&(g=Tn(c,1)),[h,g,d]})}ae.registerClass(u8);var gl=(()=>{let e=class bQ extends it{constructor(n){let r;if(super(n),null==n.cell)throw new W("cell property is missing for the constructor of RNN.");if(r=Array.isArray(n.cell)?new gA({cells:n.cell}):n.cell,null==r.stateSize)throw new W("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=n.returnSequences&&n.returnSequences,this.returnState=null!=n.returnState&&n.returnState,this.goBackwards=null!=n.goBackwards&&n.goBackwards,this._stateful=null!=n.stateful&&n.stateful,this.unroll=null!=n.unroll&&n.unroll,this.supportsMasking=!0,this.inputSpec=[new Dn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?ji(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(n){this.states_=n}computeOutputShape(n){BD(n)&&(n=n[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let i,a=r[0];if(i=this.returnSequences?[n[0],n[1],a]:[n[0],a],this.returnState){let s=[];for(let o of r)s.push([n[0],o]);return[i].concat(s)}return i}computeMask(n,r){return V(()=>{Array.isArray(r)&&(r=r[0]);let a=this.returnSequences?r:null;if(this.returnState){let i=this.states.map(s=>null);return[a].concat(i)}return a})}get states(){if(null==this.states_){let n=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let a=0;a<n;++a)r.push(null);return r}return this.states_}set states(n){this.states_=n}build(n){if(null!=this.numConstants)throw new nt("Constants support is not implemented in RNN yet.");BD(n)&&(n=n[0]);let r=this.stateful?n[0]:null,a=n.slice(2);this.inputSpec[0]=new Dn({shape:[r,null,...a]});let s,i=[n[0]].concat(n.slice(2));if(this.cell.build(i),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!I.arraysEqual(this.stateSpec.map(o=>o.shape[o.shape.length-1]),s))throw new W(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(o=>new Dn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(n,r=!1){V(()=>{if(!this.stateful)throw new ul("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape[0];if(null==a)throw new W("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>mn([a,i])):[mn([a,this.cell.stateSize])];else if(null==n)He(this.states_),null!=this.keptStates&&(He(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>mn([a,i])):this.states_[0]=mn([a,this.cell.stateSize]);else{if(Array.isArray(n)||(n=[n]),n.length!==this.states_.length)throw new W(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${n.length} state value(s). Input received: ${n}`);!0===r?this.keptStates.push(this.states_.slice()):He(this.states_);for(let i=0;i<this.states_.length;++i){let s=n[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[a,o];if(!I.arraysEqual(s.shape,l))throw new W(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>Bn(i.clone()))})}apply(n,r){let a=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});let s=c8(n,a,i,this.numConstants);n=s.inputs,a=s.initialState,i=s.constants;let o=[],l=[];if(null!=a){r.initialState=a,o=o.concat(a),this.stateSpec=[];for(let u of a)this.stateSpec.push(new Dn({shape:u.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(r.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof qi){let u=[n].concat(o),c=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=c;let d=super.apply(u,r);return this.inputSpec=h,d}return super.apply(n,r)}call(n,r){return V(()=>{let a=null==r?null:r.mask,i=null==r?null:r.training,s=null==r?null:r.initialState;n=Pe(n),null==s&&(s=this.stateful?this.states_:this.getInitialState(n));let o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==o)throw new W(`RNN Layer has ${o} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let l={training:i},u=d8((f,m)=>{let g=this.cell.call([f].concat(m),l);return[g[0],g.slice(1)]},n,s,this.goBackwards,a,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,i);let p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(n){return V(()=>{let r=mn(n.shape);return r=xe(r,[1,2]),r=tv(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?DD(r,[1,a]):r):this.cell.stateSize>1?[DD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(n)}getConfig(){let n=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===bQ.className&&(r.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),n),r)}static fromConfig(n,r,a={}){let s=Ki(r.cell,a);return new n(Object.assign(r,{cell:s}))}};return e.className="RNN",e})();ae.registerClass(gl);var dv=class extends it{},kI=class extends dv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ar(this.units,"units"),this.activation=ml(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=on(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=on(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=on(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ln(e.kernelRegularizer),this.recurrentRegularizer=ln(e.recurrentRegularizer),this.biasRegularizer=ln(e.biasRegularizer),this.kernelConstraint=jn(e.kernelConstraint),this.recurrentConstraint=jn(e.recurrentConstraint),this.biasConstraint=jn(e.biasConstraint),this.dropout=Af([1,hl([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Af([1,hl([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=bt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return V(()=>{if(2!==e.length)throw new W(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yl({ones:()=>Na(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yl({ones:()=>Na(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,i=this.dropoutMask,s=this.recurrentDropoutMask;a=ks(null!=i?z(e,i):e,this.kernel.read()),null!=this.bias&&(a=Gi(a,this.bias.read())),null!=s&&(n=z(n,s));let o=J(a,ks(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:fl(this.activation),useBias:this.useBias,kernelInitializer:gn(this.kernelInitializer),recurrentInitializer:gn(this.recurrentInitializer),biasInitializer:gn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Wn(this.kernelConstraint),recurrentConstraint:Wn(this.recurrentConstraint),biasConstraint:Wn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};kI.className="SimpleRNNCell",ae.registerClass(kI);var h8=(()=>{let e=class extends gl{constructor(t){t.cell=new kI(t),super(t)}call(t,n){return V(()=>(null!=this.cell.dropoutMask&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return new t(n)}};return e.className="SimpleRNN",e})();ae.registerClass(h8);var mA=(()=>{let e=class extends dv{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new W("GRUCell does not support reset_after parameter set to true.");this.units=t.units,ar(this.units,"units"),this.activation=ml(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ml(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=on(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=on(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=on(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ln(t.kernelRegularizer),this.recurrentRegularizer=ln(t.recurrentRegularizer),this.biasRegularizer=ln(t.biasRegularizer),this.kernelConstraint=jn(t.kernelConstraint),this.recurrentConstraint=jn(t.recurrentConstraint),this.biasConstraint=jn(t.biasConstraint),this.dropout=Af([1,hl([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=Af([1,hl([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=bt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,n){return V(()=>{if(2!==t.length)throw new W(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let r=null!=n.training&&n.training,a=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yl({ones:()=>Na(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yl({ones:()=>Na(a),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));let o,l,u,s=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(t=z(t,this.dropoutMask[0]));let c=ks(t,this.kernel.read());this.useBias&&(c=Gi(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,s[0]));let h=this.recurrentKernel.read(),[d,p]=ia(h,[2*this.units,this.units],h.rank-1),f=ks(a,d),[m,g,y]=ia(c,3,c.rank-1),[v,b]=ia(f,2,f.rank-1);o=this.recurrentActivation.apply(J(m,v)),l=this.recurrentActivation.apply(J(g,b));let w=ks(z(l,a),p);u=this.activation.apply(J(y,w));let x=J(z(o,a),z(J(1,Yt(o)),u));return[x,x]})}getConfig(){let t=super.getConfig(),n={units:this.units,activation:fl(this.activation),recurrentActivation:fl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:gn(this.kernelInitializer),recurrentInitializer:gn(this.recurrentInitializer),biasInitializer:gn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Wn(this.kernelConstraint),recurrentConstraint:Wn(this.recurrentConstraint),biasConstraint:Wn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}};return e.className="GRUCell",e})();ae.registerClass(mA);var p8=(()=>{let e=class extends gl{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new mA(t),super(t)}call(t,n){return V(()=>(null!=this.cell.dropoutMask&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return 0===n.implmentation&&(n.implementation=1),new t(n)}};return e.className="GRU",e})();ae.registerClass(p8);var NI=(()=>{let e=class extends dv{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ar(this.units,"units"),this.activation=ml(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ml(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=on(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=on(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=on(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ln(t.kernelRegularizer),this.recurrentRegularizer=ln(t.recurrentRegularizer),this.biasRegularizer=ln(t.biasRegularizer),this.kernelConstraint=jn(t.kernelConstraint),this.recurrentConstraint=jn(t.recurrentConstraint),this.biasConstraint=jn(t.biasConstraint),this.dropout=Af([1,hl([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=Af([1,hl([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;let a;if(t=bt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,s=this.units;a=new((n=class extends vi{apply(o,l){let u=i.apply([s]),c=(new RD).apply([s]),h=i.apply([2*s]);return K6(K6(u,c),h)}}).className="CustomInit",n)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return V(()=>{let r=null!=n.training&&n.training;if(3!==t.length)throw new W(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let a=t[1],i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yl({ones:()=>Na(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yl({ones:()=>Na(a),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));let l,u,c,h,o=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(t=z(t,this.dropoutMask[0]));let d=ks(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,o[0])),d=J(d,ks(a,this.recurrentKernel.read())),this.useBias&&(d=Gi(d,this.bias.read()));let[p,f,m,g]=ia(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=J(z(u,i),z(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);let y=z(h,this.activation.apply(c));return[y,y,c]})}getConfig(){let t=super.getConfig(),n={units:this.units,activation:fl(this.activation),recurrentActivation:fl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:gn(this.kernelInitializer),recurrentInitializer:gn(this.recurrentInitializer),biasInitializer:gn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Wn(this.kernelConstraint),recurrentConstraint:Wn(this.recurrentConstraint),biasConstraint:Wn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}};return e.className="LSTMCell",e})();ae.registerClass(NI);var f8=(()=>{let e=class extends gl{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new NI(t),super(t)}call(t,n){return V(()=>(null!=this.cell.dropoutMask&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return 0===n.implmentation&&(n.implementation=1),new t(n)}};return e.className="LSTM",e})();ae.registerClass(f8);var gA=(()=>{let e=class extends dv{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return V(()=>{let r=t.slice(1),a=[];for(let o of this.cells.slice().reverse())Array.isArray(o.stateSize)?a.push(r.splice(0,o.stateSize.length)):a.push(r.splice(0,1));a.reverse();let s,i=[];for(let o=0;o<this.cells.length;++o){let l=this.cells[o];r=a[o],s=0===o?[t[0]].concat(r):[s[0]].concat(r),s=l.call(s,n),i.push(s.slice(1))}r=[];for(let o of i.slice().reverse())r.push(...o);return[s[0]].concat(r)})}build(t){let n;BD(t)&&(t=t[0]),this.cells.forEach((r,a)=>{hd(`RNNCell_${a}`,()=>{r.build(t),n=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){let t=super.getConfig(),r={cells:this.cells.map(a=>({className:a.getClassName(),config:a.getConfig()}))};return Object.assign(Object.assign({},t),r)}static fromConfig(t,n,r={}){let a=[];for(let i of n.cells)a.push(Ki(i,r));return new t({cells:a})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){let t=[];for(let n of this.cells)t.push(...n.weights);return VD(t)}setWeights(t){let n=[];for(let r of this.cells){let i=t.splice(r.weights.length);for(let s=0;s<r.weights.length;++s)n.push([r.weights[s],i[s]])}UD(n)}};return e.className="StackedRNNCells",e})();function yl(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:i}=e,s=()=>null!=i?i(t(),n):Z6(t(),n),o=()=>rv(s,t,r);return!a||a<=1?Bn(o().clone()):Array(a).fill(void 0).map(o).map(l=>Bn(l.clone()))}ae.registerClass(gA);var m8=class extends gl{constructor(e){if(e.unroll)throw new nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new nt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Dn({ndim:5})]}call(e,t){return V(()=>{if(null!=this.cell.dropoutMask&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new W("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return V(()=>{let{stateSize:t}=this.cell,r=this.computeSingleOutputShape(e.shape),i=mn([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){V(()=>{if(!this.stateful)throw new ul("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new W("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>mn(a)):[mn(a)];else if(null==e)He(this.states_),null!=this.keptStates&&(He(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>mn(a)):this.states_[0]=mn(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new W(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):He(this.states_);for(let i=0;i<this.states_.length;++i){let s=e[i],o=a;if(!I.arraysEqual(s.shape,o))throw new W(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>Bn(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:i,dilationRate:s}=this.cell,o="channelsFirst"===t,u=e[o?4:3],c=Zi(e[o?3:2],r[0],a,i[0],s[0]),h=Zi(u,r[1],a,i[1],s[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}};m8.className="ConvRNN2D";var yA=(()=>{let e=class extends NI{constructor(t){let{filters:n,kernelSize:r,strides:a,padding:i,dataFormat:s,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,ar(this.filters,"filters"),this.kernelSize=Of(r,2,"kernelSize"),this.kernelSize.forEach(l=>ar(l,"kernelSize")),this.strides=Of(a||1,2,"strides"),this.strides.forEach(l=>ar(l,"strides")),this.padding=i||"valid",Ya(this.padding),this.dataFormat=s||"channelsLast",bn(this.dataFormat),this.dilationRate=Of(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>ar(l,"dilationRate"))}build(t){var n;t=bt(t);let r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new W(`The channel dimension of the input should be defined. Found ${t[r]}`);let s=this.kernelSize.concat([t[r],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;l=new((n=class extends vi{apply(h,d){return TD([u.apply([c]),aa([c]),u.apply([2*c])])}}).className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return V(()=>{if(3!==t.length)throw new W(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=n.training||!1,a=t[0],i=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yl({ones:()=>Na(a),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));let l=this.dropoutMask,u=(ee,te,se)=>te&&te[se]?z(te[se],ee):ee,c=u(a,l,0),h=u(a,l,1),d=u(a,l,2),p=u(a,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yl({ones:()=>Na(i),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,m=u(i,f,0),g=u(i,f,1),y=u(i,f,2),v=u(i,f,3),[w,x,C,k]=ia(this.kernel.read(),4,3),[T,A,R,M]=this.useBias?ia(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,w,T,this.padding),h=this.inputConv(h,x,A,this.padding),d=this.inputConv(d,C,R,this.padding),p=this.inputConv(p,k,M,this.padding);let[_,$,U,j]=ia(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,_),g=this.recurrentConv(g,$),y=this.recurrentConv(y,U),v=this.recurrentConv(v,j);let G=this.recurrentActivation.apply(J(c,m)),K=this.recurrentActivation.apply(J(h,g)),X=J(z(K,s),z(G,this.activation.apply(J(d,y)))),Y=z(this.recurrentActivation.apply(J(p,v)),this.activation.apply(X));return[Y,Y,X]})}getConfig(){let r=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(super.getConfig(),["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),a)}inputConv(t,n,r,a){let i=Lr(t,n,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?Gi(i,r,this.dataFormat):i}recurrentConv(t,n){return Lr(t,n,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};return e.className="ConvLSTM2DCell",e})();ae.registerClass(yA);var g8=(()=>{let e=class extends m8{constructor(t){let n=new yA(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}};return e.className="ConvLSTM2D",e})();ae.registerClass(g8);var vA=(()=>{let e=class extends it{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;let n=t.shape,r=[];for(let a=0;a<this.noiseShape.length;++a)r.push(null==this.noiseShape[a]?n[a]:this.noiseShape[a]);return r}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);if(0<this.rate&&this.rate<1){let a=null!=n.training&&n.training,i=this.getNoiseShape(r);return rv(()=>Z6(r,this.rate,i,this.seed),()=>r,a)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}};return e.className="Dropout",e})();ae.registerClass(vA);var y8=(()=>{let e=class extends vA{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let n=t.shape;return[n[0],1,n[2]]}};return e.className="SpatialDropout1D",e})();ae.registerClass(y8);var v8=(()=>{let e=class extends it{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let n=null;null!=t.batchSize&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,ar(this.units,"units"),this.activation=ml(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=on(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=on(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=jn(t.kernelConstraint),this.biasConstraint=jn(t.biasConstraint),this.kernelRegularizer=ln(t.kernelRegularizer),this.biasRegularizer=ln(t.biasRegularizer),this.activityRegularizer=ln(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){let n=(t=bt(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){let n=(t=bt(t)).slice();return n[n.length-1]=this.units,n}call(t,n){return V(()=>{this.invokeCallHook(t,n);let i,r=Pe(t),a=V6(this.activation.getClassName());return null!=a?i=ks(r,this.kernel.read(),a,this.bias?this.bias.read():null):(i=ks(r,this.kernel.read()),null!=this.bias&&(i=Gi(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){let t={units:this.units,activation:fl(this.activation),useBias:this.useBias,kernelInitializer:gn(this.kernelInitializer),biasInitializer:gn(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:Wn(this.kernelConstraint),biasConstraint:Wn(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Dense",e})();ae.registerClass(v8);var b8=(()=>{let e=class extends it{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=bt(t);for(let n of t.slice(1))if(null==n)throw new W(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],dl(t,1)]}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);if("channelsFirst"===this.dataFormat&&r.rank>1){let a=[0];for(let i=2;i<r.rank;++i)a.push(i);a.push(1),r=tt(r,a)}return function lNe(e){if(e.rank<=1)throw new W(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],dl(e.shape,1)];return B(e,t)}(r)})}getConfig(){let t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);let n=super.getConfig();return Object.assign(t,n),t}};return e.className="Flatten",e})();ae.registerClass(b8);var w8=(()=>{let e=class extends it{constructor(t){super(t),this.supportsMasking=!0,this.activation=ml(t.activation)}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);return this.activation.apply(r)})}getConfig(){let t={activation:fl(this.activation)},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Activation",e})();ae.registerClass(w8);var x8=(()=>{let e=class extends it{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return V(()=>function sNe(e,t){return V(()=>{if(2!==e.shape.length)throw new W(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return DD(tv(e,1),[1,t,1])})}(t=Pe(t),this.n))}getConfig(){let t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}};return e.className="RepeatVector",e})();ae.registerClass(x8);var I8=(()=>{let e=class extends it{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,n){let r="Total size of new array must be unchanged.",a=n.slice(),i=1,s=null;for(let l=0;l<a.length;++l){let u=a[l];if(this.isUnknown(u)){if(null!==s)throw new W("Can only specifiy one unknown dimension.");s=l}else i*=u}let o=dl(t);if(null!==s){if(0===i||o%i!=0)throw new W(r);a[s]=o/i}else if(o!==i)throw new W(r);return a}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t),a=r.shape,i=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return B(r,i)})}getConfig(){let t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Reshape",e})();ae.registerClass(I8);var S8=(()=>{let e=class extends it{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let n=ji(1,t.dims.length+1);if(!I.arraysEqual(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Dn({ndim:this.dims.length+1})]}computeOutputShape(t){let n=(t=bt(t)).slice();return this.dims.forEach((r,a)=>{n[a+1]=t[r]}),n}call(t,n){return tt(Pe(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Permute",e})();ae.registerClass(S8);var _8=(()=>{let e=class extends it{constructor(t){super(t??{}),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){let r=Pe(t);return Fy(ad(r,this.maskValue),-1)}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t),a=Fy(ad(r,this.maskValue),-1,!0);return z(r,de(a,r.dtype))})}};return e.className="Masking",e})();ae.registerClass(_8);var C8=(()=>{let e=class extends it{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),this.batchInputShape=null==t.inputLength?[n,null]:[n].concat(Ft(t.inputLength))}this.inputDim=t.inputDim,ar(this.inputDim,"inputDim"),this.outputDim=t.outputDim,ar(this.outputDim,"outputDim"),this.embeddingsInitializer=on(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ln(t.embeddingsRegularizer),this.activityRegularizer=ln(t.activityRegularizer),this.embeddingsConstraint=jn(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return V(()=>this.maskZero?(t=Pe(t),ad(t,ft(t))):null)}computeOutputShape(t){if(t=bt(t),null==this.inputLength)return[...t,this.outputDim];let n=Ft(this.inputLength);if(n.length!==t.length-1)throw new W(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let a=0;a<n.length;++a){let i=n[a],s=t[a+1];if(null!=i&&null!=s&&i!==s)throw new W(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==i&&(n[r]=s),r++}}return[t[0],...n,this.outputDim]}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);"int32"!==r.dtype&&(r=co(r,"int32"));let a=X6(this.embeddings.read(),B(r,[r.size]));return B(a,bt(this.computeOutputShape(r.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:gn(this.embeddingsInitializer),embeddingsRegularizer:Gt(this.embeddingsRegularizer),activityRegularizer:Gt(this.activityRegularizer),embeddingsConstraint:Wn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Embedding",e})();ae.registerClass(C8);var md=class extends it{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new nt}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],i=t[r];if(null==a||null==i||a<0||i<0)n.push(null);else if(1===a)n.push(i);else if(1===i)n.push(a);else{if(a!==i)throw new W("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[bt(e)]),e.length<2)throw new W(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=cl(t),t.length>1)throw new W(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let i=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let r=e.map(a=>a.length);this.reshapeRequired=-1!==e.indexOf(null)||1!==cl(r).length}call(e,t){return V(()=>{if(this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(-1===r.indexOf(null)){let a=hl(r);for(let i of e){let s=i.rank;for(let o=0;o<a-s;++o)i=tv(i,1);n.push(i)}return this.mergeFunction(n)}{let a=!1;for(let o of e){let l=o.rank;if(null==l){let u=o.shape,c=u[0],h=u.slice(1).concat([c]),d=B(o,[c].concat(dl(u.slice(1))));d=tt(d,[1,0]),d=B(d,h),n.push(d),a=!0}else if(l>1){let u=ji(1,l).concat([0]);n.push(tt(o,u)),a=!0}else n.push(o)}let i=this.mergeFunction(n),s=i.rank;if(a)if(null==s){let o=i.shape,u=o[o.length-1],c=[u].concat(o.slice(0,o.length-1));i=B(tt(B(i,[-1,u]),[1,0]),c)}else if(s>1){let o=[s-1].concat(ji(0,s-1));i=tt(i,o)}return i}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let a=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=cl(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return V(()=>{if(null==t)return null;if(!Array.isArray(t))throw new W("`mask` should be an Array");if(!Array.isArray(e))throw new W("`inputs` should be an Array");if(t.length!==e.length)throw new W(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>null==r))return null;let n=(t=t.map(r=>null==r?r:nr(r,0)))[0];for(let r=1;r<t.length-1;++r)n=gi(n,t[r]);return n})}},bA=class extends md{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=J(t,e[n]);return t})}};bA.className="Add",ae.registerClass(bA);var E8=(()=>{let e=class extends md{constructor(t){super(t)}mergeFunction(t){return V(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=z(n,t[r]);return n})}};return e.className="Multiply",e})();ae.registerClass(E8);var k8=(()=>{let e=class extends md{constructor(t){super(t)}mergeFunction(t){return V(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=J(n,t[r]);return z(1/t.length,n)})}};return e.className="Average",e})();ae.registerClass(k8);var N8=(()=>{let e=class extends md{constructor(t){super(t)}mergeFunction(t){return V(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=xs(n,t[r]);return n})}};return e.className="Maximum",e})();ae.registerClass(N8);var T8=(()=>{let e=class extends md{constructor(t){super(t)}mergeFunction(t){return V(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=al(n,t[r]);return n})}};return e.className="Minimum",e})();ae.registerClass(T8);var D8=(()=>{let e=class extends md{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new W("A `Concatenate` layer should be called on a list of at least 2 inputs");let n=!0;for(let a of t)if(null!=a){n=!1;break}if(n)return;let r=[];for(let a=0;a<t.length;++a){let i=t[a].slice();i.splice(this.axis,1);let s=!1;for(let o of r)if(I.arraysEqual(o,i)){s=!0;break}s||r.push(i)}if(r.length>1)throw new W("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return V(()=>TD(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new W("A `Concatenate` layer should be called on a list of inputs.");let n=t,r=n[0].slice(),a=this.axis<0?r.length+this.axis:this.axis;for(let i of n.slice(1)){if(null==r[a]||null==i[a]){r[a]=null;break}r[a]+=i[a]}return r}computeMask(t,n){if(null==n)return null;if(!Array.isArray(n))throw new W("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new W("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new W(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return V(()=>{let r=!0;if(n.forEach(s=>{null==s||(r=!1)}),r)return null;let a=[];for(let s=0;s<t.length;++s)a.push(null==n[s]?de(Na(t[s]),"bool"):n[s].rank<t[s].rank?nr(n[s],-1):n[s]);let i=zt(a,this.axis);return N0(i,-1,!1)})}getConfig(){let t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Concatenate",e})();function hv(e,t){for(;e<0;)e+=t;return e}ae.registerClass(D8);var A8=(()=>{let e=class extends md{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){I.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=t[0],r=t[1];if(n.length>3||r.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(n,r);if(n[a[0]]!==r[a[1]])throw new W(`Dimension incompatibility: ${n[a[0]]} !== ${r[a[1]]}`)}mergeFunction(t){if(2!==t.length)throw new W(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let a,n=t[0],r=t[1];return a=Array.isArray(this.axes)?this.axes.map((i,s)=>hv(i,t[s].shape.length)):[hv(this.axes,n.shape.length),hv(this.axes,r.shape.length)],this.normalize&&(n=yI(n,a[0]),r=yI(r,a[1])),function cDe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(I.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),I.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new nt("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let i=n;return V(()=>{let s,o;if(r>a){s=r-a;let l=[];for(let u=0;u<s;++u)l.push(1);t=B(t,t.shape.concat(l))}else if(a>r){s=a-r;let l=[];for(let u=0;u<s;++u)l.push(1);e=B(e,e.shape.concat(l))}else s=0;if(o=2===e.shape.length&&2===t.shape.length?i[0]===i[1]?xe(z(e,t),i[0]):xe(z(tt(e,[1,0]),t),i[1]):et(e,t,i[0]!==e.shape.length-1,i[1]===t.shape.length-1),s>0){let l;l=r>a?r+a-3:r-1;let u=[];for(let c=l;c<l+s;++c)u.push(c);o=ol(o,u)}return 1===o.shape.length&&(o=nr(o,1)),o})}(n,r,a)}interpretAxes(t,n){let r;return r=Array.isArray(this.axes)?this.axes:[hv(this.axes,t.length),hv(this.axes,n.length)],r}computeOutputShape(t){I.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(n,r);n.splice(a[0],1),r.splice(a[1],1),r.splice(0,1);let i=n.concat(r);return 1===i.length&&i.push(1),i}computeMask(t,n){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}};return e.className="Dot",e})();ae.registerClass(A8);var M8=(()=>{let e=class extends it{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);return rv(()=>J(dI(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}};return e.className="GaussianNoise",e})();ae.registerClass(M8);var R8=(()=>{let e=class extends it{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return V(()=>{this.invokeCallHook(t,n);let r=Pe(t);return this.rate>0&&this.rate<1?rv(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return z(r,dI(r.shape,1,a))},()=>r,n.training||!1):r})}};return e.className="GaussianDropout",e})();ae.registerClass(R8);var F8=(()=>{let e=class extends it{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Pe(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return V(()=>{if(this.rate<1&&this.rate>0){let r=this._getNoiseShape(t);return rv(()=>{let a=Pe(t),i=-1.7580993408473766,s=so(il(r),this.rate);s=co(s,"float32");let o=((1-this.rate)*(1+this.rate*i**2))**-.5,l=-o*i*this.rate,u=J(z(a,s),z(J(s,-1),i));return J(z(u,o),l)},()=>Pe(t),n.training||!1)}return t})}};return e.className="AlphaDropout",e})();function pv(e,t,n,r,a,i=.001){let s;if(2===e.rank)s=QN(e,t,n,r,a,i);else if(3===e.rank)s=JN(e,t,n,r,a,i);else{if(4!==e.rank)throw new nt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=eT(e,t,n,r,a,i)}return s}ae.registerClass(F8);var O8=(()=>{let e=class extends it{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=on(t.betaInitializer||"zeros"),this.gammaInitializer=on(t.gammaInitializer||"ones"),this.movingMeanInitializer=on(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=on(t.movingVarianceInitializer||"ones"),this.betaConstraint=jn(t.betaConstraint),this.gammaConstraint=jn(t.gammaConstraint),this.betaRegularizer=ln(t.betaRegularizer),this.gammaRegularizer=ln(t.gammaRegularizer)}build(t){t=bt(t);let n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(null==r)throw new W(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Dn({ndim:t.length,axes:{[n]:r}})];let a=[r];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return V(()=>{let r=null!=n.training&&n.training,a=Pe(t),i=a.shape,s=i.length,o=ji(0,s),l=this.axis>=0?this.axis:this.axis+s;o.splice(l,1);let u=ud(1,s);u[l]=i[l];let c=o.slice();c.sort();let h=!I.arraysEqual(c,ji(0,s).slice(0,s-1));if(!r)return(()=>{if(h){let y=B(this.movingMean.read(),u),v=B(this.movingVariance.read(),u),b=this.center?B(this.beta.read(),u):null,w=this.scale?B(this.gamma.read(),u):null;return pv(a,y,v,b,w,this.epsilon)}return pv(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[p,f,m]=function pDe(e,t,n,r,a=.001){return I.arraysEqual(r.slice().sort(),ji(0,e.rank-1))?function dDe(e,t,n,r,a=.001){return V(()=>{let i=Gy(e,r),s=i.mean,o=i.variance;return[pv(e,s,o,n,t,a),s,o]})}(e,t,n,r,a):function hDe(e,t,n,r,a=.001){return V(()=>{let i=Gy(e,r),s=i.mean,o=i.variance,l=[];for(let p of ji(0,e.rank))-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p]);let u=B(s,l),c=B(o,l),h=null==t?null:B(t,l),d=null==n?null:B(n,l);return[pv(e,u,c,d,h,a),s,o]})}(e,t,n,r,a)}(a,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(y,v,b)=>{V(()=>{let w=1-b,x=y.read(),C=z(ye(x,v),w);y.write(ye(x,C))})};return g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum),p})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:gn(this.betaInitializer),gammaInitializer:gn(this.gammaInitializer),movingMeanInitializer:gn(this.movingMeanInitializer),movingVarianceInitializer:gn(this.movingVarianceInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer),betaConstraint:Wn(this.betaConstraint),gammaConstraint:Wn(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}};return e.className="BatchNormalization",e})();ae.registerClass(O8);var $8=(()=>{let e=class extends it{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=on(t.betaInitializer||"zeros"),this.gammaInitializer=on(t.gammaInitializer||"ones"),this.betaRegularizer=ln(t.betaRegularizer),this.gammaRegularizer=ln(t.gammaRegularizer),this.supportsMasking=!0}build(t){let n=(t=bt(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=n);for(let i of this.axis)if(i<0||i>=n)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==cl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let r=this.axis.map(i=>t[i]),a=!0;this.gamma=this.scale?this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,a):null,this.beta=this.center?this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,a):null,this.built=!0}call(t,n){let r=Pe(t),a=r.shape,i=a.length;return V(()=>{let{mean:s,variance:o}=Gy(r,this.axis,!0),l=ud(1,i);for(let f of this.axis)l[f]=a[f];let u=f=>null!=f&&f.shape.length!==i?B(f,l):f,c=this.scale?u(this.gamma.read()):null,h=this.center?u(this.beta.read()):null,d=[],p=[];for(let f=0;f<i;++f)-1!==this.axis.indexOf(f)?(d.push(a[f]),p.push(1)):(d.push(1),p.push(a[f]));return s=Ea(s,d),o=Ea(o,d),null!=c&&(c=Ea(c,p)),null!=h&&(h=Ea(h,p)),pv(r,s,o,h,c,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:gn(this.betaInitializer),gammaInitializer:gn(this.gammaInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}};return e.className="LayerNormalization",e})();ae.registerClass($8);var P8=(()=>{let e=class extends it{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new W(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if("number"==typeof t.padding[0])n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new W(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],2!==t.padding[1].length)throw new W(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(t){let n,r;return t=bt(t),"channelsFirst"===this.dataFormat?(n=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],n,r]):(n=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],n,r,t[3]])}call(t,n){return V(()=>function fDe(e,t,n){return V(()=>{if(4!==e.rank)throw new W(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new W("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new W(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Wi(e,r)})}(Pe(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}};return e.className="ZeroPadding2D",e})();function TI(e,t,n,r,a,i){return V(()=>{bn(a),W6(i),Ya(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=pA(e,a);let s,o="same"===r?"same":"valid";return s="max"===i?rr(e,t,n,o):ao(e,t,n,o),"channelsFirst"===a&&(s=tt(s,[0,3,1,2])),s})}function L8(e,t,n,r,a,i){return V(()=>{bn(a),W6(i),Ya(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=e8(e,a);let s,o="same"===r?"same":"valid";return s="max"===i?CT(e,t,n,o):YN(e,t,n,o),"channelsFirst"===a&&(s=tt(s,[0,4,1,2,3])),s})}ae.registerClass(P8);var z8=class extends it{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new W(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(ar(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new W(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}ar(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Ya(this.padding),this.inputSpec=[new Dn({ndim:3})]}computeOutputShape(e){let t=Zi((e=bt(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return V(()=>{this.invokeCallHook(e,t),e=tv(Pe(e),2);let n=this.poolingFunction(Pe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ol(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},wA=class extends z8{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return bn(a),Ya(r),TI(e,t,n,r,a,"max")}};wA.className="MaxPooling1D",ae.registerClass(wA);var B8=(()=>{let e=class extends z8{constructor(t){super(t)}poolingFunction(t,n,r,a,i){return bn(i),Ya(a),TI(t,n,r,a,i,"avg")}};return e.className="AveragePooling1D",e})();ae.registerClass(B8);var V8=class extends it{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new W(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ar(this.poolSize,"poolSize"),ar(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,bn(this.dataFormat),Ya(this.padding),this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(e){e=bt(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Zi(t,this.poolSize[0],this.padding,this.strides[0]),n=Zi(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Pe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},xA=class extends V8{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return bn(a),Ya(r),TI(e,t,n,r,a,"max")}};xA.className="MaxPooling2D",ae.registerClass(xA);var U8=(()=>{let e=class extends V8{constructor(t){super(t)}poolingFunction(t,n,r,a,i){return bn(i),Ya(a),TI(t,n,r,a,i,"avg")}};return e.className="AveragePooling2D",e})();ae.registerClass(U8);var W8=class extends it{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new W(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ar(this.poolSize,"poolSize"),ar(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,bn(this.dataFormat),Ya(this.padding),this.inputSpec=[new Dn({ndim:5})]}computeOutputShape(e){e=bt(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Zi(t,this.poolSize[0],this.padding,this.strides[0]),n=Zi(n,this.poolSize[1],this.padding,this.strides[1]),r=Zi(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Pe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},IA=class extends W8{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return bn(a),Ya(r),L8(e,t,n,r,a,"max")}};IA.className="MaxPooling3D",ae.registerClass(IA);var j8=(()=>{let e=class extends W8{constructor(t){super(t)}poolingFunction(t,n,r,a,i){return bn(i),Ya(a),L8(t,n,r,a,i,"avg")}};return e.className="AveragePooling3D",e})();ae.registerClass(j8);var H8=class extends it{constructor(e){super(e),this.inputSpec=[new Dn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new nt}},SA=class extends H8{constructor(e){super(e||{})}call(e,t){return V(()=>{let n=Pe(e);return fn(n,1)})}};SA.className="GlobalAveragePooling1D",ae.registerClass(SA);var G8=(()=>{let e=class extends H8{constructor(t){super(t||{})}call(t,n){return V(()=>{let r=Pe(t);return Ka(r,1)})}};return e.className="GlobalMaxPooling1D",e})();ae.registerClass(G8);var q8=class extends it{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,bn(this.dataFormat),this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new nt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},_A=class extends q8{call(e,t){return V(()=>{let n=Pe(e);return fn(n,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}};_A.className="GlobalAveragePooling2D",ae.registerClass(_A);var K8=(()=>{let e=class extends q8{call(t,n){return V(()=>{let r=Pe(t);return Ka(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}};return e.className="GlobalMaxPooling2D",e})();ae.registerClass(K8);var X8=class extends it{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=Ki(t.layer,n);delete t.layer;let i={layer:a};return Object.assign(i,t),new e(i)}},CA=class extends X8{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=bt(e)).length<3)throw new W(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=bt(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t);return[n[0],e[1]].concat(n.slice(1))}call(e,t){return V(()=>d8((n,r)=>[Pe(this.layer.call(n,t)),[]],e=Pe(e),[],!1,null,null,!1,!0)[1])}};CA.className="TimeDistributed",ae.registerClass(CA);var EA=class extends X8{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ki(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ki(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function mDe(e){dd(tNe,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let n=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let n,r,a,t=this.forwardLayer.computeOutputShape(e);return Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),this.returnState&&(a=t.slice(1)),n=t[0],"concat"===this.mergeMode?(n[n.length-1]*=2,r=[n]):r=null==this.mergeMode?[n,n.slice()]:[n],this.returnState?null==this.mergeMode?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):sa(r)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=c8(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let i=[],s=[];if(null!=n){let l=n.length;if(l%2>0)throw new W("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);let u=n.map(c=>new Dn({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),s.push(...u)}if(null!=r)throw new nt("Support for constants in Bidirectional layers is not implemented yet.");let o=i[0]instanceof qi;for(let l of i)if(l instanceof qi!==o)throw new W("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(i),u=this.inputSpec.concat(s),c=this.inputSpec;this.inputSpec=u;let h=super.apply(l,t);return this.inputSpec=c,h}return super.apply(e,t)}call(e,t){return V(()=>{let r,a,i,s,n=t.initialState;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}return this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Xa(a,1)),"concat"===this.mergeMode?s=TD([r,a]):"sum"===this.mergeMode?s=J(r,a):"ave"===this.mergeMode?s=z(.5,J(r,a)):"mul"===this.mergeMode?s=z(r,a):null==this.mergeMode&&(s=[r,a]),this.returnState?null==this.mergeMode?s.concat(i):[s].concat(i):s})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){hd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),hd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ki(t.layer);if(delete t.layer,null!=t.numConstants)throw new nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};EA.className="Bidirectional",ae.registerClass(EA);var Z8=(()=>{let e=class extends it{constructor(t){super(t),this.scale=t.scale,this.offset=t.offset?t.offset:0}getConfig(){let t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return V(()=>("float32"!==(t=Pe(t)).dtype&&(t=co(t,"float32")),J(z(t,this.scale),this.offset)))}};return e.className="Rescaling",e})();ae.registerClass(Z8);var{resizeBilinear:yDe,cropAndResize:vDe}=Za,kA=class extends it{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,i,s,o){return V(()=>{let l,u=!1,f=[t/i,n/s,(r+t)/i,(a+n)/s],m=[];3===e.rank?(u=!0,l=Tn([e])):l=e;for(let b=0;b<l.shape[0];b++)m.push(f);let g=$r(m,[m.length,4]),y=id(0,m.length,1,"int32"),v=vDe(l,g,y,[r,a],"nearest");return co(u?Pe(vn(v)):v,o)})}upsize(e,t,n,r){return V(()=>co(yDe(e,[t,n]),r))}call(e,t){return V(()=>{let n=Pe(e),r=n.dtype,a=n.shape,i=a[a.length-3],s=a[a.length-2],o=0;i!==this.height&&(o=Math.floor((i-this.height)/2));let l=0;return s!==this.width&&(l=Math.floor((s-this.width)/2),0===l&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,i,s,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let n=(e=bt(e)).length-2;return e[e.length-3]=this.height,e[n]=this.width,e}};kA.className="CenterCrop",ae.registerClass(kA);var Y8=(()=>{let e=class extends it{constructor(t){super(t),this.numTokens=t.numTokens,this.outputMode=t.outputMode?t.outputMode:"multiHot"}getConfig(){let t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return null==(t=bt(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return V(()=>{let r;if("int32"!==(t=Pe(t)).dtype&&(t=co(t,"int32")),typeof n.countWeights<"u"){if("count"!==this.outputMode)throw new W(`countWeights is not used when outputMode !== count.\n              Received countWeights=${n.countWeights}`);r=Pe(n.countWeights)}let a=Ka(t),i=yf(t),s=zr(this.numTokens,a).bufferSync().get(0),o=so(i,0).bufferSync().get(0);if(!s||!o)throw new W(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function bDe(e,t,n,r){let a=Pe(e);if("int32"!==a.dtype&&(a=co(a,"int32")),"int"===t)return a;let i=a.shape;if(0===a.rank&&(a=nr(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=nr(a,-1)),a.rank>2)throw new W(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${a.rank}.`);let l,s=["multiHot","oneHot"].includes(t);if(l=R0(a,typeof r<"u"&&"count"===t?r:[],n,s),"tfIdf"!==t)return l;if(r)return z(l,r);throw new W("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,r)})}};return e.className="CategoryEncoding",e})();ae.registerClass(Y8);var Q8=new Set(["bilinear","nearest"]),NA=class extends it{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!Q8.has(e.interpolation))throw new W(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=bt(e),[this.height,this.width,e[2]]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return V(()=>{let n=[this.height,this.width];if("bilinear"===this.interpolation)return Za.resizeBilinear(e,n,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Za.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Q8]} are supported`)})}};NA.className="Resizing",ae.registerClass(NA);var xDe=(()=>{let e=class{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}};return e.className="RandomSeed",e})(),IDe=(()=>{let e=class extends it{constructor(t){super(t),this.randomGenerator=new xDe(t.seed)}getConfig(){let t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}};return e.className="BaseRandomLayer",e})(),J8=new Set(["bilinear","nearest"]),TA=class extends IDe{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new W(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new W(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new W(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!J8.has(n))throw new W(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=bt(e),[this.imgHeight,-1,e[2]]}call(e,t){return V(()=>{let n=Pe(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=il([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);let i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Za.resizeBilinear(e,i);case"nearest":return Za.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...J8]} are supported`)}})}};function _De(e){return new av(e)}function CDe(e){return new Y5(e)}function EDe(e){return new K5(e)}function kDe(e){return new X5(e)}function NDe(e){return new Z5(e)}function TDe(e){return new J5(e)}function DDe(e){return new Q5(e)}function ADe(e){return new s8(e)}function MDe(e){return new EI(e)}function RDe(e){return new r8(e)}function FDe(e){return new fA(e)}function ODe(e){return new a8(e)}function $De(e){return new i8(e)}function PDe(e){return new o8(e)}function LDe(e){return new l8(e)}function zDe(e){return new u8(e)}function BDe(e){return new w8(e)}function VDe(e){return new v8(e)}function UDe(e){return new vA(e)}function WDe(e){return new y8(e)}function jDe(e){return new b8(e)}function HDe(e){return new x8(e)}function GDe(e){return new I8(e)}function qDe(e){return new S8(e)}function KDe(e){return new C8(e)}function XDe(e){return new bA(e)}function ZDe(e){return new k8(e)}function YDe(e){return new D8(e)}function QDe(e){return new N8(e)}function JDe(e){return new T8(e)}function eAe(e){return new E8(e)}function tAe(e){return new A8(e)}function nAe(e){return new O8(e)}function rAe(e){return new $8(e)}function aAe(e){return new P8(e)}function DA(e){return new B8(e)}function iAe(e){return DA(e)}function sAe(e){return DA(e)}function AA(e){return new U8(e)}function oAe(e){return AA(e)}function lAe(e){return AA(e)}function MA(e){return new j8(e)}function uAe(e){return MA(e)}function cAe(e){return MA(e)}function dAe(e){return new SA(e)}function hAe(e){return new _A(e)}function eq(e){return new G8(e)}function tq(e){return new K8(e)}function nq(e){return new wA(e)}function rq(e){return new xA(e)}function pAe(e){return new IA(e)}function fAe(e){return new p8(e)}function mAe(e){return new mA(e)}function gAe(e){return new f8(e)}function yAe(e){return new NI(e)}function vAe(e){return new h8(e)}function bAe(e){return new kI(e)}function wAe(e){return new g8(e)}function xAe(e){return new yA(e)}function IAe(e){return new gl(e)}function SAe(e){return new gA(e)}function _Ae(e){return new EA(e)}function CAe(e){return new CA(e)}TA.className="RandomWidth",ae.registerClass(TA);var EAe=eq,kAe=tq,NAe=nq,TAe=rq;function DAe(e){return new M8(e)}function AAe(e){return new R8(e)}function MAe(e){return new F8(e)}function RAe(e){return new _8(e)}function FAe(e){return new Z8(e)}function OAe(e){return new kA(e)}function $Ae(e){return new NA(e)}function PAe(e){return new Y8(e)}function LAe(e){return new TA(e)}var aq={};function zAe(e,t){return KD(e,t)}function BAe(e,t){return N5(e,t)}function VAe(e,t){return T5(e,t)}function UAe(e,t){return XD(e,t)}function WAe(e,t){return ZD(e,t)}function jAe(e,t){return k5(e,t)}function HAe(e,t){return function oTe(e,t){return V(()=>{let n=E5(e,t),r=function iTe(e,t){return V(()=>de(xe(gi(Ca(e,1),Ca(t,0))),"float32"))}(e,t),a=J(n,r);return de(tr(zr(a,0),ve(n,a),0),"float32")})}(e,t)}function GAe(e,t){return GD(e,t)}function qAe(e,t){return vI(e,t)}function KAe(e,t){return Ff(e,t)}function XAe(e,t){return Ff(e,t)}function ZAe(e,t){return Ff(e,t)}function YAe(e,t){return fd(e,t)}function QAe(e,t){return fd(e,t)}function JAe(e,t){return fd(e,t)}je(aq,{MAPE:()=>XAe,MSE:()=>QAe,binaryAccuracy:()=>zAe,binaryCrossentropy:()=>BAe,categoricalAccuracy:()=>UAe,categoricalCrossentropy:()=>WAe,cosineProximity:()=>GAe,mape:()=>ZAe,meanAbsoluteError:()=>qAe,meanAbsolutePercentageError:()=>KAe,meanSquaredError:()=>YAe,mse:()=>JAe,precision:()=>jAe,recall:()=>HAe,sparseCategoricalAccuracy:()=>VAe});var iq={};je(iq,{modelFromJSON:()=>LTe});var sq={};function eMe(e){return new cv(e)}function tMe(e){return function rDe(e){return hA(e),new cv({l1:null!=e?e.l1:null,l2:0})}(e)}function nMe(e){return function aDe(e){return hA(e),new cv({l2:null!=e?e.l2:null,l1:0})}(e)}je(sq,{l1:()=>tMe,l1l2:()=>eMe,l2:()=>nMe});var oq=class extends Rf{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ho))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function DI(e,t){return e<t}function lq(e,t){return e>t}var Da,cq,uq=class extends oq{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new nt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.monitorFunc="min"===this.mode?DI:"max"===this.mode||-1!==this.monitor.indexOf("acc")?lq:DI,this.monitorFunc===DI&&(this.minDelta*=-1)}onTrainBegin(e){var t=this;return F(function*(){t.wait=0,t.stoppedEpoch=0,t.best=null!=t.baseline?t.baseline:t.monitorFunc===DI?1/0:-1/0})()}onEpochEnd(e,t){var n=this;return F(function*(){yield pl(t);let r=n.getMonitorValue(t);null!=r&&(n.monitorFunc(r-n.minDelta,n.best)?(n.best=r,n.wait=0):(n.wait++,n.wait>=n.patience&&(n.stoppedEpoch=e,n.model.stopTraining=!0)))})()}onTrainEnd(e){var t=this;return F(function*(){t.stoppedEpoch>0&&t.verbose&&console.log(`Epoch ${t.stoppedEpoch}: early stopping.`)})()}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}},aMe={earlyStopping:function rMe(e){return new uq(e)}};H().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Da||(Da={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(cq||(cq={}));var RA={};function sMe(e,t){RA[e]={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t}}function dq(e){return RA[e]}function oMe(e){delete RA[e]}function S(e,t,n,r,a){let i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){let o=i.inputIndexStart,l=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?o+1:i.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if("tensor"===i.type)return pr(t.inputNames[u],n,r,a);if("tensors"===i.type){let d=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((p,f)=>{var m;return"NoOp"!==(null===(m=d[f])||void 0===m?void 0:m.op)}).map(p=>pr(p,n,r,a))}let c=pr(t.inputNames[u],n,r,a),h=c.dataSync();return"number"===i.type?h[0]:I.toNestedArray(c.shape,h)}let s=t.attrParams[e];return s&&s.value}function pr(e,t,n,r){let[a,i]=Aa(e,n);if(null!=r){let o=r.getHashTableHandleByName(a);if(null!=o)return o}let s=n.currentContextIds.find(o=>!!t[AI(a,o)]);return void 0!==s?t[AI(a,s)][i]:void 0}function hq(e,t,n){return t[AI(e,n.currentContextId)]}function po(e,t){let[n,r,a]=Aa(e,t);return[AI(n,t&&t.currentContextId),r,a]}function AI(e,t){return t?`${e}-${t}`:e}function Aa(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let i=t.parseNodeNameCache.get(e);if(null!=i)return i}let a,r=e.split(":");if(1===r.length)a=[e,0,void 0];else{let s=3===r.length?r[1]:void 0;a=[r[0],Number(r[r.length-1]),s]}return n&&t.parseNodeNameCache.set(e,a),a}function MI(e,t,n){let r=S("pad",e,t,n);if("explicit"===r){r=S("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)a[i][0]=r[2*i],a[i][1]=r[2*i+1];return a}return r}function fo(e){return e.kept?e:vs(e)}var pq={};je(pq,{json:()=>lMe});var lMe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fq={};je(fq,{json:()=>uMe});var uMe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mq={};je(mq,{json:()=>cMe});var cMe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],gq={};je(gq,{json:()=>dMe});var dMe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],yq={};je(yq,{json:()=>hMe});var hMe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],vq={};je(vq,{json:()=>pMe});var pMe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bq={};je(bq,{json:()=>fMe});var fMe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],wq={};je(wq,{json:()=>mMe});var mMe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],xq={};je(xq,{json:()=>gMe});var gMe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Iq={};je(Iq,{json:()=>yMe});var yMe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Sq={};je(Sq,{json:()=>vMe});var vMe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],_q={};je(_q,{json:()=>bMe});var bMe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Cq={};je(Cq,{json:()=>wMe});var wMe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Eq={};je(Eq,{json:()=>xMe});var xMe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],kq={};je(kq,{json:()=>IMe});var IMe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Nq={};je(Nq,{json:()=>SMe});var SMe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Tq={};je(Tq,{json:()=>_Me});var _Me=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Dq={};je(Dq,{json:()=>CMe});var CMe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Aq={};je(Aq,{json:()=>EMe});var EMe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Mq=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[].concat(...[pq,fq,mq,gq,yq,vq,bq,wq,xq,Iq,Sq,_q,Cq,Eq,kq,Nq,Tq,Dq,Aq].map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let r=[],a=[],i=[],s=e.node.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):"Const"===m.op?a.push(f[m.name]):(null==m.input||0===m.input.length)&&i.push(f[m.name]),f),{}),o=[],l=[],u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let h=Object.keys(s);h.forEach(f=>{let m=s[f];m.inputNames.forEach((g,y)=>{let[v,,b]=po(g),w=s[v];if(null!=w.outputs){let x=w.outputs.indexOf(b);-1!==x&&(m.inputNames[y]=`${v}:${x}`)}m.inputs.push(w),w.children.push(m)})}),0===Object.keys(c).length?h.forEach(f=>{let m=s[f];0===m.children.length&&l.push(m)}):Object.keys(c).forEach(f=>{let[m]=po(f),g=s[m];null!=g&&(g.signatureKey=c[f],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(f=>{let[m]=po(f),g=s[m];g&&(g.signatureKey=u[f],o.push(g))}):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:s,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return i.length>0&&(p.initNodes=i),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=dq(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((r,a)=>{let s,i=a.type;switch(a.type){case"string":s=FA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=FA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=UA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=UA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=$A(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=$A(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=VA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=VA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=OA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=OA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=jA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=jA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=BA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=BA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=WA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=WA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=LA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=LA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=zA(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=zA(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=Fq(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Fq(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:s,type:i},r},{})),n}mapFunction(e){let t=e.nodeDef,r=[],a={};null!=t&&(a=t.reduce((u,c)=>(u[c.name]=this.mapNode(c),"Const"===c.op&&r.push(u[c.name]),u),{}));let i=[],s=[];e.signature.inputArg.forEach(u=>{let[c]=po(u.name),h={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:PA(u.type),type:"dtype"}},children:[]};h.signatureKey=u.name,i.push(h),a[c]=h}),Object.keys(a).forEach(u=>{let c=a[u];c.inputNames.forEach((h,d)=>{let[p,,f]=po(h),m=a[p];if(null!=m.outputs){let g=m.outputs.indexOf(f);-1!==g&&(c.inputNames[d]=`${p}:${g}`)}c.inputs.push(m),m.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[c,h]=po(o[u.name]),d=a[c];null!=d&&(d.defaultOutput=h,s.push(d))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:i,outputs:s,weights:r,placeholders:[],signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function Rq(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function kMe(e){let t=H().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function FA(e,t,n,r=!1){let a=e[t];return null!=a?Rq(a.s,r):n}function OA(e,t,n){let r=e[t];return r?r.b:n}function $A(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function PA(e){switch("string"==typeof e&&(e=Da[e]),e){case Da.DT_FLOAT:case Da.DT_HALF:return"float32";case Da.DT_INT32:case Da.DT_INT64:case Da.DT_INT8:case Da.DT_UINT8:return"int32";case Da.DT_BOOL:return"bool";case Da.DT_DOUBLE:return"float32";case Da.DT_STRING:return"string";case Da.DT_COMPLEX64:case Da.DT_COMPLEX128:return"complex64";default:return null}}function Fq(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function LA(e,t,n){let r=e[t];return r&&r.type?PA(r.type):n}function zA(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>PA(a)):n}function Oq(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function BA(e,t,n){let r=e[t];return r&&r.shape?Oq(r.shape):n}function VA(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>"number"==typeof a?a:parseInt(a,10)):n}function UA(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(i=>Rq(i,r)):n}function WA(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>Oq(a)):n}function jA(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var NMe=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return pr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return pr(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return $A(this.node.rawAttrs,e,t);if(null!=n.s)return FA(this.node.rawAttrs,e,t);if(null!=n.b)return OA(this.node.rawAttrs,e,t);if(null!=n.shape)return BA(this.node.rawAttrs,e,t);if(null!=n.type)return LA(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return VA(this.node.rawAttrs,e,t);if(null!=n.list.s)return UA(this.node.rawAttrs,e,t);if(null!=n.list.shape)return WA(this.node.rawAttrs,e,t);if(null!=n.list.b)return jA(this.node.rawAttrs,e,t);if(null!=n.list.type)return zA(this.node.rawAttrs,e,t)}return t}},ir={};function bi(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){I.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],i=t[r];I.assert(a<0||i<0||a===i,()=>n+` Shapes ${e} and ${t} must match`)}}}function $q(e){return!("number"==typeof e||e.some(t=>t<0))}function fv(e,t,n){let r=HA(e,n),a=!$q(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(i=>{r=HA(i.shape,r)}),!$q(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function HA(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],i=t[r];if(a>=0&&i>=0&&a!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:i}return n}je(ir,{OP_SCOPE_SUFFIX:()=>wN,abs:()=>kn,acos:()=>VN,acosh:()=>UN,add:()=>J,addN:()=>PH,all:()=>N0,any:()=>Fy,argMax:()=>Xc,argMin:()=>WN,asin:()=>jN,asinh:()=>HN,atan:()=>GN,atan2:()=>qN,atanh:()=>KN,avgPool:()=>ao,avgPool3d:()=>YN,basicLSTMCell:()=>VH,batchNorm:()=>Qc,batchNorm2d:()=>QN,batchNorm3d:()=>JN,batchNorm4d:()=>eT,batchToSpaceND:()=>Ly,bincount:()=>tT,bitwiseAnd:()=>UH,booleanMaskAsync:()=>AG,broadcastArgs:()=>WH,broadcastTo:()=>Jc,buffer:()=>Je,cast:()=>de,ceil:()=>nT,clipByValue:()=>Sr,clone:()=>vs,complex:()=>to,concat:()=>zt,concat1d:()=>rT,concat2d:()=>aT,concat3d:()=>iT,concat4d:()=>sT,conv1d:()=>T0,conv2d:()=>Lr,conv2dTranspose:()=>D0,conv3d:()=>lT,conv3dTranspose:()=>uT,cos:()=>zy,cosh:()=>A0,cosineWindow:()=>tI,cumprod:()=>By,cumsum:()=>M0,denseBincount:()=>R0,depthToSpace:()=>cT,depthwiseConv2d:()=>ed,diag:()=>HH,dilation2d:()=>dT,div:()=>ve,divNoNan:()=>hT,dot:()=>pT,dropout:()=>KT,einsum:()=>td,elu:()=>gf,enclosingPowerOfTwo:()=>XT,ensureShape:()=>qH,equal:()=>Ca,erf:()=>fT,euclideanNorm:()=>yT,exp:()=>_r,expandDims:()=>nr,expm1:()=>vT,eye:()=>F0,fft:()=>Zy,fill:()=>_a,floor:()=>bf,floorDiv:()=>k0,fused:()=>Nf,gather:()=>wf,gatherND:()=>OG,greater:()=>zr,greaterEqual:()=>so,ifft:()=>kf,imag:()=>Vy,image:()=>Za,inTopKAsync:()=>$G,irfft:()=>K0,isFinite:()=>bT,isInf:()=>wT,isNaN:()=>xT,leakyRelu:()=>Uy,less:()=>xf,lessEqual:()=>rl,linalg:()=>nD,linspace:()=>QH,localResponseNormalization:()=>IT,log:()=>ka,log1p:()=>Wy,logSigmoid:()=>ST,logSoftmax:()=>$0,logSumExp:()=>jy,logicalAnd:()=>gi,logicalNot:()=>Hy,logicalOr:()=>P0,logicalXor:()=>_T,losses:()=>ZG,lowerBound:()=>eG,matMul:()=>et,max:()=>Ka,maxPool:()=>rr,maxPool3d:()=>CT,maxPoolWithArgmax:()=>tG,maximum:()=>xs,mean:()=>fn,meshgrid:()=>nG,min:()=>yf,minimum:()=>al,mirrorPad:()=>ET,mod:()=>kT,moments:()=>Gy,movingAverage:()=>MG,mul:()=>z,multiRNNCell:()=>rG,multinomial:()=>aG,neg:()=>Yt,norm:()=>vf,notEqual:()=>ad,oneHot:()=>If,ones:()=>aa,onesLike:()=>Na,op:()=>L,outerProduct:()=>iG,pad:()=>Wi,pad1d:()=>sG,pad2d:()=>oG,pad3d:()=>lG,pad4d:()=>uG,pool:()=>NT,pow:()=>io,prelu:()=>Ky,print:()=>BN,prod:()=>TT,raggedGather:()=>cG,raggedRange:()=>dG,raggedTensorToTensor:()=>hG,rand:()=>pG,randomGamma:()=>yG,randomNormal:()=>B0,randomStandardNormal:()=>vG,randomUniform:()=>il,randomUniformInt:()=>bG,range:()=>id,real:()=>Sf,reciprocal:()=>$T,relu:()=>Rt,relu6:()=>V0,reshape:()=>B,reverse:()=>Xa,reverse1d:()=>wG,reverse2d:()=>xG,reverse3d:()=>IG,reverse4d:()=>SG,rfft:()=>Yy,round:()=>U0,rsqrt:()=>W0,scalar:()=>ke,scatterND:()=>RG,searchSorted:()=>z0,selu:()=>j0,separableConv2d:()=>_f,setdiff1dAsync:()=>_G,sigmoid:()=>mi,sign:()=>LT,signal:()=>XG,sin:()=>H0,sinh:()=>G0,slice:()=>ct,slice1d:()=>Xy,slice2d:()=>q0,slice3d:()=>Cf,slice4d:()=>Ef,softmax:()=>sl,softplus:()=>rd,spaceToBatchND:()=>qy,sparse:()=>YG,sparseToDense:()=>FG,spectral:()=>KG,split:()=>ia,sqrt:()=>dr,square:()=>Vt,squaredDifference:()=>X0,squeeze:()=>ol,stack:()=>Tn,step:()=>sd,stridedSlice:()=>zT,string:()=>QG,sub:()=>ye,sum:()=>xe,tan:()=>BT,tanh:()=>Yc,tensor:()=>$r,tensor1d:()=>Tt,tensor2d:()=>Is,tensor3d:()=>Z0,tensor4d:()=>ll,tensor5d:()=>CG,tensor6d:()=>EG,tensorScatterUpdate:()=>NG,tile:()=>Ea,topk:()=>UT,transpose:()=>tt,truncatedNormal:()=>J0,unique:()=>WT,unsortedSegmentSum:()=>eI,unstack:()=>vn,upperBound:()=>TG,variable:()=>jT,where:()=>tr,whereAsync:()=>GT,zeros:()=>mn,zerosLike:()=>ft});var AMe=class{constructor(e,t,n,r,a,i,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=ke(0),Bn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),bi(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Bn(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(0===e.length)return $r([],[0].concat(this.elementShape));let n=this.readMany(e);return bi(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Tn(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return $r([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return bi(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),zt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,vn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,i=[];V(()=>{t=B(t,[1,n,a]);for(let o=0;o<e.length;++o)i[o]=B(ct(t,[0,0===o?0:r[o-1],0],[1,e[o],a]),this.elementShape);return i});let s=[];for(let o=0;o<e.length;o++)s[o]=o;this.writeMany(s,i)}},RI=class NO{get id(){return this.idTensor.id}constructor(t,n,r,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);bi(n,i.shape,"TensorList shape mismatch: "),Bn(i)}),this.idTensor=ke(0),this.maxNumElements=a,Bn(this.idTensor)}copy(){return new NO([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(null==t||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);bi(t,this.elementShape,"TensorList shape mismatch: ");let a=fv(this.elementShape,this.tensors,t);return V(()=>{let i=this.tensors.map(s=>B(s,a));return Tn(i,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let r=fv(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,bi(a.shape,t,"TensorList shape mismatch: "),B(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(bi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Bn(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new NO([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);bi(this.tensors[t].shape,n,"TensorList shape mismatch: ");let a=fv(this.elementShape,this.tensors,n);return B(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);bi(this.elementShape,n.shape,"TensorList shape mismatch: "),Bn(n),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);bi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let a=fv(this.elementShape,this.tensors,r);return 0===t.length?$r([],[0].concat(a)):V(()=>{let i=t.map(s=>B(this.tensors[s],a));return Tn(i,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);bi(this.elementShape,n,"TensorList shape mismatch: ");let r=fv(this.elementShape,this.tensors,n);return 0===this.size()?$r([],[0].concat(r)):V(()=>{let a=this.tensors.map(i=>B(i,r));return zt(a,0)})}},$Me=function(){var e=F(function*(t,n,r){switch(t.op){case"If":case"StatelessIf":{let a=S("thenBranch",t,n,r),i=S("elseBranch",t,n,r),s=S("cond",t,n,r),o=S("args",t,n,r);return(yield s.data())[0]?r.functionMap[a].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap):r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{let a=S("body",t,n,r),i=S("cond",t,n,r),s=S("args",t,n,r),o=yield r.functionMap[i].executeFunctionAsync(s,r.tensorArrayMap,r.tensorListMap),l=s.map(h=>h.id),u=yield o[0].data();o.forEach(h=>{!h.kept&&-1===l.indexOf(h.id)&&h.dispose()});let c=s;for(;u[0];){let h=c;c=yield r.functionMap[a].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);let d=c.map(f=>f.id);h.forEach(f=>{!f.kept&&-1===l.indexOf(f.id)&&-1===d.indexOf(f.id)&&f.dispose()});let p=yield r.functionMap[i].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield p[0].data(),p.forEach(f=>{!f.kept&&-1===l.indexOf(f.id)&&-1===d.indexOf(f.id)&&f.dispose()})}return c}case"LoopCond":return[fo(S("pred",t,n,r))];case"Switch":{let a=S("pred",t,n,r),i=S("data",t,n,r);return i.kept||(i=fo(i)),(yield a.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{let a=t.inputNames.find(i=>void 0!==pr(i,n,r));return a?[fo(pr(a,n,r))]:void 0}case"Enter":{let a=S("frameName",t,n,r),i=S("tensor",t,n,r);return r.enterFrame(a),[fo(i)]}case"Exit":{let a=S("tensor",t,n,r);return r.exitFrame(),[fo(a)]}case"NextIteration":{let a=S("tensor",t,n,r);return r.nextIteration(),[fo(a)]}case"TensorArrayV3":{let a=S("size",t,n,r),i=S("dtype",t,n,r),s=S("elementShape",t,n,r),o=S("dynamicSize",t,n,r),l=S("clearAfterRead",t,n,r),u=S("identicalElementShapes",t,n,r),c=S("name",t,n,r),h=new AMe(c,i,a,s,u,o,l);return r.addTensorArray(h),[h.idTensor,ke(1)]}case"TensorArrayWriteV3":{let a=S("tensorArrayId",t,n,r),i=S("index",t,n,r),s=S("tensor",t,n,r),o=r.getTensorArray(a.id);return o.write(i,s),[o.idTensor]}case"TensorArrayReadV3":{let a=S("tensorArrayId",t,n,r),i=S("index",t,n,r);return[r.getTensorArray(a.id).read(i)]}case"TensorArrayGatherV3":{let a=S("tensorArrayId",t,n,r),i=S("indices",t,n,r),s=S("dtype",t,n,r);return[r.getTensorArray(a.id).gather(i,s)]}case"TensorArrayScatterV3":{let a=S("tensorArrayId",t,n,r),i=S("indices",t,n,r),s=S("tensor",t,n,r),o=r.getTensorArray(a.id);return o.scatter(i,s),[o.idTensor]}case"TensorArrayConcatV3":{let a=S("tensorArrayId",t,n,r),i=r.getTensorArray(a.id),s=S("dtype",t,n,r);return[i.concat(s)]}case"TensorArraySplitV3":{let a=S("tensorArrayId",t,n,r),i=S("tensor",t,n,r),s=S("lengths",t,n,r),o=r.getTensorArray(a.id);return o.split(s,i),[o.idTensor]}case"TensorArraySizeV3":{let a=S("tensorArrayId",t,n,r);return[ke(r.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{let a=S("tensorArrayId",t,n,r),i=r.getTensorArray(a.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{let a=S("tensorListId",t,n,r),i=S("index",t,n,r),s=S("tensor",t,n,r),o=r.getTensorList(a.id);return o.setItem(i,s),[o.idTensor]}case"TensorListGetItem":{let a=S("tensorListId",t,n,r),i=S("index",t,n,r),s=S("elementShape",t,n,r),o=S("elementDType",t,n,r);return[r.getTensorList(a.id).getItem(i,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{let a=S("indices",t,n,r),l=function FMe(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let i=new RI([],n,e.dtype,r),s=vn(e,0);return t.forEach((o,l)=>{i.setItem(o,s[l])}),i}(S("tensor",t,n,r),a,S("elementShape",t,n,r),S("numElements",t,n,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let s,a=S("elementShape",t,n,r),i=S("elementDType",t,n,r);s="TensorListReserve"===t.op?"numElements":"maxNumElements";let o=S(s,t,n,r),u=function RMe(e,t,n,r){return new RI([],e,t,r)}(a,i,0,"TensorListReserve"===t.op?-1:o);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{let a=S("tensorListId",t,n,r),i=S("indices",t,n,r),s=S("elementShape",t,n,r),o=S("elementDType",t,n,r);return[r.getTensorList(a.id).gather(i,o,s)]}case"TensorListStack":{let a=S("tensorListId",t,n,r),i=S("elementShape",t,n,r),s=S("elementDType",t,n,r),o=S("numElements",t,n,r);return[r.getTensorList(a.id).stack(i,s,o)]}case"TensorListFromTensor":{let o=function MMe(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);bi(e.shape.slice(1),t,"TensorList shape mismatch: ");let i=vn(e);return new RI(i,t,r)}(S("tensor",t,n,r),S("elementShape",t,n,r),S("elementDType",t,n,r));return r.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=S("tensorListId",t,n,r),i=r.getTensorList(a.id),s=S("dtype",t,n,r),o=S("elementShape",t,n,r);return[i.concat(s,o)]}case"TensorListPushBack":{let a=S("tensorListId",t,n,r),i=S("tensor",t,n,r),s=r.getTensorList(a.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{let a=S("tensorListId",t,n,r),i=S("elementShape",t,n,r),s=S("elementDType",t,n,r);return[r.getTensorList(a.id).popBack(i,s)]}case"TensorListSplit":{let a=S("tensor",t,n,r),i=S("elementShape",t,n,r),o=function OMe(e,t,n){let r=0,a=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=HA(e.shape.slice(1),n),o=0===r?0:e.size/r,l=V(()=>{let c=[];e=B(e,[1,r,o]);for(let h=0;h<t.length;++h)c[h]=B(ct(e,[0,0===h?0:a[h-1],0],[1,t[h],o]),s);return e.dispose(),c}),u=new RI([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(a,S("lengths",t,n,r),i);return r.addTensorList(o),[o.idTensor]}case"TensorListLength":{let a=S("tensorListId",t,n,r);return[ke(r.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{let a=S("tensorListId",t,n,r),i=S("size",t,n,r),s=r.getTensorList(a.id).resize(i);return r.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(n,r,a){return e.apply(this,arguments)}}();function Pq(e,t,n){let[r,a]=S("fusedOps",e,t,n),i="biasadd"===r,s=!i,o="prelu"===a,l="fusedbatchnorm"===r,u=S("numArgs",e,t,n);if(i){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=S("strides",e,t,n),h=MI(e,t,n),d=S("dataFormat",e,t,n).toUpperCase(),p=S("dilations",e,t,n),[f,m]=S("args",e,t,n);return s&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:S("leakyreluAlpha",e,t,n)}}function GA(e,t,n){return{boxes:S("boxes",e,t,n),scores:S("scores",e,t,n),maxOutputSize:S("maxOutputSize",e,t,n),iouThreshold:S("iouThreshold",e,t,n),scoreThreshold:S("scoreThreshold",e,t,n),softNmsSigma:S("softNmsSigma",e,t,n)}}var zMe=function(){var e=F(function*(t,n,r,a,i=ir){switch(t.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:h}=GA(t,n,r),d=yield i.image.nonMaxSuppressionWithScoreAsync(s,o,l,u,c,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=GA(t,n,r),h=S("padToMaxOutputSize",t,n,r),d=yield i.image.nonMaxSuppressionPaddedAsync(s,o,l,u,c,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=GA(t,n,r);return[yield i.image.nonMaxSuppressionAsync(s,o,l,u,c)]}case"Where":{let s=i.cast(S("condition",t,n,r),"bool"),o=[yield i.whereAsync(s)];return s.dispose(),o}case"ListDiff":return i.setdiff1dAsync(S("x",t,n,r),S("y",t,n,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(n,r,a,i){return e.apply(this,arguments)}}(),UMe=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ke(0),this.tensorMap=new Map,Bn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ke(this.size(),"int32")}import(e,t){var n=this;return F(function*(){n.checkKeyAndValueTensor(e,t);let r=yield e.data();return n.tensorMap.forEach(a=>a.dispose()),n.tensorMap.clear(),V(()=>{let a=vn(t),i=r.length,s=a.length;I.assert(i===s,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${s} elements.`);for(let o=0;o<i;o++){let l=r[o],u=a[o];Bn(u),n.tensorMap.set(l,u)}return n.handle})})()}find(e,t){var n=this;return F(function*(){n.checkKeyAndValueTensor(e,t);let r=yield e.data();return V(()=>{let a=[];for(let i=0;i<r.length;i++){let o=n.findWithDefault(r[i],t);a.push(o)}return Tn(a)})})()}findWithDefault(e,t){return this.tensorMap.get(e)??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},WMe=function(){var e=F(function*(t,n,r,a){switch(t.op){case"HashTable":case"HashTableV2":{let i=a.getHashTableHandleByName(t.name);if(null!=i)return[i];{let s=S("keyDType",t,n,r),o=S("valueDType",t,n,r),l=new UMe(s,o);return a.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let i=S("tableHandle",t,n,r,a),s=S("keys",t,n,r),o=S("values",t,n,r);return[yield a.getHashTableById(i.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{let i=S("tableHandle",t,n,r,a),s=S("keys",t,n,r),o=S("defaultValue",t,n,r);return[yield a.getHashTableById(i.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let i=S("tableHandle",t,n,r,a);return[a.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(n,r,a,i){return e.apply(this,arguments)}}();function Lq(e,t,n,r,a=V){let i=((s,o,l)=>{switch(s.category){case"arithmetic":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(S("a",e,t,n),S("b",e,t,n))];case"AddN":return[r.addN(S("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(S("a",e,t,n),S("b",e,t,n))];case"Mul":return[r.mul(S("a",e,t,n),S("b",e,t,n))];case"RealDiv":case"Div":return[r.div(S("a",e,t,n),S("b",e,t,n))];case"DivNoNan":return[r.divNoNan(S("a",e,t,n),S("b",e,t,n))];case"FloorDiv":return[r.floorDiv(S("a",e,t,n),S("b",e,t,n))];case"Sub":return[r.sub(S("a",e,t,n),S("b",e,t,n))];case"Minimum":return[r.minimum(S("a",e,t,n),S("b",e,t,n))];case"Maximum":return[r.maximum(S("a",e,t,n),S("b",e,t,n))];case"Pow":return[r.pow(S("a",e,t,n),S("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"basic_math":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(S("x",e,t,n))];case"Acos":return[r.acos(S("x",e,t,n))];case"Acosh":return[r.acosh(S("x",e,t,n))];case"Asin":return[r.asin(S("x",e,t,n))];case"Asinh":return[r.asinh(S("x",e,t,n))];case"Atan":return[r.atan(S("x",e,t,n))];case"Atan2":return[r.atan2(S("x",e,t,n),S("y",e,t,n))];case"Atanh":return[r.atanh(S("x",e,t,n))];case"Ceil":return[r.ceil(S("x",e,t,n))];case"Complex":return[r.complex(S("real",e,t,n),S("imag",e,t,n))];case"Cos":return[r.cos(S("x",e,t,n))];case"Cosh":return[r.cosh(S("x",e,t,n))];case"Elu":return[r.elu(S("x",e,t,n))];case"Erf":return[r.erf(S("x",e,t,n))];case"Exp":return[r.exp(S("x",e,t,n))];case"Expm1":return[r.expm1(S("x",e,t,n))];case"Floor":return[r.floor(S("x",e,t,n))];case"Log":return[r.log(S("x",e,t,n))];case"Log1p":return[r.log1p(S("x",e,t,n))];case"Imag":return[r.imag(S("x",e,t,n))];case"Neg":return[r.neg(S("x",e,t,n))];case"Reciprocal":return[r.reciprocal(S("x",e,t,n))];case"Real":return[r.real(S("x",e,t,n))];case"Relu":return[r.relu(S("x",e,t,n))];case"Round":return[r.round(S("x",e,t,n))];case"Selu":return[r.selu(S("x",e,t,n))];case"Sigmoid":return[r.sigmoid(S("x",e,t,n))];case"Sin":return[r.sin(S("x",e,t,n))];case"Sign":return[r.sign(S("x",e,t,n))];case"Sinh":return[r.sinh(S("x",e,t,n))];case"Softplus":return[r.softplus(S("x",e,t,n))];case"Sqrt":return[r.sqrt(S("x",e,t,n))];case"Square":return[r.square(S("x",e,t,n))];case"Tanh":return[r.tanh(S("x",e,t,n))];case"Tan":return[r.tan(S("x",e,t,n))];case"ClipByValue":return[r.clipByValue(S("x",e,t,n),S("clipValueMin",e,t,n),S("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(S("x",e,t,n))];case"Rsqrt":return[r.rsqrt(pr(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(S("x",e,t,n),S("alpha",e,t,n))];case"Prelu":return[r.prelu(S("x",e,t,n),S("alpha",e,t,n))];case"IsNan":return[r.isNaN(pr(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(pr(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(pr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"control":return $Me(s,o,l);case"convolution":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Conv1D":{let a=S("stride",e,t,n),i=S("pad",e,t,n),s=S("dataFormat",e,t,n).toUpperCase(),o=S("dilation",e,t,n);return[r.conv1d(S("x",e,t,n),S("filter",e,t,n),a,i,s,o)]}case"Conv2D":{let a=S("strides",e,t,n),i=MI(e,t,n),s=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv2d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2]],i,s,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:i,dataFormat:s,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Pq(e,t,n);return[r.fused.conv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:i,dataFormat:s,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Pq(e,t,n);return[r.fused.depthwiseConv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:s,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=S("outputShape",e,t,n),i=S("strides",e,t,n),s=MI(e,t,n);return[r.conv2dTranspose(S("x",e,t,n),S("filter",e,t,n),a,[i[1],i[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=S("strides",e,t,n),i=MI(e,t,n),s=S("dilations",e,t,n),o=S("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(S("input",e,t,n),S("filter",e,t,n),[a[1],a[2]],i,o,[s[1],s[2]])]}case"Conv3D":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv3d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2],a[3]],i,s,[o[1],o[2],o[3]])]}case"AvgPool":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("kernelSize",e,t,n);return[r.avgPool(S("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i)]}case"MaxPool":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("kernelSize",e,t,n);return[r.maxPool(S("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i)]}case"MaxPoolWithArgmax":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("kernelSize",e,t,n),o=S("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(S("x",e,t,n),[s[1],s[2]],[a[1],a[2]],i,o);return[l,u]}case"AvgPool3D":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("kernelSize",e,t,n);return[r.avgPool3d(S("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],i)]}case"MaxPool3D":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("kernelSize",e,t,n);return[r.maxPool3d(S("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],i)]}case"Dilation2D":{let a=S("strides",e,t,n),i=S("pad",e,t,n),s=S("dilations",e,t,n),o=a[1],l=a[2],u=s[1],c=s[2];return[r.dilation2d(S("x",e,t,n),S("filter",e,t,n),[o,l],i,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"creation":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Fill":{let a=S("shape",e,t,n),i=S("dtype",e,t,n),s=S("value",e,t,n);return[r.fill(a,s,i)]}case"LinSpace":{let a=S("start",e,t,n),i=S("stop",e,t,n),s=S("num",e,t,n);return[r.linspace(a,i,s)]}case"Multinomial":{let a=S("logits",e,t,n),i=S("numSamples",e,t,n),s=S("seed",e,t,n);return[r.multinomial(a,i,s)]}case"OneHot":{let a=S("indices",e,t,n),i=S("depth",e,t,n),s=S("onValue",e,t,n),o=S("offValue",e,t,n),l=S("dtype",e,t,n);return[r.oneHot(a,i,s,o,l)]}case"Ones":return[r.ones(S("shape",e,t,n),S("dtype",e,t,n))];case"OnesLike":return[r.onesLike(S("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(S("shape",e,t,n),S("dtype",e,t,n),S("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("seed",e,t,n))];case"Range":{let a=S("start",e,t,n),i=S("stop",e,t,n),s=S("step",e,t,n);return[r.range(a,i,s,S("dtype",e,t,n))]}case"TruncatedNormal":{let a=S("shape",e,t,n),i=S("mean",e,t,n),s=S("stdDev",e,t,n),o=S("seed",e,t,n);return[r.truncatedNormal(a,i,s,S("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(S("shape",e,t,n),S("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"dynamic":return zMe(s,o,l);case"evaluation":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"LowerBound":{let a=S("sortedSequence",e,t,n),i=S("values",e,t,n);return[r.lowerBound(a,i)]}case"TopKV2":{let a=S("x",e,t,n),i=S("k",e,t,n),s=S("sorted",e,t,n),o=r.topk(a,i,s);return[o.values,o.indices]}case"UpperBound":{let a=S("sortedSequence",e,t,n),i=S("values",e,t,n);return[r.upperBound(a,i)]}case"Unique":{let a=S("x",e,t,n),i=r.unique(a);return[i.values,i.indices]}case"UniqueV2":{let a=S("x",e,t,n),i=S("axis",e,t,n),s=r.unique(a,i);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"image":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"ResizeBilinear":{let a=S("images",e,t,n),i=S("size",e,t,n),s=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[i[0],i[1]],s,o)]}case"ResizeNearestNeighbor":{let a=S("images",e,t,n),i=S("size",e,t,n),s=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[i[0],i[1]],s,o)]}case"CropAndResize":{let a=S("image",e,t,n),i=S("boxes",e,t,n),s=S("boxInd",e,t,n),o=S("cropSize",e,t,n),l=S("method",e,t,n),u=S("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,i,s,o,l,u)]}case"ImageProjectiveTransformV3":{let a=S("images",e,t,n),i=S("transforms",e,t,n),s=S("outputShape",e,t,n),o=S("fillValue",e,t,n),l=S("interpolation",e,t,n),u=S("fillMode",e,t,n);return[r.image.transform(a,i,l.toLowerCase(),u.toLowerCase(),o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"graph":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=S("default",e,t,n);return[pr(e.name,t,n)||a];case"Placeholder":return[pr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[fo(S("x",e,t,n))];case"IdentityN":return S("x",e,t,n).map(c=>fo(c));case"Shape":return[r.tensor1d(S("x",e,t,n).shape,"int32")];case"ShapeN":return S("x",e,t,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(S("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(S("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let s=S("x",e,t,n),o=S("data",e,t,n),l=S("message",e,t,n),u=S("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"logical":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Equal":return[r.equal(S("a",e,t,n),S("b",e,t,n))];case"NotEqual":return[r.notEqual(S("a",e,t,n),S("b",e,t,n))];case"Greater":return[r.greater(S("a",e,t,n),S("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(S("a",e,t,n),S("b",e,t,n))];case"Less":return[r.less(S("a",e,t,n),S("b",e,t,n))];case"LessEqual":return[r.lessEqual(S("a",e,t,n),S("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(S("a",e,t,n),S("b",e,t,n))];case"LogicalNot":return[r.logicalNot(S("a",e,t,n))];case"LogicalOr":return[r.logicalOr(S("a",e,t,n),S("b",e,t,n))];case"Select":case"SelectV2":return[r.where(S("condition",e,t,n),S("a",e,t,n),S("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"matrices":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(S("a",e,t,n),S("b",e,t,n),S("transposeA",e,t,n),S("transposeB",e,t,n))];case"Einsum":return[r.einsum(S("equation",e,t,n),...S("tensors",e,t,n))];case"Transpose":return[r.transpose(S("x",e,t,n),S("perm",e,t,n))];case"_FusedMatMul":let[a,i]=S("fusedOps",e,t,n),s="biasadd"===a,o="prelu"===i,l=S("numArgs",e,t,n),u=S("leakyreluAlpha",e,t,n);if(s){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,h]=S("args",e,t,n);return[r.fused.matMul({a:S("a",e,t,n),b:S("b",e,t,n),transposeA:S("transposeA",e,t,n),transposeB:S("transposeB",e,t,n),bias:c,activation:i,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(S("a",e,t,n),S("numLower",e,t,n),S("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"normalization":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(S("x",e,t,n),S("axis",e,t,n),S("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(S("x",e,t,n),S("mean",e,t,n),S("variance",e,t,n),S("offset",e,t,n),S("scale",e,t,n),S("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(S("x",e,t,n),S("radius",e,t,n),S("bias",e,t,n),S("alpha",e,t,n),S("beta",e,t,n))];case"Softmax":return[r.softmax(S("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"ragged":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:i}=r.raggedGather(S("paramsNestedSplits",e,t,n),S("paramsDenseValues",e,t,n),S("indices",e,t,n),S("outputRaggedRank",e,t,n));return a.concat(i)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:i}=r.raggedRange(S("starts",e,t,n),S("limits",e,t,n),S("splits",e,t,n));return[a,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(S("shape",e,t,n),S("values",e,t,n),S("defaultValue",e,t,n),S("rowPartitionTensors",e,t,n),S("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"reduction":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Max":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.max(S("x",e,t,n),o,l)]}case"Mean":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.mean(S("x",e,t,n),o,l)]}case"Min":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.min(S("x",e,t,n),o,l)]}case"Sum":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.sum(S("x",e,t,n),o,l)]}case"All":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.all(S("x",e,t,n),o,l)]}case"Any":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.any(S("x",e,t,n),o,l)]}case"ArgMax":{let o=S("axis",e,t,n);return[r.argMax(S("x",e,t,n),o)]}case"ArgMin":{let o=S("axis",e,t,n);return[r.argMin(S("x",e,t,n),o)]}case"Prod":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.prod(S("x",e,t,n),o,l)]}case"Cumprod":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),u=S("reverse",e,t,n);return[r.cumprod(S("x",e,t,n),o,l,u)]}case"Cumsum":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),u=S("reverse",e,t,n);return[r.cumsum(S("x",e,t,n),o,l,u)]}case"Bincount":let a=S("x",e,t,n),i=S("weights",e,t,n),s=S("size",e,t,n);return[r.bincount(a,i,s)];case"DenseBincount":{let o=S("x",e,t,n),l=S("weights",e,t,n),u=S("size",e,t,n),c=S("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"slice_join":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=S("n",e,t,n),i=S("axis",e,t,n),s=S("tensors",e,t,n);return s=s.slice(0,a),[r.concat(s,i)]}case"Gather":{let a=S("x",e,t,n),i=S("indices",e,t,n);return[r.gather(a,r.cast(i,"int32"),0)]}case"GatherV2":{let a=S("axis",e,t,n),i=S("batchDims",e,t,n),s=S("x",e,t,n),o=S("indices",e,t,n);return[r.gather(s,r.cast(o,"int32"),a,i)]}case"Reverse":{let a=S("dims",e,t,n),i=[];for(let o=0;o<a.length;o++)a[o]&&i.push(o);let s=S("x",e,t,n);return[r.reverse(s,i)]}case"ReverseV2":{let a=S("axis",e,t,n),i=S("x",e,t,n);return[r.reverse(i,a)]}case"Slice":{let a=S("begin",e,t,n),i=S("size",e,t,n);return[r.slice(S("x",e,t,n),a,i)]}case"StridedSlice":{let a=S("begin",e,t,n),i=S("end",e,t,n),s=S("strides",e,t,n),o=S("beginMask",e,t,n),l=S("endMask",e,t,n),u=S("ellipsisMask",e,t,n),c=S("newAxisMask",e,t,n),h=S("shrinkAxisMask",e,t,n),d=S("x",e,t,n);return[r.stridedSlice(d,a,i,s,o,l,u,c,h)]}case"Pack":return V(()=>{let a=S("axis",e,t,n),i=S("tensors",e,t,n),s=i[0].shape,o=r.squeeze(i[0]).shape,l=i.map(u=>{let c=I.arraysEqual(u.shape,s);if(!c&&!I.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,s)});return[r.stack(l,a)]});case"Unpack":{let a=S("axis",e,t,n),i=S("tensor",e,t,n);return r.unstack(i,a)}case"Tile":{let a=S("reps",e,t,n);return[r.tile(S("x",e,t,n),a)]}case"Split":case"SplitV":{let a=S("axis",e,t,n),i=S("numOrSizeSplits",e,t,n),s=S("x",e,t,n);return r.split(s,i,a)}case"ScatterNd":{let a=S("indices",e,t,n),i=S("values",e,t,n),s=S("shape",e,t,n);return[r.scatterND(a,i,s)]}case"GatherNd":{let a=S("x",e,t,n),i=S("indices",e,t,n);return[r.gatherND(a,i)]}case"SparseToDense":{let a=S("sparseIndices",e,t,n),i=S("outputShape",e,t,n),s=S("sparseValues",e,t,n),o=S("defaultValue",e,t,n);return[r.sparseToDense(a,s,i,s.dtype===o.dtype?o:r.cast(o,s.dtype))]}case"TensorScatterUpdate":{let a=S("indices",e,t,n),i=S("values",e,t,n),s=S("tensor",e,t,n);return[r.tensorScatterUpdate(s,a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"sparse":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:i,emptyRowIndicator:s,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(S("indices",e,t,n),S("values",e,t,n),S("denseShape",e,t,n),S("defaultValue",e,t,n));return[a,i,s,o]}case"SparseReshape":{let{outputIndices:a,outputShape:i}=r.sparse.sparseReshape(S("inputIndices",e,t,n),S("inputShape",e,t,n),S("newShape",e,t,n));return[a,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"spectral":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"FFT":return[r.fft(S("x",e,t,n))];case"IFFT":return[r.ifft(S("x",e,t,n))];case"RFFT":return[r.rfft(S("x",e,t,n))];case"IRFFT":return[r.irfft(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"string":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(S("input",e,t,n),S("pattern",e,t,n),S("rewrite",e,t,n),S("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:i}=r.string.stringNGrams(S("data",e,t,n),S("dataSplits",e,t,n),S("separator",e,t,n),S("nGramWidths",e,t,n),S("leftPad",e,t,n),S("rightPad",e,t,n),S("padWidth",e,t,n),S("preserveShortSequences",e,t,n));return[a,i]}case"StringSplit":{let{indices:a,values:i,shape:s}=r.string.stringSplit(S("input",e,t,n),S("delimiter",e,t,n),S("skipEmpty",e,t,n));return[a,i,s]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(S("input",e,t,n),S("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"transformation":return a(()=>((e,t,n,r=ir)=>{switch(e.op){case"Cast":return[r.cast(S("x",e,t,n),S("dtype",e,t,n))];case"ExpandDims":{let a=S("axis",e,t,n);return[r.expandDims(S("x",e,t,n),a)]}case"Squeeze":{let a=S("axis",e,t,n);return[r.squeeze(S("x",e,t,n),a)]}case"Reshape":return[r.reshape(S("x",e,t,n),S("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(S("x",e,t,n),S("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(S("x",e,t,n),S("padding",e,t,n),S("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(S("x",e,t,n),S("padding",e,t,n),S("constantValue",e,t,n))];case"SpaceToBatchND":{let a=S("blockShape",e,t,n),i=S("paddings",e,t,n);return[r.spaceToBatchND(S("x",e,t,n),a,i)]}case"BatchToSpaceND":{let a=S("blockShape",e,t,n),i=S("crops",e,t,n);return[r.batchToSpaceND(S("x",e,t,n),a,i)]}case"DepthToSpace":{let a=S("blockSize",e,t,n),i=S("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(S("x",e,t,n),a,i)]}case"BroadcastTo":return[r.broadcastTo(S("x",e,t,n),S("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(S("s0",e,t,n),S("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(s,o,l));case"hash_table":return WMe(s,o,l,r);case"custom":let u=dq(s.op);if(u&&u.customExecutor)return u.customExecutor(new NMe(s,o,l));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return I.isPromise(i)?i.then(s=>[].concat(s)):[].concat(i)}var zq=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Bq(e,t,n,r){let a=new Set,i=[],s=null,o=null,l=new Set,u=new Set(Object.keys(e).map(d=>Aa(d)[0]));r=r||[];let c=new Set(r.map(d=>Aa(d.name)[0])),h=[...t];for(;h.length>0;){let d=h.pop();if((gd(d)||l2e(d)||u2e(d))&&null==s&&(s=d,o=s.children.map(p=>p.name).filter(p=>a.has(p))),a.add(d.name),null==n[d.name]&&!u.has(d.name)&&!c.has(d.name)){if(0===d.inputs.length){i.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:i,dynamicNode:s,syncInputs:o}}var FI=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}},i2e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),s2e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),o2e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function gd(e){return i2e.has(e.op)}function l2e(e){return s2e.has(e.op)}function u2e(e){return o2e.has(e.op)}var Vq=class wQ{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new wQ(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(i=>i.name).sort(),a=n.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,n){let r=Bq(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:i,syncInputs:s}=r;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(a.length>0){let u=n.map(h=>h.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${a}]`)}let o=function t2e(e,t){let{usedNodes:n,inputs:r}=t,s=g=>n.has("string"==typeof g?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...Object.keys(r).map(g=>Aa(g)[0]).map(g=>e.nodes[g]),...e.weights,...e.initNodes||[]]).filter(s),u=o([...l,...Object.values(e.nodes)]).filter(s),c=new Map(u.map(g=>[g.name,g])),h={};for(let g of u){h[g.name]=h[g.name]||0;for(let y of g.children)s(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}let d=Object.entries(h).filter(([,g])=>0===g).map(([g])=>g),p=[...d];for(;d.length>0;){let g=d.pop(),y=c.get(g);for(let v of y.children.filter(s))0==--h[v.name]&&(p.push(v.name),d.push(v.name))}let m=function n2e(e,t){let n=new Map(e.map(i=>[i.name,i])),r=t.map(i=>i.name),a=new Set(r);for(;r.length>0;){let i=r.pop(),s=n.get(i);for(let o of s.children)!n.has(o.name)||a.has(o.name)||(a.add(o.name),r.push(o.name))}return e.filter(i=>a.has(i.name))}(p.map(g=>c.get(g)),l);return function r2e(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),a=o=>r.has("string"==typeof o?o:o.name),i=new Set(e.map(o=>o.name)),s=o=>i.has("string"==typeof o?o:o.name);for(let o of e){for(let l of o.children.filter(s)){if(!n.has(l.name))throw new FI(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new FI(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!a(o))for(let l of o.inputs){if(!n.has(l.name))throw new FI(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new FI(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}(m,l),m}(this.graph,r),l=function a2e(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>gd(o)?n:l),a=o=>r[t.get(o.name)]??-1,i=e.map((o,l)=>o.children.map(a).reduce((u,c)=>Math.max(u,c),r[l])),s=new Map;for(let o=0;o<e.length;++o){let l=i[o];if(l===n)continue;let u=e[o],c=e[l];s.has(c.name)||s.set(c.name,[]),s.get(c.name).push(u)}return s}(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(null==t)return null;let n=t.clone();return Bn(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let a=r.map(d=>this.graph.nodes[Aa(d)[0]]),i=n.map(d=>Aa(d)[0]),s=new Set(i),o=i.map(d=>this.graph.nodes[d]);0===o.length&&(o=this._outputs);let l=this.getCompilationKey(a,o),u=this.compiledMap.get(l);null==u&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=H().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let c={},h={};return V(()=>{let d=new zq(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[v,b]=Aa(y,d),w=[];w[b]=t[y],p[v]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(w))});let f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(let y of m){if(p[y.name])continue;let v=Lq(y,p,d,this._resourceManager);if(I.isPromise(v))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,d,f,s,g.get(y.name))}return null==this.parent&&d.dispose(f),n.map(y=>pr(y,p,d))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,r,a,i,s,o){if(!gd(n)&&!s.has(t)){for(let l of r[t])null!=l&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(gd(l))continue;let u=hq(l.name,r,a);if(null!=u)for(let c of u){if(!c||c.kept||i.has(c.id))continue;let h=o[c.id];1===h?(c.dispose(),delete o[c.id]):null!=h&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,a,i,s){function o(l){return gd(l)||i.has(l.name)}if(!gd(t)&&null!=s)for(let l of s){if(o(l))continue;let u=hq(l.name,n,r);for(let c of u)!c||c.kept||a.has(c.id)||c.dispose()}}executeAsync(t,n){var r=this;return F(function*(){return r._executeAsync(t,n)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,n,r=!1,a={},i={}){var s=this;return F(function*(){s.disposeIntermediateTensors(),r||(t=s.mapInputs(t),s.checkInputs(t),s.checkInputShapeAndType(t),n=s.mapOutputs(n),s.checkOutputs(n));try{s.keepIntermediateTensors=H().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){s.keepIntermediateTensors=!1,console.warn(p.message)}let o=new zq(s.weightMap,a,i,s.functionExecutorMap,s.parseNodeNameCache);s.keepIntermediateTensors&&(s.clonedTensorsMap=s.cloneTensorMap(s.weightMap));let l=yield s.executeWithControlFlow(t,o,n,r),u=n.map(p=>pr(p,l,o)),c=u.map(p=>p.id),h=Object.keys(t).map(p=>t[p].id),d=new Set([...c,...h,...s.weightIds]);return Object.values(l).forEach(p=>{p.forEach(f=>{f&&!f.isDisposed&&!d.has(f.id)&&f.dispose()})}),null==s.parent&&o.dispose(d),u})()}executeFunctionAsync(t,n,r){var a=this;return F(function*(){let i=t.reduce((s,o,l)=>(s[a.inputs[l].name]=o,s),{});return a._executeAsync(i,a.outputNodes,!0,n,r)})()}executeWithControlFlow(t,n,r,a){var i=this;return F(function*(){let s=Object.keys(t),o=s.map(x=>i.graph.nodes[Aa(x)[0]]),l=r.map(x=>Aa(x)[0]),u=new Set(l),c=l.map(x=>i.graph.nodes[x]);0===c.length&&(c=i._outputs);let{usedNodes:h,missingInputs:d,dynamicNode:p,syncInputs:f}=Bq(t,c,i.weightMap,i._initNodes),m=[...o,...i.graph.weights,...i._initNodes||[]].map(x=>({node:x,contexts:n.currentContext})),g=Object.assign({},i.weightMap);Object.keys(t).forEach(x=>{let[C,k]=Aa(x),T=[];T[k]=t[x],g[C]=T});let y={},v=i.getFrozenTensorIds(g),b={};for(;m.length>0;){let x=i.processStack(o,m,n,g,b,v,u,y,h);yield Promise.all(x)}null==p&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=c.filter(x=>!gd(x)&&!pr(x.name,g,n)).map(x=>x.name);if(w.length>0){let x="";throw null!=p&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${x}`)}return g})()}processStack(t,n,r,a,i,s,o,l,u){let c=[];for(;n.length>0;){let h=n.pop();r.currentContext=h.contexts;let d="";if("Enter"===h.node.op&&S("isConstant",h.node,a,r)&&([d]=po(h.node.name,r)),null==a[h.node.name]){let p=Lq(h.node,a,r,this._resourceManager);d||([d]=po(h.node.name,r));let f=r.currentContext;I.isPromise(p)?c.push(p.then(m=>(a[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(d,h.node,a,r,s,o,l),this.processChildNodes(h.node,n,r,a,i,u),m))):(a[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,a,r,s,o,l),this.processChildNodes(h.node,n,r,a,i,u))}else this.processChildNodes(h.node,n,r,a,i,u)}return c}processChildNodes(t,n,r,a,i,s){t.children.forEach(o=>{let[l]=po(o.name,r);i[l]||!s.has(o.name)||("Merge"===o.op?o.inputNames.some(u=>!!pr(u,a,r))&&(i[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!pr(u,a,r))&&(i[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[a]=Aa(n),i=this.graph.nodes[a];if(i.attrParams.shape&&i.attrParams.shape.value){let s=i.attrParams.shape.value,o=s.length===r.shape.length&&r.shape.every((l,u)=>-1===s[u]||s[u]===l);I.assert(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${s}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&I.assert(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let a={};for(let i in t){let s=null===(r=null===(n=this._signature)||void 0===n?void 0:n.inputs)||void 0===r?void 0:r[i];null!=s?a[s.name]=t[i]:a[i]=t[i]}return a}checkInputs(t){let n=Object.keys(t).filter(r=>{let[a]=Aa(r);return null==this.graph.nodes[a]});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,a;let i=null===(a=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===a?void 0:a[n];return null!=i?i.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=Aa(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},c2e=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},d2e="?tfjs-format=file",h2e="model.json",qA=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=hr){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new c2e}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return I.isPromise(e)?e.then(t=>null==t.getWeightStream?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}loadStreaming(e){var t=this;return F(function*(){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let n=yield CH(e.getWeightStream(),e.weightSpecs);return t.loadWithWeightMap(e,n)})()}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let a=this.artifacts.userDefinedMetadata;null!=a.signature&&(r=a.signature),null!=a.structuredOutputKeys&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new Vq(Mq.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let a=Mq.Instance.transformGraph(e.modelInitializer);this.initializer=new Vq(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}save(e,t){var n=this;return F(function*(){if("string"==typeof e){let r=n.io.getSaveHandlers(e);if(0===r.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(n.artifacts)})()}addStructuredOutputNames(e){if(this.structuredOutputKeys){let n={};return(e instanceof Ze?[e]:e).forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}predictAsync(e,t){var n=this;return F(function*(){let r=yield n.executeAsync(e,n.outputNodes);return n.addStructuredOutputNames(r)})()}normalizeInputs(e){var t;if(!(e instanceof Ze||Array.isArray(e))){let a=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=a)for(let i in a){let s=a[i];null!=s.resourceId&&(e[i]=this.resourceIdToCapturedInput[s.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,i)=>{var s,o,l;let u=null===(l=null===(o=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===o?void 0:o[i])||void 0===l?void 0:l.resourceId;return a[i]=null!=u?this.resourceIdToCapturedInput[u]:e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var e=this;return F(function*(){return null==e.initializer?[]:e.initializer.executeAsync({},null==e.initializerSignature?[]:Object.keys(e.initializerSignature.outputs))})()}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++)this.resourceIdToCapturedInput[t[n[r]].resourceId]=e[r]}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}executeAsync(e,t){var n=this;return F(function*(){null==n.resourceIdToCapturedInput&&n.setResourceIdToCapturedInput(yield n.executeInitializerGraphAsync()),e=n.normalizeInputs(e),t=n.normalizeOutputs(t);let r=yield n.executor.executeAsync(e,t);return r.length>1?r:r[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&He(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};function p2e(e){return KA.apply(this,arguments)}function KA(){return KA=F(function*(e,t={},n=hr){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function m2e(e){return e.endsWith("/")||(e+="/"),`${e}${h2e}${d2e}`}(e));let r=new qA(e,t,n);return yield r.load(),r}),KA.apply(this,arguments)}function f2e(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!(a&&a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let i=hr.getWeightSpecs(r.weightsManifest),s=hr.getModelArtifactsForJSONSync(r,i,a);t=hr.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=hr.fromMemorySync(e)}let n=new qA(t);return n.load(),n}var g2e="4.16.0",Uq={};je(Uq,{CSVDataset:()=>tK,Dataset:()=>Pf,FileDataSource:()=>sK,TextLineDataset:()=>Qq,URLDataSource:()=>oK,array:()=>z2e,csv:()=>Q2e,func:()=>J2e,generator:()=>eRe,microphone:()=>nRe,version_data:()=>rRe,webcam:()=>tRe,zip:()=>B2e});var y2e=Uo(Zx()),v2e=Uo(Zx());function OI(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if($f(e)){let i=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let l=OI(e[s],t,n,r);i[s]=l}return r.delete(e),e.__proto__&&(i.__proto__=e.__proto__),i}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function w2e(e,t=jq){return Wq(e,t)}function Wq(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if($f(r)){let i=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let l=Wq(e.map(u=>u[s]),t,n);i[s]=l}return n.delete(r),i}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function jq(e){return null===e?null:$f(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function Hq(e,t){return XA.apply(this,arguments)}function XA(){return XA=F(function*(e,t){let n=new Map;OI(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(I.isPromise(a)){let i=yield a;n.set(r,i)}}return OI(e,t,n)}),XA.apply(this,arguments)}function $f(e){let t=!1;if(H().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=Bj();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Ze)&&!(e instanceof Promise)&&!t)}function S2e(e){return function b2e(e,t){return OI(e,t)}(e,_2e)}function _2e(e){return e instanceof Ze?{value:e.clone(),recurse:!1}:$f(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var Gq=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},qq=class xQ extends Gq{constructor(){super(xQ.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=2*this.capacity,n=new Array(t),r=this.length();for(let a=0;a<r;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};function Kq(e){return new k2e(e)}function ZA(e){return new N2e(e)}qq.INITIAL_CAPACITY=32;var vl,sr=class{toArray(){var e=this;return F(function*(){let t=[],n=yield e.next();for(;!n.done;)t.push(n.value),n=yield e.next();return t})()}toArrayForTest(){var e=this;return F(function*(){let t=e.prefetch(100),n=[],r=yield t.next();for(;!r.done;)n.push(r.value),r=yield t.next();return n})()}resolveFully(){var e=this;return F(function*(){let t=yield e.next();for(;!t.done;)t=yield e.next()})()}resolveWhile(e){var t=this;return F(function*(){let n=yield t.next(),r=e(n.value);for(;!n.done&&r;)n=yield t.next(),r=e(n.value)})()}handleErrors(e){return new O2e(this,e)}filter(e){return new R2e(this,e)}map(e){return new F2e(this,e)}mapAsync(e){return new Xq(this,e)}serialMapAsync(e){return new Xq(this,e).serial()}flatmap(e){return new $2e(this,e)}forEachAsync(e){var t=this;return F(function*(){return t.map(e).resolveFully()})()}serialForEach(e){var t=this;return F(function*(){return t.serialMapAsync(e).resolveWhile(n=>!0===n)})()}rowMajorBatch(e,t=!0){return new M2e(this,e,t)}columnMajorBatch(e,t=!0,n=jq){return this.rowMajorBatch(e,t).map(r=>w2e(r,n))}concatenate(e,t){return new Zq(Kq([this,e]),t)}take(e){return e<0||null==e?this:new A2e(this,e)}skip(e){return e<0||null==e?this:new D2e(this,e)}prefetch(e){return new Yq(this,e)}shuffle(e,t){return new L2e(this,e,t)}serial(){return new T2e(this)}},k2e=class extends sr{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var e=this;return F(function*(){if(e.trav>=e.items.length)return{value:null,done:!0};let t=e.items[e.trav];return e.trav++,{value:S2e(t),done:!1}})()}},N2e=class extends sr{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}next(){var e=this;return F(function*(){try{return e.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})()}},T2e=class extends sr{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){return e.upstream.next()})()}},D2e=class extends sr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){for(;e.count++<e.maxCount;){let t=yield e.upstream.next();if(t.done)return t;He(t.value)}return e.upstream.next()})()}},A2e=class extends sr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var e=this;return F(function*(){return e.count++>=e.maxCount?{value:null,done:!0}:e.upstream.next()})()}},M2e=class extends sr{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){let t=[];for(;t.length<e.batchSize;){let n=yield e.upstream.next();if(n.done)return e.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}})()}},R2e=class extends sr{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){for(;;){let t=yield e.upstream.next();if(t.done||e.predicate(t.value))return t;He(t.value)}})()}},F2e=class extends sr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}next(){var e=this;return F(function*(){let t=yield e.upstream.next();if(t.done)return{value:null,done:!0};let n=Ui.getTensorsInContainer(t.value),r=e.transform(t.value),a=Ui.getTensorsInContainer(r);for(let i of n)Ui.isTensorInList(i,a)||i.dispose();return{value:r,done:!1}})()}},O2e=class extends sr{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){for(;;)try{return yield e.upstream.next()}catch(t){if(!e.handler(t))return{value:null,done:!0}}})()}},Xq=class extends sr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var e=this;return F(function*(){let t=yield e.upstream.next();if(t.done)return{value:null,done:!0};let n=Ui.getTensorsInContainer(t.value),r=yield e.transform(t.value),a=Ui.getTensorsInContainer(r);for(let i of n)Ui.isTensorInList(i,a)||i.dispose();return{value:r,done:!1}})()}},YA=class extends sr{constructor(){super(),this.outputQueue=new qq,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return F(function*(){for(;0===e.outputQueue.length();)if(!(yield e.pump()))return{value:null,done:!0};return{value:e.outputQueue.shift(),done:!1}})()}},$2e=class extends YA{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var e=this;return F(function*(){let t=yield e.upstream.next();if(t.done)return!1;let n=Ui.getTensorsInContainer(t.value),r=e.transform(t.value),a=Ui.getTensorsInContainer(r);e.outputQueue.pushAll(r);for(let i of n)Ui.isTensorInList(i,a)||i.dispose();return!0})()}},Zq=class extends sr{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var e=this;return F(function*(){return e.lastRead=e.readFromChain(e.lastRead),e.lastRead})()}readFromChain(e){var t=this;return F(function*(){if(yield e,null==t.iterator){let r=yield t.moreIterators.next();if(r.done)return{value:null,done:!0};t.iterator=r.value,null!=t.baseErrorHandler&&(t.iterator=t.iterator.handleErrors(t.baseErrorHandler))}let n=yield t.iterator.next();return n.done?(t.iterator=null,t.readFromChain(e)):n})()}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(vl||(vl={}));var P2e=class extends sr{constructor(e,t=vl.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}nextState(e){var t=this;return F(function*(){yield e;let n=0,r=0,i=yield Hq(t.iterators,function a(s){return s instanceof sr?{value:s.next().then(o=>(n++,o.done&&r++,o.value)),recurse:!1}:{value:null,recurse:!0}});if(n===r)return{value:null,done:!0};if(r>0)switch(t.mismatchMode){case vl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${t.count}.`);case vl.SHORTEST:return{value:null,done:!0}}return t.count++,{value:i,done:!1}})()}next(){var e=this;return F(function*(){return e.currentPromise=e.nextState(e.currentPromise),e.currentPromise})()}},Yq=class extends sr{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Gq(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},L2e=class extends Yq{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=v2e.alea(n||I.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return F(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var e=this;return F(function*(){for(e.upstreamExhausted||e.refill();!e.buffer.isEmpty();){let t=e.chooseIndex(),n=yield e.buffer.shuffleExcise(t);if(!n.done)return e.refill(),n;e.upstreamExhausted=!0}return{value:null,done:!0}})()}},Pf=class{constructor(){this.size=null}batch(e,t=!0){let r,n=this;return I.assert(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Ma(F(function*(){return(yield n.iterator()).columnMajorBatch(e,t,V2e)}),r)}concatenate(e){let n,t=this;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Ma(F(function*(){return(yield t.iterator()).concatenate(yield e.iterator())}),n)}filter(e){let n,t=this;return n=this.size===1/0?1/0:null,Ma(F(function*(){return(yield t.iterator()).filter(r=>V(()=>e(r)))}),n)}forEachAsync(e){var t=this;return F(function*(){return(yield t.iterator()).forEachAsync(e)})()}map(e){let t=this;return Ma(F(function*(){return(yield t.iterator()).map(n=>V(()=>e(n)))}),this.size)}mapAsync(e){let t=this;return Ma(F(function*(){return(yield t.iterator()).mapAsync(e)}),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ma(F(function*(){return(yield t.iterator()).prefetch(e)}),this.size)}repeat(e){let n,t=this;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Ma(F(function*(){return function C2e(e,t){return new Zq(e,t)}(ZA(F(function*(){return{value:yield t.iterator(),done:!1}})).take(e))}),n)}skip(e){let n,t=this;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Ma(F(function*(){return(yield t.iterator()).skip(e)}),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=y2e.alea(t||I.now().toString());return Ma(F(function*(){let i=a.int32();return n&&(i+=a.int32()),(yield r.iterator()).shuffle(e,i.toString())}),this.size)}take(e){let n,t=this;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Ma(F(function*(){return(yield t.iterator()).take(e)}),n)}toArray(){var e=this;return F(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArray()})()}toArrayForTest(){var e=this;return F(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArrayForTest()})()}};function Ma(e,t=null){return new class extends Pf{constructor(){super(...arguments),this.size=t}iterator(){return F(function*(){return e()})()}}}function z2e(e){return Ma(F(function*(){return Kq(e)}),e.length)}function B2e(e){if(!$f(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return Ma(F(function*(){return function E2e(e,t=vl.FAIL){return new P2e(e,t)}(yield Hq(e,r=>{if(r instanceof Pf)return{value:r.iterator(),recurse:!1};if($f(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),vl.SHORTEST)}),t)}function V2e(e){return null===e?null:function x2e(e){return null==e||function I2e(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof Ze||I.isTypedArray(e)}(e[0])?{value:U2e(e),recurse:!1}:{value:null,recurse:!0}}function U2e(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ze?Tn(e):$r(e)}Pf.MAX_BUFFER_SIZE=1e4;var Qq=class extends Pf{constructor(e){super(),this.input=e}iterator(){var e=this;return F(function*(){return(yield e.input.iterator()).decodeUTF8().split("\n").map(t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t))})()}},mv=Symbol("out"),Jq=Symbol("field"),PI=Symbol("quote"),QA=Symbol("quoteafterquote"),eK=Symbol("quoteinquote"),tK=class extends Pf{columnNames(){var e=this;return F(function*(){return e.columnNamesValidated||(yield e.setColumnNames()),e.configuredColumnsOnly?Object.keys(e.columnConfigs):e.fullColumnNames})()}setColumnNames(){var e=this;return F(function*(){let t=yield e.maybeReadHeaderLine();if(!e.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");e.fullColumnNames&&t&&I.assert(t.length===e.fullColumnNames.length,()=>"The length of provided columnNames ("+e.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),e.fullColumnNames||(e.fullColumnNames=t);let n=e.fullColumnNames.reduce((a,i)=>(a[i]=a[i]+1||1,a),{}),r=Object.keys(n).filter(a=>n[a]>1);if(I.assert(0===r.length,()=>"Duplicate column names found: "+r.toString()),e.columnConfigs)for(let a of Object.keys(e.columnConfigs))if(-1===e.fullColumnNames.indexOf(a))throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+e.fullColumnNames.toString()+").");e.columnNamesValidated=!0})()}maybeReadHeaderLine(){var e=this;return F(function*(){if(e.hasHeader){let t=yield(yield e.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");return e.parseRow(t.value,!1)}return null})()}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Qq(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(I.assert(null==t.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}iterator(){var e=this;return F(function*(){e.columnNamesValidated||(yield e.setColumnNames());let t=yield e.base.iterator();return e.hasHeader&&(t=t.skip(1)),t.map(n=>e.makeDataElement(n))})()}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],s=this.columnConfigs?this.columnConfigs[i]:null;if(!this.configuredColumnsOnly||s){let o=t[a],l=null;if(""===o)if(s&&void 0!==s.default)l=s.default;else{if(s&&(s.required||s.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))l=s&&"bool"===s.dtype?this.getBoolean(o):o;else if(s&&s.dtype)switch(s.dtype){case"float32":default:l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o)}else l=u}s&&s.isLabel?r[i]=l:n[i]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,i=mv;for(let s=0;s<a;s++)switch(i){case mv:switch(e.charAt(s)){case'"':r=s+1,i=PI;break;case this.delimiter:if(r=s+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),i=mv;break;default:i=Jq,r=s}break;case Jq:e.charAt(s)===this.delimiter&&(n.push(e.substring(r,s)),i=mv,r=s+1);break;case PI:'"'===e.charAt(s)&&(i=QA);break;case QA:switch(e.charAt(s)){case this.delimiter:n.push(e.substring(r,s-1)),i=mv,r=s+1;break;case'"':i=PI;break;default:i=eK}break;case eK:'"'===e.charAt(s)&&(i=PI)}if(n.push(i===QA?e.substring(r,a-1):e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},W2e=class IQ extends sr{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!1!==t.includeSpectrogram,this.includeWaveform=!0===t.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static create(t={}){return F(function*(){if(!H().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new IQ(t);return yield n.start(),n})()}start(){var t=this;return F(function*(){try{t.stream=yield navigator.mediaDevices.getUserMedia({audio:null==t.audioTrackConstraints||t.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!t.stream)throw new Error("Could not obtain audio from microphone.");let n=window.AudioContext||window.webkitAudioContext;if(t.audioContext=new n,t.sampleRateHz){if(t.audioContext.sampleRate!==t.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${t.sampleRateHz}; Actual: ${t.audioContext.sampleRate}`)}else t.sampleRateHz=t.audioContext.sampleRate;let r=t.audioContext.createMediaStreamSource(t.stream);t.analyser=t.audioContext.createAnalyser(),t.analyser.fftSize=2*t.fftSize,t.analyser.smoothingTimeConstant=t.smoothingTimeConstant,r.connect(t.analyser),t.freqData=new Float32Array(t.fftSize),t.timeData=new Float32Array(t.fftSize)})()}next(){var t=this;return F(function*(){if(t.isClosed)return{value:null,done:!0};let n,r,a=yield t.getAudioData();if(t.includeSpectrogram){let i=t.flattenQueue(a.freqDataQueue);n=t.getTensorFromAudioDataArray(i,[t.numFrames,t.columnTruncateLength,1])}if(t.includeWaveform){let i=t.flattenQueue(a.timeDataQueue);r=t.getTensorFromAudioDataArray(i,[t.numFrames*t.fftSize,1])}return{value:{spectrogram:n,waveform:r},done:!1}})()}capture(){var t=this;return F(function*(){return(yield t.next()).value})()}getAudioData(){var t=this;return F(function*(){let n=[],r=[],a=0;return new Promise(i=>{let s=setInterval(()=>{t.includeSpectrogram&&(t.analyser.getFloatFrequencyData(t.freqData),t.freqData[0]===-1/0&&i({freqDataQueue:n,timeDataQueue:r}),n.push(t.freqData.slice(0,t.columnTruncateLength))),t.includeWaveform&&(t.analyser.getFloatTimeDomainData(t.timeData),r.push(t.timeData.slice())),++a===t.numFrames&&(clearInterval(s),i({freqDataQueue:n,timeDataQueue:r}))},t.fftSize/t.sampleRateHz*1e3)})})()}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((a,i)=>r.set(a,i*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(I.sizeFromShape(n));return r.set(t,r.length-t.length),$r(r,n)}},j2e=class SQ extends sr{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Tt([0],"int32"),this.webcamConfig.centerCrop){let r=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,a=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,i=(1-r)/2,s=(1-a)/2;this.cropBox=Is([s,i,a+s,i+r],[1,4])}else this.cropBox=Is([0,0,1,1],[1,4])}summary(){return"webcam"}static create(t,n={}){return F(function*(){if(!H().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new SQ(t,n);return yield r.start(),r})()}start(){var t=this;return F(function*(){t.webcamConfig.facingMode&&I.assert("user"===t.webcamConfig.facingMode||"environment"===t.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${t.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{t.stream=yield navigator.mediaDevices.getUserMedia({video:{deviceId:t.webcamConfig.deviceId,facingMode:t.webcamConfig.facingMode?t.webcamConfig.facingMode:"user",width:t.webcamVideoElement.width,height:t.webcamVideoElement.height}})}catch(n){throw n.message=`Error thrown while initializing video stream: ${n.message}`,n}if(!t.stream)throw new Error("Could not obtain video from webcam.");try{t.webcamVideoElement.srcObject=t.stream}catch(n){console.log(n),t.webcamVideoElement.src=window.URL.createObjectURL(t.stream)}return t.webcamVideoElement.play(),t.isClosed=!1,new Promise(n=>{t.webcamVideoElement.onloadedmetadata=()=>{n()}})})()}next(){var t=this;return F(function*(){if(t.isClosed)return{value:null,done:!0};let n;try{n=Qy.fromPixels(t.webcamVideoElement)}catch(r){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(r)}`)}if(!t.resize)return{value:n,done:!1};try{return{value:t.cropAndResizeFrame(n),done:!1}}catch(r){throw new Error(`Error thrown cropping the video: ${r.message}`)}finally{n.dispose()}})()}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(t){return V(()=>{let r,n=nr(de(t,"float32"),0);return r=Za.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear"),B(r,r.shape.slice(1))})}capture(){var t=this;return F(function*(){return(yield t.next()).value})()}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},nK=class{},rK=class extends sr{split(e){return new H2e(this,e)}},H2e=class extends rK{constructor(e,t){super(),this.upstream=e,this.impl=new G2e(e,t)}summary(){return this.impl.summary()}next(){var e=this;return F(function*(){return e.impl.next()})()}},G2e=class extends YA{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}pump(){var e=this;return F(function*(){let t=yield e.upstream.next();if(t.done)return""!==e.carryover&&(e.outputQueue.push(e.carryover),e.carryover="",!0);let n=t.value.split(e.separator);n[0]=e.carryover+n[0];for(let r of n.slice(0,-1))e.outputQueue.push(r);return e.carryover=n[n.length-1],!0})()}},q2e=class extends sr{decodeUTF8(){return new K2e(this)}},K2e=class extends rK{constructor(e){super(),this.upstream=e,this.impl=new X2e(e)}summary(){return this.impl.summary()}next(){var e=this;return F(function*(){return e.impl.next()})()}},X2e=class extends YA{constructor(e){if(super(),this.upstream=e,H().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=Bj();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}pump(){var e=this;return F(function*(){let n,r,t=yield e.upstream.next();return!t.done&&(n=t.value,r=H().get("IS_BROWSER")?e.decoder.decode(n,{stream:!0}):e.decoder.write(Buffer.from(n.buffer)),e.outputQueue.push(r),!0)})()}},aK=class extends q2e{constructor(e,t={}){super(),this.file=e,this.options=t,I.assert(e instanceof Uint8Array||!!H().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}next(){var e=this;return F(function*(){return e.offset>=(e.file instanceof Uint8Array?e.file.byteLength:e.file.size)?{value:null,done:!0}:{value:yield new Promise((t,n)=>{let r=e.offset+e.chunkSize;if(e.file instanceof Uint8Array)t(new Uint8Array(e.file.slice(e.offset,r)));else{let a=new FileReader;a.onload=s=>{let o=a.result;if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),!(o instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(o)},a.onabort=s=>n(new Error("Aborted")),a.onerror=s=>n(new Error(s.type));let i=e.file.slice(e.offset,r);a.readAsArrayBuffer(i)}e.offset=r}),done:!1}})()}};function JA(){return JA=F(function*(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=Y2e(e));let i=yield(n||I.fetch)(r,a);if(i.ok){let s=new Uint8Array(yield i.arrayBuffer());return new aK(s,t)}throw new Error(i.statusText)}),JA.apply(this,arguments)}var Y2e=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function iK(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var sK=class extends nK{constructor(e,t={}){super(),this.input=e,this.options=t}iterator(){var e=this;return F(function*(){if(iK(e.input)&&H().get("IS_NODE")){let t=tN();e.input=t.readFileSync(e.input.slice(7))}return new aK(e.input,e.options)})()}},oK=class extends nK{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}iterator(){var e=this;return F(function*(){return iK(e.url)?new sK(e.url,e.fileOptions).iterator():function Z2e(e){return JA.apply(this,arguments)}(e.url,e.fileOptions)})()}};function Q2e(e,t={}){return new tK(new oK(e),t)}function J2e(e){let t=ZA(e);return Ma(F(function*(){return t}))}function eRe(e){return Ma(F(function*(){let t=yield e();return ZA(()=>t.next())}))}function tRe(e,t){return eM.apply(this,arguments)}function eM(){return eM=F(function*(e,t){return j2e.create(e,t)}),eM.apply(this,arguments)}function nRe(e){return tM.apply(this,arguments)}function tM(){return tM=F(function*(e){return W2e.create(e)}),tM.apply(this,arguments)}var rRe="4.16.0";function Ie(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{null!=n&&I.assert("complex64"!==n.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var aRe=_s.whereImpl,nM=class _Q extends Yg{nextDataId(){return _Q.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Yx(this,fi())}write(t,n,r){this.firstUse&&(this.firstUse=!1,H().get("IS_NODE")&&E.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,n,r){let a;if("string"===n&&null!=r&&r.length>0&&I.isString(r[0])){let i=r.map(s=>I.encodeString(s));a=this.write(i,t,n)}else a=this.write(r,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,n,r,a,i){this.data.set(t,{values:n,dtype:a,refCount:i})}numDataIds(){return this.data.numDataIds()}read(t){var n=this;return F(function*(){return n.readSync(t)})()}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if("complex64"===n){let a=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return E.mergeRealAndImagArrays(a,i)}return I.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if("string"===t.dtype)try{let r=n.map(a=>I.decodeString(a));return Je(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Je(t.shape,t.dtype,n)}makeOutput(t,n,r){return fi().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return F(function*(){let n=I.now();return t(),{kernelMs:I.now()-n}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Ie([t],"where");let n=this.readSync(t.dataId);return aRe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};nM.nextDataId=0;var rM={};function lK(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}je(rM,{addImpl:()=>cK,bincountImpl:()=>iM,bincountReduceImpl:()=>dK,bitwiseAndImpl:()=>hK,castImpl:()=>uK,ceilImpl:()=>pK,concatImpl:()=>sM,equalImpl:()=>fK,expImpl:()=>gK,expm1Impl:()=>vK,floorDivImpl:()=>wK,floorImpl:()=>bK,gatherNdImpl:()=>xK,gatherV2Impl:()=>IK,greaterEqualImpl:()=>_K,greaterImpl:()=>SK,lessEqualImpl:()=>EK,lessImpl:()=>CK,linSpaceImpl:()=>kK,logImpl:()=>NK,maxImpl:()=>TK,maximumImpl:()=>DK,minimumImpl:()=>AK,multiplyImpl:()=>oM,negImpl:()=>MK,notEqualImpl:()=>RK,prodImpl:()=>FK,raggedGatherImpl:()=>$K,raggedRangeImpl:()=>LK,raggedTensorToTensorImpl:()=>VK,rangeImpl:()=>uM,rsqrtImpl:()=>UK,scatterImpl:()=>vd,sigmoidImpl:()=>rFe,simpleAbsImpl:()=>lK,sliceImpl:()=>BI,sparseFillEmptyRowsImpl:()=>jK,sparseReshapeImpl:()=>HK,sparseSegmentReductionImpl:()=>cM,sqrtImpl:()=>sFe,squaredDifferenceImpl:()=>GK,staticRegexReplaceImpl:()=>qK,stridedSliceImpl:()=>KK,stringNGramsImpl:()=>dM,stringSplitImpl:()=>hM,stringToHashBucketFastImpl:()=>pM,subImpl:()=>XK,tileImpl:()=>ZK,topKImpl:()=>QK,transposeImpl:()=>lM,uniqueImpl:()=>mM});var sRe={kernelName:np,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;Ie(t,"abs");let r=new Float32Array(I.sizeFromShape(t.shape));return r=lK(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function wn(e){return(t,n,r,a,i)=>{let s=E.assertAndGetBroadcastShape(t,n),o=s.length,l=I.computeStrides(s),u=I.sizeFromShape(s),c=I.getTypedArrayFromDType(i,u),h=t.length,d=n.length,p=I.computeStrides(t),f=I.computeStrides(n),m=E.getBroadcastDims(t,s),g=E.getBroadcastDims(n,s);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){let v=I.indexToLoc(y,o,l),b=v.slice(-h);m.forEach(k=>b[k]=0);let w=I.locToIndex(b,h,p),x=v.slice(-d);g.forEach(k=>x[k]=0);let C=I.locToIndex(x,d,f);c[y]=e(r[w],a[C])}return[c,s]}}function Ra(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(a.shape,"float32",s)},o}var oRe={kernelName:r0,backendName:"cpu",kernelFunc:Ra};function LI(e,t,n="float32"){if("complex64"===n)return Ra({inputs:{real:LI(e,t,"float32"),imag:LI(e,t,"float32")},backend:e});let r=I.makeZerosTypedArray(I.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Ts(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var lRe={kernelName:Qu,backendName:"cpu",kernelFunc:Ts};function yd(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var uRe={kernelName:g0,backendName:"cpu",kernelFunc:yd};function uK(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){let a=I.toTypedArray([0],n),[i,s]=wn((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[s,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function bl(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===a.dtype)return Ts({inputs:{x:a},backend:n});let c=LI(n,a.shape,a.dtype),h=bl({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),d=Ra({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),d}if("complex64"===a.dtype){let c=yd({inputs:{input:a},backend:n}),h=bl({inputs:{x:c},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(c),h}if(!I.hasEncodingLoss(a.dtype,i)){let c=Ts({inputs:{x:a},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:i}}let s=n.data.get(a.dataId).values,[o,l,u]=uK(s,a.shape,a.dtype,i);return n.makeTensorInfo(o,l,u)}var cRe={kernelName:Ru,backendName:"cpu",kernelFunc:bl};function Hn(e,t,n,r){return null==n?({inputs:a,backend:i})=>{let{a:s,b:o}=a,l=i;Ie([s,o],e);let u=l.data.get(s.dataId).values,c=l.data.get(o.dataId).values,h="string"===s.dtype?E.fromUint8ToStringArray(u):u,d="string"===s.dtype?E.fromUint8ToStringArray(c):c,p=r||s.dtype,[f,m]=t(s.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:a,backend:i})=>{let{a:s,b:o}=a,l=i;if("complex64"===s.dtype||"complex64"===o.dtype){let u=bl({inputs:{x:s},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.imag,p=l.data.get(c.complexTensorInfos.real.dataId).values,f=l.data.get(d.dataId).values,m=bl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),v=g.complexTensorInfos.imag,b=l.data.get(g.complexTensorInfos.real.dataId).values,w=l.data.get(v.dataId).values,[x,C,k]=n(s.shape,o.shape,p,f,b,w),T=l.makeTensorInfo(k,"float32",x),A=l.makeTensorInfo(k,"float32",C),R=Ra({inputs:{real:T,imag:A},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(A),R}{let u=l.data.get(s.dataId).values,c=l.data.get(o.dataId).values,h=r||s.dtype,[d,p]=t(s.shape,o.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function aM(e){return(t,n,r,a,i,s)=>{let o=E.assertAndGetBroadcastShape(t,n),l=I.sizeFromShape(o),u=o.length,c=I.computeStrides(o),h=I.getTypedArrayFromDType("float32",l),d=I.getTypedArrayFromDType("float32",l),p=E.getBroadcastDims(t,o),f=E.getBroadcastDims(n,o),m=E.mergeRealAndImagArrays(r,a),g=E.mergeRealAndImagArrays(i,s),y=t.length,v=I.computeStrides(t),b=n.length,w=I.computeStrides(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){let C=x%m.length,k=x%g.length,T=e(m[2*C],m[2*C+1],g[2*k],g[2*k+1]);h[x]=T.real,d[x]=T.imag}else for(let x=0;x<h.length;x++){let C=I.indexToLoc(x,u,c),k=C.slice(-y);p.forEach(_=>k[_]=0);let T=I.locToIndex(k,y,v),A=C.slice(-b);f.forEach(_=>A[_]=0);let R=I.locToIndex(A,b,w),M=e(m[2*T],m[2*T+1],g[2*R],g[2*R+1]);h[x]=M.real,d[x]=M.imag}return[h,d,o]}}var cK=wn((e,t)=>e+t),dRe=aM((e,t,n,r)=>({real:e+n,imag:t+r})),Lf=Hn(Ho,cK,dRe),hRe={kernelName:Ho,backendName:"cpu",kernelFunc:Lf};function iM(e,t,n,r,a){let i=I.sizeFromShape(r),s=I.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s[l]+=i>0?t[o]:1)}return s}function dK(e,t,n,r=!1){let a=e.shape[0],i=e.shape[1],s=Je([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<i;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||s.set(r?1:t.size>0?s.get(o,u)+t.get(o,l):s.get(o,u)+1,o,u)}return s}var hK=wn((e,t)=>e&t),pRe=Hn(cp,hK),fRe={kernelName:cp,backendName:"cpu",kernelFunc:pRe};function Ds(e){return(t,n,r)=>{let a=I.getArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)a[i]=e(t[i],r);return a}}function Ot(e,t,n){return wl(e,Ds(t),n)}function wl(e,t,n){return({inputs:r,attrs:a,backend:i})=>{let{x:s}=r;Ie(s,e);let u,o=i,l=o.data.get(s.dataId).values;if("string"===s.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=E.fromUint8ToStringArray(l)}else u=l;let c=n||s.dtype,h=t(u,c,a);return o.makeTensorInfo(s.shape,c,h)}}var pK=Ds(e=>Math.ceil(e)),mRe=wl(Fu,pK),gRe={kernelName:Fu,backendName:"cpu",kernelFunc:mRe};function sM(e,t,n,r){let a=I.getArrayFromDType(n,I.sizeFromShape(t));if(r&&"string"!==n){let i=0;e.forEach(s=>{let o=I.sizeFromShape(s.shape);a.set(s.vals,i),i+=o})}else{let i=0;e.forEach(s=>{let o="string"===n?E.fromUint8ToStringArray(s.vals):s.vals,l=0;for(let u=0;u<s.shape[0];++u){let c=u*t[1]+i;for(let h=0;h<s.shape[1];++h)a[c+h]=o[l++]}i+=s.shape[1]})}return a}var fK=wn((e,t)=>e===t?1:0),mK=Hn(wp,fK,null,"bool"),yRe={kernelName:wp,backendName:"cpu",kernelFunc:mK},gK=Ds(e=>Math.exp(e)),yK=wl(Gu,gK,"float32"),vRe={kernelName:Gu,backendName:"cpu",kernelFunc:yK},vK=Ds(e=>Math.expm1(e)),bRe=wl(qu,vK),wRe={kernelName:qu,backendName:"cpu",kernelFunc:bRe},bK=Ds(e=>Math.floor(e)),xRe=wl(Ku,bK),IRe={kernelName:Ku,backendName:"cpu",kernelFunc:xRe},wK=wn((e,t)=>Math.floor(e/t)),SRe=Hn(Xu,wK,null,"int32"),_Re={kernelName:Xu,backendName:"cpu",kernelFunc:SRe};function xK(e,t,n,r,a,i,s,o,l){let u=Je([r,i],n);for(let c=0;c<r;c++){let h=[],d=0;for(let p=0;p<a;p++){let f=e[c*a+p];d+=f*s[p],h.push(f)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let p=0;p<i;p++)u.values[c*i+p]=t.get(...t.indexToLoc(d*i+p))}return u}function IK(e,t,n){let r=Je(n,e.dtype);for(let a=0;a<r.size;++a){let i=r.indexToLoc(a).slice(),l=t.locToIndex([i[0],i[2]]);i[2]=t.values[l];let u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[a]=e.values[u])}return r}var SK=wn((e,t)=>e>t?1:0),CRe=Hn(Cp,SK,null,"bool"),ERe={kernelName:Cp,backendName:"cpu",kernelFunc:CRe},_K=wn((e,t)=>e>=t?1:0),kRe=Hn(Yu,_K,null,"bool"),NRe={kernelName:Yu,backendName:"cpu",kernelFunc:kRe},CK=wn((e,t)=>e<t?1:0),TRe=Hn(Ep,CK,null,"bool"),DRe={kernelName:Ep,backendName:"cpu",kernelFunc:TRe},EK=wn((e,t)=>e<=t?1:0),ARe=Hn(kp,EK,null,"bool"),MRe={kernelName:kp,backendName:"cpu",kernelFunc:ARe};function kK(e,t,n){let r=(t-e)/(n-1),a=I.makeZerosTypedArray(n,"float32");a[0]=e;for(let i=1;i<a.length;i++)a[i]=a[i-1]+r;return a}var NK=Ds(e=>Math.log(e)),RRe=wl(rc,NK),FRe={kernelName:rc,backendName:"cpu",kernelFunc:RRe};function TK(e,t,n,r){let a=I.getTypedArrayFromDType(r,I.sizeFromShape(n));for(let i=0;i<a.length;++i){let s=i*t,o=e[s];for(let l=0;l<t;++l){let u=e[s+l];(Number.isNaN(u)||u>o)&&(o=u)}a[i]=o}return a}var DK=wn((e,t)=>Math.max(e,t)),ORe=Hn(oc,DK),$Re={kernelName:oc,backendName:"cpu",kernelFunc:ORe},AK=wn((e,t)=>Math.min(e,t)),PRe=Hn(dc,AK),LRe={kernelName:dc,backendName:"cpu",kernelFunc:PRe},oM=wn((e,t)=>e*t),zRe=aM((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),zI=Hn(fc,oM,zRe),BRe={kernelName:fc,backendName:"cpu",kernelFunc:zI};function MK(e,t,n){let r=I.createScalarValue(-1,n);return oM([],t,r,e,n)}var URe={kernelName:Op,backendName:"cpu",kernelFunc:function VRe(e){let{inputs:t,backend:n}=e,{x:r}=t;Ie(r,"neg");let a=n.data.get(r.dataId).values,[i,s]=MK(a,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,i)}},RK=wn((e,t)=>e!==t?1:0),WRe=Hn($p,RK,null,"bool"),jRe={kernelName:$p,backendName:"cpu",kernelFunc:WRe};function lM(e,t,n,r,a){let i=t.length,s=I.sizeFromShape(t),o=I.computeStrides(t),l=I.computeStrides(a),u=I.getTypedArrayFromDType(n,I.sizeFromShape(a));for(let c=0;c<s;++c){let h=I.indexToLoc(c,i,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[r[f]];u[I.locToIndex(d,i,l)]=e[c]}return u}function la(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:i}=n;Ie(a,"transpose");let o=new Array(a.shape.length);for(let c=0;c<o.length;c++)o[c]=a.shape[i[c]];let u=lM(r.data.get(a.dataId).values,a.shape,a.dtype,i,o);return{dataId:r.write(u,o,a.dtype),shape:o,dtype:a.dtype}}var HRe={kernelName:eo,backendName:"cpu",kernelFunc:la};function FK(e,t,n,r){let[a,i]=E.computeOutAndReduceShapes(e,r),s=Ga(t,"int32"),o=I.makeZerosTypedArray(I.sizeFromShape(a),s),l=I.sizeFromShape(i);for(let u=0;u<o.length;++u){let c=u*l,h=1;for(let d=0;d<l;++d)h*=n[c+d];o[u]=h}return{outVals:o,outShape:a,outDtype:s}}var qRe={kernelName:bc,backendName:"cpu",kernelFunc:function GRe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;Ie(a,"prod");let o=a.shape.length,l=I.parseAxisParam(i,a.shape),u=E.getAxesPermutation(l,o),c=l,h=a,d=[];null!=u&&(h=la({inputs:{x:a},backend:n,attrs:{perm:u}}),d.push(h),c=E.getInnerMostAxes(c.length,o));let p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=FK(h.shape,h.dtype,p,c),y=m;return s&&(y=E.expandShapeToKeepDim(m,l)),d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(y,g,f)}};function OK(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function $K(e,t,n,r,a,i,s,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function KRe(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let i=I.indexToLoc(a,t.length,I.computeStrides(t)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${n})`)}})}(i,s,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:h,numValues:d}=function ZRe(e,t,n,r){let a=[],i=0,o=new Array(t.length-1+n.length).fill(null).map(()=>[0]);!function XRe(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let h=1;h<l+1;++h)o[u].push(h*c)}for(let u=0;u<e.length;++u){let c=e[u],h=e[u]+1;for(let d=0;d<n.length;++d){let p=n[d],f=d+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<h;++y)o[f].push(p[y+1]+g)}c=p[c],h=p[h]}h!==c&&(a.push([c,h]),i+=h-c)}return{outSplits:o,valueSlices:a,numValues:i}}(i,s,e,u),p=function YRe(e){let t=[];for(let n=0;n<e.length;++n){let a=I.getArrayFromDType("int32",e[n].length);t.push(a),e[n].forEach((i,s)=>a[s]=i)}return t}(c),f=function JRe(e,t,n,r,a){let i=t.slice();i[0]=a;let s=I.getArrayFromDType(n,I.sizeFromShape(i)),o=e.length;return function QRe(e,t,n,r,a,i){let s=OK(t,2)[1],o=OK(i,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let h=0;h<r;++h)a[l*o+h]=e[c*s+h];++l}}(e,t,r,0===o?0:o/t[0],s,i),[s,i]}(n,r,a,h,d);return[p,f[0],f[1]]}var PK=2147483647;function LK(e,t,n,r,a,i,s){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(s.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===s.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(s[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let h=0===c.length?1:c[0],d=I.getArrayFromDType("int32",h+1);d[0]=0;for(let g=0;g<h;++g){let w,y=o?e[0]:e[g],v=l?r[0]:r[g],b=u?i[0]:i[g];if(0===b)throw new Error("Requires delta != 0");if(b>0&&v<y||b<0&&v>y)w=0;else if(w=Math.ceil(Math.abs((v-y)/b)),w>PK)throw new Error(`Requires ((limit - start) / delta) <= ${PK}`);d[g+1]=d[g]+w}let f=I.getArrayFromDType(n,d[h]),m=0;for(let g=0;g<h;++g){let y=d[g+1]-d[g],v=o?e[0]:e[g],b=u?i[0]:i[g];for(let w=0;w<y;++w)f[m++]=v,v+=b}return[d,f]}var wi=E.RowPartitionType,eFe=class TO{constructor(t,n,r,a,i,s,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=i,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=E.getRowPartitionTypesHelper(c),this.raggedRank=E.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===wi.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===wi.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case wi.VALUE_ROWIDS:return TO.getMaxWidthValueRowID(n);case wi.ROW_SPLITS:return TO.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${wi[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(0===n||1===n)return 0;let r=0;for(let a=0;a<n-1;++a){let i=t[a+1]-t[a];i>r&&(r=i)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(0===n)return 0;let r=0,a=t[0],i=0;for(let s=1;s<n;++s){let o=t[s];o!==a&&(a=o,i=Math.max(s-r,i),r=s)}return Math.max(n-r,i)}tensorShapeFromTensor(t,n,r=!0){if(0===n.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return BK(t,r)}calculateOutputSize(t){let n=this.valuesShape;E.validateDefaultValueShape(this.defaultValueShape,n);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=E.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);i[0]<0&&(i[0]=t);for(let s=1;s<=this.raggedRank;++s)i[s]<0&&(i[s]=this.getMaxWidth(s));return i}calculateFirstParentOutputIndex(t,n,r){let a=Math.min(t,r),i=[],s=0;for(let o=0;o<a;++o,s+=n)i.push(s);for(let o=a;o<t;++o)i.push(-1);return I.assert(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,n,r,a){let i=t.length,s=[];for(let o=0;o<i-1;++o){let l=t[o+1]-t[o],u=Math.min(a,l),c=n[o];-1===c&&(u=0);for(let h=0;h<u;++h)s.push(c),c+=r;for(let h=0;h<l-u;++h)s.push(-1)}if(i>0&&s.length!==t[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,n,r,a){let i=t.length,s=[];if(0===i)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];s.push(u);for(let c=1;c<i;++c){let h=t[c];if(h===l)u>=0&&(++o,o<a?u+=r:u=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}s.push(u)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,n,r,a){let i=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case wi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,r,a);case wi.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,r,a);default:throw new Error(`Unsupported partition type: ${wi[s]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case wi.FIRST_DIM_SIZE:return t[0];case wi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case wi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${wi[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let s=r.length-2;s>=0;--s)r[s]=r[s+1]*n[s+1];let a=BK(n,!1),i=I.getArrayFromDType(this.valuesDType,I.sizeFromShape(a));if(r[0]*n[0]>0){let s=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)s=this.calculateOutputIndex(o-1,s,r[o],n[o]);this.setOutput(this.raggedRank,s,i,a)}return[a,i]}setOutput(t,n,r,a){if(0===r.length)return;let i=this.values,s=r,o=a.slice();o=o.slice(t+1);let l=I.sizeFromShape(o),u=n.length,c=this.defaultValue;if(c.length!==l&&1!==c.length){let f=this.defaultValueShape;V(()=>{let m=B(c,f);c=Jc(m,o).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let m=f<u?n[f]:-1;if(m!==p){if(d<p){let g=i.subarray(h*l);zK(s.subarray(d*l),g,(p-d)*l)}if(f>=u&&(m=Math.floor(r.length/l)),m>p)if(1===this.defaultValue.length)s.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;)zK(s.slice(p*l),c,l),++p;m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}else++p}}};function zK(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function BK(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function VK(e,t,n,r,a,i,s,o,l,u){return new eFe(e,t,n,r,a,i,s,o,l,u).compute()}function uM(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return I.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=I.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var UK=Ds(e=>1/Math.sqrt(e)),tFe=wl(kc,UK),nFe={kernelName:kc,backendName:"cpu",kernelFunc:tFe};function vd(e,t,n,r,a,i,s,o,l,u){let c=[r/a,a],h=e.values,d=t.values;if(0===r)return Je(n,t.dtype);let p=l instanceof En?l:Je(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<i;f++){let m=[],g=0;for(let y=0;y<s;y++){let v=h[f*s+y];m.push(v),g+=v*o[y]}if(g<0||g>=r/a)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<a;y++)u?p.values[g*a+y]+=d[f*a+y]:p.values[g*a+y]=0===t.rank?d[0]:d[f*a+y]}return p}var rFe=Ds(e=>1/(1+Math.exp(-e))),WK=Ot(Mc,e=>1/(1+Math.exp(-e))),aFe={kernelName:Mc,backendName:"cpu",kernelFunc:WK};function BI(e,t,n,r,a){let i=Vn.isSliceContinous(r,t,n),s=I.sizeFromShape(n),o=I.computeStrides(r);if(i){let h=Vn.computeFlatOffset(t,o);return"string"===a?e.slice(h,h+s):e.subarray(h,h+s)}let u=Je(r,a,"string"===a?E.fromUint8ToStringArray(e):e),c=Je(n,a);for(let h=0;h<c.size;++h){let d=c.indexToLoc(h),p=d.map((f,m)=>f+t[m]);c.set(u.get(...p),...d)}return"string"===a?E.fromStringArrayToUint8(c.values):c.values}function bd(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:s}=r;Ie(a,"slice");let[o,l]=Vn.parseSliceParams(a,i,s);Vn.assertParamsValid(a,o,l);let c=BI(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}var iFe={kernelName:Xp,backendName:"cpu",kernelFunc:bd};function jK(e,t,n,r,a,i,s){let o=t[0],l=i[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[I.getArrayFromDType(n,0),[0,h],I.getArrayFromDType(a,0),u,c]}let d=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*h];if(y<0)throw new Error(E.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],d=d&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){let y=0===f[g];u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){let g=e,y=r;for(let v=0;v<o;++v)c[v]=v;return[g,[o,h],y,u,c]}{let g=f[l-1],y=I.getArrayFromDType(n,g*h),v=I.getArrayFromDType(a,g),b=new Array(l).fill(0);for(let w=0;w<o;++w){let x=e[w*h],k=(0===x?0:f[x-1])+b[x];b[x]++;for(let T=0;T<h;++T)y[k*h+T]=e[w*h+T];v[k]=r[w],c[w]=k}for(let w=0;w<l;++w)if(0===b[w]){let x=0===w?0:f[w-1];y[x*h+0]=w;for(let C=1;C<h;++C)y[x*h+C]=0;v[x]=s}return[y,[g,h],v,u,c]}}function HK(e,t,n,r,a){let i=I.sizeFromShape(r),s=t[0],o=a.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let g=a[m];if(-1===g){if(-1!==c)throw new Error(E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(g<0)throw new Error(E.getSparseReshapeNegativeOutputDimErrorMessage(m,g));u*=g,l.push(g)}}if(-1!==c){if(u<=0)throw new Error(E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(i/u);if(u*m!==i)throw new Error(E.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=m}if(I.sizeFromShape(l)!==i)throw new Error(E.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let h=r.length,d=[];if(h>0){d[h-1]=1;for(let m=h-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}let f=I.getArrayFromDType(n,s*o);for(let m=0;m<s;++m){let g=0;for(let y=0;y<h;++y)g+=e[m*h+y]*d[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/p[y]),g%=p[y]}return[f,[s,o],l]}function cM(e,t,n,r,a,i=!1,s=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=c;let d=h.reduce((v,b)=>v*b,1),p=I.getArrayFromDType(n,d);if(0===o)return c>0&&p.fill(s),[p,h];if(c<=0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let v=0;if(m<o){if(v=a[m],y===v){++m;continue}if(y>=v)throw new Error(E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(s,g*u,y*u);for(let b=f;b<m;++b){let w=r[b];if(w<0||w>=l[0])throw new Error(E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b,r[b],l[0]));for(let x=0;x<u;x++)p[y*u+x]+=e[w*u+x]}if(i)for(let b=0;b<u;b++)p[y*u+b]/=m-f;if(f=m,++m,g=y+1,y=v,m>o)break}return g<c&&p.fill(s,g*u,c*u),[p,h]}var sFe=Ds(e=>Math.sqrt(e)),oFe=Ot(Fc,e=>Math.sqrt(e)),lFe={kernelName:Fc,backendName:"cpu",kernelFunc:oFe},GK=wn((e,t)=>{let n=e-t;return n*n}),uFe=Hn(Pc,GK),cFe={kernelName:Pc,backendName:"cpu",kernelFunc:uFe},qK=Ds((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),dFe=wl(gy,qK),hFe={kernelName:gy,backendName:"cpu",kernelFunc:dFe};function KK(e,t,n,r){let a=Je(e,t.dtype);for(let i=0;i<a.size;i++){let s=a.indexToLoc(i),o=new Array(s.length);for(let l=0;l<o.length;l++)o[l]=s[l]*n[l]+r[l];a.set(t.get(...o),...s)}return a}var pFe=class{constructor(e,t,n,r,a,i){this.separator=I.encodeString(e),this.nGramWidths=t,this.leftPad=I.encodeString(n),this.rightPad=I.encodeString(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,i){for(let s=0;s<a;++s){let o=this.getPadWidth(i),l=Math.max(0,o-s),u=Math.max(0,o-(a-(s+1))),c=i-(l+u),h=t+(l>0?0:s-o),d=0;d+=l*this.leftPad.length;for(let y=0;y<c;++y)d+=e[h+y].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+s]=new Uint8Array(d);let f=n[r+s],m=0,g=y=>y.forEach(v=>f[m++]=v);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<c-1;++y)g(e[h+y]),g(this.separator);if(c>0){g(e[h+c-1]);for(let y=0;y<u;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<u-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(0!==o)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,i=I.getArrayFromDType("int32",r);if(0===n||0===r){let o=new Array(n);for(let l=0;l<=a;++l)i[l]=0;return[o,i]}i[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&0===u&&(u=1),i[o]=i[o-1]+u}let s=new Array(i[a]);for(let o=0;o<a;++o){let l=t[o],u=i[o];if(this.nGramWidths.forEach(c=>{let d=this.getNumNGrams(t[o+1]-t[o],c);this.createNGrams(e,l,s,u,d,c),u+=d}),this.preserveShort&&u===i[o]){let c=t[o+1]-t[o];if(0===c)continue;this.createNGrams(e,l,s,u,1,c+2*this.padWidth)}}return[s,i]}};function dM(e,t,n,r,a,i,s,o){return new pFe(n,r,a,i,s,o).compute(e,t)}function fFe(e,t,n,r){if(!e.length)return;if(0===t.length){for(let i=0;i<e.length;++i)r.push(e.subarray(i,i+1));return}if(1===t.length){let i=t[0],s=e.indexOf(i);for(;-1!==s;){let o=e.subarray(0,s);(!n||0!==o.length)&&r.push(o),s=(e=e.subarray(s+1)).indexOf(i)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){let s=e.subarray(a,i);(!n||0!==s.length)&&r.push(s),a=i+1}}function hM(e,t,n){let r=e.length,a=[],i=0,s=0,o=new Array(r);for(let d=0;d<r;++d){let p=a.length;fFe(e[d],t,n,a);let f=a.length-p;o[d]=f,i+=f,s=Math.max(s,f)}let l=I.getArrayFromDType("int32",2*i),u=new Array(i),c=[r,s],h=0;for(let d=0;d<r;++d)for(let p=0;p<o[d];++p)l[2*h]=d,l[2*h+1]=p,u[h]=a[h],++h;return[l,u,c]}function pM(e,t){let n=I.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=I.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var XK=wn((e,t)=>e-t),mFe=aM((e,t,n,r)=>({real:e-n,imag:t-r})),fM=Hn(Lc,XK,mFe),gFe={kernelName:Lc,backendName:"cpu",kernelFunc:fM};function ZK(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=Je(n,e.dtype);for(let a=0;a<r.values.length;++a){let i=r.indexToLoc(a),s=new Array(e.rank);for(let l=0;l<s.length;l++)s[l]=i[l]%e.shape[l];let o=e.locToIndex(s);r.values[a]=e.values[o]}return r}var gv=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function YK(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2);YK(e,t,Math.max(n,Math.floor(t-l*c/o+h)),Math.min(r,Math.floor(t+(o-l)*c/o+h)))}let a=e[t],i=n,s=r;for(I.swap(e,n,t),gv(e[r],a)>0&&I.swap(e,n,r);i<s;){for(I.swap(e,i,s),i++,s--;gv(e[i],a)<0;)i+=1;for(;gv(e[s],a)>0;)s-=1}0===gv(e[n],a)?I.swap(e,n,s):(s+=1,I.swap(e,s,r)),s<=t&&(n=s+1),t<=s&&(r=s-1)}}function QK(e,t,n,r,a){let i=t[t.length-1],[s,o]=[e.length/i,i],l=I.getTypedArrayFromDType(n,s*r),u=I.getTypedArrayFromDType("int32",s*r);for(let h=0;h<s;h++){let d=h*o,p=e.subarray(d,d+o),f=new Array(p.length);p.forEach((v,b)=>f[b]={value:v,index:b}),r<f.length&&(YK(f,r),f=f.slice(0,r)),a&&f.sort(gv);let m=h*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let v=0;v<r;v++)g[v]=f[v].value,y[v]=f[v].index}let c=t.slice();return c[c.length-1]=r,[Je(c,n,l),Je(c,"int32",u)]}function mM(e,t,n,r){let a=I.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let f=0;f<a;f++)i[0]*=n[f];i[1]=n[a];for(let f=a+1;f<n.length;f++)i[2]*=n[f];let s=new Map,o=new Int32Array(n[a]),l=new En(i,r,e),u=[],c=1===i[0]&&1===i[2];for(let f=0;f<n[a];f++){let m;if(c)m=e[f].toString();else{let y=[];for(let v=0;v<i[0];v++)for(let b=0;b<i[2];b++)y.push(l.get(v,f,b));m=y.join(",")}let g=s.get(m);if(null!=g)o[f]=g;else{let y=s.size;s.set(m,y),o[f]=y,u.push(f)}}let h=i.slice();h[1]=s.size;let d=new En(h,r);u.forEach((f,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)d.set(l.get(g,f,y),g,m,y)});let p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:o}}var yFe="4.16.0";C0("cpu",()=>new nM,1);var JK=Ot(ju,e=>e>=0?e:Math.exp(e)-1),vFe={kernelName:ju,backendName:"cpu",kernelFunc:JK};function e7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r;Ie([a],"leakyRelu");let s=I.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=I.getTypedArrayFromDType("float32",s);for(let u=0;u<o.length;u++)l[u]=o[u]<0?i*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var bFe={kernelName:nc,backendName:"cpu",kernelFunc:e7},wFe=wn((e,t)=>e<0?t*e:e);function t7(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;Ie([r,a],"prelu");let i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,[o,l]=wFe(r.shape,a.shape,i,s,"float32");return n.makeTensorInfo(l,"float32",o)}var xFe={kernelName:vc,backendName:"cpu",kernelFunc:t7},n7=Ot(xc,e=>Math.max(0,e)),IFe={kernelName:xc,backendName:"cpu",kernelFunc:n7},r7=Ot(_c,e=>Math.min(Math.max(0,e),6)),SFe={kernelName:_c,backendName:"cpu",kernelFunc:r7};function VI(e,t,n,r,a){if("linear"===n)return Ts({inputs:{x:t},backend:e});if("relu"===n)return n7({inputs:{x:t},backend:e});if("elu"===n)return JK({inputs:{x:t},backend:e});if("relu6"===n)return r7({inputs:{x:t},backend:e});if("prelu"===n)return t7({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return e7({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return WK({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Qt(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,s=I.sizeFromShape(a.shape),o=I.inferFromImplicitShape(i,s),l=I.sizeFromShape(o);I.assert(s===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let h=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=o,h.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var _Fe={kernelName:Up,backendName:"cpu",kernelFunc:Qt};function a7(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:i}=t,{transposeA:s,transposeB:o}=r;Ie([a,i],"matMul");let l=a.shape.length,u=i.shape.length,c=s?a.shape[l-2]:a.shape[l-1],h=o?i.shape[u-1]:i.shape[u-2],d=s?a.shape[l-1]:a.shape[l-2],p=o?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=I.sizeFromShape(f),y=I.sizeFromShape(m),v=mf.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);I.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`);let w=o?[y,p,h]:[y,h,p],x=Qt({inputs:{x:a},backend:n,attrs:{shape:s?[g,c,d]:[g,d,c]}}),C=Qt({inputs:{x:i},backend:n,attrs:{shape:w}}),k=s?x.shape[1]:x.shape[2],T=s?x.shape[2]:x.shape[1],A=o?C.shape[1]:C.shape[2],R=Math.max(g,y),M=n.data.get(x.dataId).values,_=n.data.get(C.dataId).values,$=I.computeStrides(x.shape),U=I.computeStrides(C.shape),[j,G,K]=s?[$[0],1,$[1]]:[$[0],$[1],1],[X,Y,ee]=o?[1,U[1],U[0]]:[U[1],1,U[0]],te=T*A,se=Je([R,T,A],x.dtype),re=se.values,oe=n.blockSize;for(let le=0;le<R;le++){let Ce=le%g,fe=le%y;for(let _e=0;_e<T;_e+=oe){let De=Math.min(_e+oe,T);for(let Fe=0;Fe<A;Fe+=oe){let rt=Math.min(Fe+oe,A);for(let dt=0;dt<k;dt+=oe){let qt=Math.min(dt+oe,k);for(let At=_e;At<De;At++)for(let St=Fe;St<rt;St++){let _t=0;for(let Ye=dt;Ye<qt;Ye++)_t+=M[Ce*j+At*G+Ye*K]*_[Ye*X+St*Y+fe*ee];re[le*te+(At*A+St)]+=_t}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(C),n.makeTensorInfo(v,se.dtype,se.values)}var CFe={kernelName:Mu,backendName:"cpu",kernelFunc:a7},kFe={kernelName:Vc,backendName:"cpu",kernelFunc:function EFe(e){let d,p,f,{inputs:t,backend:n,attrs:r}=e,{a,b:i,bias:s,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r,m=[];d=a7({inputs:{a,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),s&&(p=Lf({inputs:{a:d,b:s},backend:n}),m.push(d),d=p),c&&(f=VI(n,d,c,o,h),m.push(d),d=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return d}},NFe=Ot(Su,e=>Math.acos(e)),TFe={kernelName:Su,backendName:"cpu",kernelFunc:NFe},DFe=Ot(_u,e=>Math.acosh(e)),AFe={kernelName:_u,backendName:"cpu",kernelFunc:DFe},RFe={kernelName:Cu,backendName:"cpu",kernelFunc:function MFe(e){let{inputs:t,backend:n}=e,r=t;Ie(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),i=Je(r[0].shape,r[0].dtype),s=i.values;for(let o=0;o<r.length;o++){let l=a[o];for(let u=0;u<s.length;u++)s[u]+=l[u]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}},OFe={kernelName:rp,backendName:"cpu",kernelFunc:function FFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;Ie(a,"all");let o=I.parseAxisParam(i,a.shape),l=o,u=E.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=la({inputs:{x:a},backend:n,attrs:{perm:u}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("all",l,c.shape.length);let[h,d]=E.computeOutAndReduceShapes(c.shape,l),p=I.sizeFromShape(d),f=I.makeZerosTypedArray(I.sizeFromShape(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,b=m[v];for(let w=0;w<p;++w)b=b&&m[v+w];f[y]=b}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(h,c.dtype,f);if(s){let v=Qt({inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),v}return g}},PFe={kernelName:ap,backendName:"cpu",kernelFunc:function $Fe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;Ie(a,"any");let o=I.parseAxisParam(i,a.shape),l=o,u=E.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=la({inputs:{x:a},backend:n,attrs:{perm:u}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("any",l,c.shape.length);let[h,d]=E.computeOutAndReduceShapes(c.shape,l),p=I.sizeFromShape(d),f=I.makeZerosTypedArray(I.sizeFromShape(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,b=m[v];for(let w=0;w<p;++w)b=b||m[v+w];f[y]=b}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(h,c.dtype,f);if(s){let v=Qt({inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),v}return g}},zFe={kernelName:ip,backendName:"cpu",kernelFunc:function LFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;Ie(a,"argMax");let s=I.parseAxisParam(i,a.shape),o=E.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=la({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=E.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],E.assertAxesAreInnerMostDims("argMax",s,l.shape.length);let[c,h]=E.computeOutAndReduceShapes(l.shape,s),d=I.sizeFromShape(c),p=I.makeZerosTypedArray(d,"int32"),f=I.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,v=m[y],b=0;for(let w=0;w<f;++w){let x=m[y+w];x>v&&(v=x,b=w)}p[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}},VFe={kernelName:sp,backendName:"cpu",kernelFunc:function BFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;Ie(a,"argMin");let s=I.parseAxisParam(i,a.shape),o=E.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=la({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=E.getInnerMostAxes(s.length,l.shape.length)),s=[s[0]],E.assertAxesAreInnerMostDims("argMin",s,l.shape.length);let[c,h]=E.computeOutAndReduceShapes(l.shape,s),d=I.sizeFromShape(c),p=I.makeZerosTypedArray(d,"int32"),f=I.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,v=m[y],b=0;for(let w=0;w<f;++w){let x=m[y+w];x<v&&(v=x,b=w)}p[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}},UFe=Ot(Eu,e=>Math.asin(e)),WFe={kernelName:Eu,backendName:"cpu",kernelFunc:UFe},jFe=Ot(ku,e=>Math.asinh(e)),HFe={kernelName:ku,backendName:"cpu",kernelFunc:jFe},GFe=Ot(Nu,e=>Math.atan(e)),qFe={kernelName:Nu,backendName:"cpu",kernelFunc:GFe},KFe=wn((e,t)=>Math.atan2(e,t)),XFe=Hn(Du,KFe),ZFe={kernelName:Du,backendName:"cpu",kernelFunc:XFe},YFe=Ot(Tu,e=>Math.atanh(e)),QFe={kernelName:Tu,backendName:"cpu",kernelFunc:YFe};function gM(e,t,n,r,a,i){let s=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Je(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],v=a.outShape[2]*a.outShape[3],b=a.outShape[3];for(let w=0;w<a.batchSize;++w){let x=w*y,C=w*r[0];for(let k=0;k<a.inChannels;++k)for(let T=0;T<a.outHeight;++T){let A=T*s-d,R=Math.max(0,A),M=Math.min(a.inHeight,c+A),_=x+T*v;for(let $=0;$<a.outWidth;++$){let U=$*o-p,j=Math.max(0,U),G=Math.min(a.inWidth,h+U),K=f,X=0,Y=0;for(let te=R;te<M;te+=l){let se=C+te*r[1];for(let re=j;re<G;re+=u){let le=e[se+re*r[2]+k];"max"===i&&le>K?K=le:"avg"===i&&(X+=le,Y++)}if(isNaN(K))break}g[_+$*b+k]="avg"===i?X/Y:K}}}return m}function i7(e,t,n,r,a=!1,i=!1){let s=Je(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Je(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let v=0;v<r.outHeight;++v){let b=v*o-p,w=b;for(;w<0;)w+=u;let x=Math.min(r.inHeight,h+b);for(let C=0;C<r.outWidth;++C){let k=C*l-f,T=k;for(;T<0;)T+=c;let A=Math.min(r.inWidth,d+k),R=Number.NEGATIVE_INFINITY,M=-1;for(let _=w;_<x;_+=u){let $=_-b;for(let U=T;U<A;U+=c){let j=U-k,G=m.get(g,_,U,y);G>R&&(R=G,M=a?i?((g*r.inHeight+_)*r.inWidth+U)*r.inChannels+y:(_*r.inWidth+U)*r.inChannels+y:$*d+j)}}s.set(M,g,v,C,y)}}return s}function s7(e,t,n,r,a,i){let s=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,v="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Je(a.outShape,n),w=b.values,x=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],C=a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[3]*a.outShape[4],T=a.outShape[4];for(let A=0;A<a.batchSize;++A){let R=A*x,M=A*r[0];for(let _=0;_<a.inChannels;++_)for(let $=0;$<a.outDepth;++$){let U=$*s-m,j=U;for(;j<0;)j+=u;let G=Math.min(a.inDepth,d+U),K=R+$*C;for(let X=0;X<a.outHeight;++X){let Y=X*o-g,ee=Y;for(;ee<0;)ee+=c;let te=Math.min(a.inHeight,p+Y),se=K+X*k;for(let re=0;re<a.outWidth;++re){let oe=re*l-y,le=oe;for(;le<0;)le+=h;let Ce=Math.min(a.inWidth,f+oe),fe=se+re*T,_e=v,De=0,Fe=0;for(let dt=j;dt<G;dt+=u){let qt=M+dt*r[1];for(let At=ee;At<te;At+=c){let St=qt+At*r[2];for(let _t=le;_t<Ce;_t+=h){let Jt=e[St+_t*r[3]+_];if("max"===i&&Jt>_e?_e=Jt:"avg"===i&&(De+=Jt,Fe++),isNaN(_e))break}if(isNaN(_e))break}if(isNaN(_e))break}w[fe+_]="avg"===i?De/Math.max(Fe,1):_e}}}}return b}var tOe={kernelName:Au,backendName:"cpu",kernelFunc:function eOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;I.assert(E.eitherStridesOrDilationsAreOne(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let h,c=E.computePool2DInfo(a.shape,i,s,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&I.arraysEqual(c.inShape,c.outShape))h=Ts({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,p=I.computeStrides(a.shape),f=gM(d,0,a.dtype,p,c,"avg");h=n.makeTensorInfo(c.outShape,a.dtype,f.values)}return h}},rOe={kernelName:op,backendName:"cpu",kernelFunc:function nOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r;Ie(a,"avgPool3d");let c=E.computePool3DInfo(a.shape,i,s,1,o,l,u),d=s7(n.data.get(a.dataId).values,0,a.dtype,I.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}},iOe={kernelName:ny,backendName:"cpu",kernelFunc:function aOe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r;Ie([a,i],"avgPool3DGrad");let c=E.computePool3DInfo(i.shape,s,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,v=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,C=c.effectiveFilterWidth,k=w-1-c.padInfo.front,T=C-1-c.padInfo.left,A=x-1-c.padInfo.top,R=Je(i.shape,"float32"),M=1/(f*m*g),_=n.bufferSync(a);for(let $=0;$<c.batchSize;++$)for(let U=0;U<c.inChannels;++U)for(let j=0;j<c.inDepth;++j)for(let G=0;G<c.inHeight;++G)for(let K=0;K<c.inWidth;++K){let X=j-k,Y=G-A,ee=K-T,te=0;for(let se=0;se<w;se+=y){let re=(X+se)/h;if(!(re<0||re>=c.outDepth||Math.floor(re)!==re))for(let oe=0;oe<x;oe+=v){let le=(Y+oe)/d;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let Ce=0;Ce<C;Ce+=b){let fe=(ee+Ce)/p;fe<0||fe>=c.outWidth||Math.floor(fe)!==fe||(te+=_.get($,re,le,fe,U))}}}R.set(te*M,$,j,G,K,U)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}},oOe={kernelName:ty,backendName:"cpu",kernelFunc:function sOe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i;Ie([a,i],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=E.computePool2DInfo(s.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,v=c.effectiveFilterWidth,b=v-1-c.padInfo.left,w=y-1-c.padInfo.top,x=Je(s.shape,"float32"),C=1/(p*f),k=n.data.get(a.dataId).values,T=Je(a.shape,"float32",k);for(let A=0;A<c.batchSize;++A)for(let R=0;R<c.inChannels;++R)for(let M=0;M<c.inHeight;++M)for(let _=0;_<c.inWidth;++_){let $=M-w,U=_-b,j=0;for(let G=0;G<y;G+=m){let K=($+G)/h;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let X=0;X<v;X+=g){let Y=(U+X)/d;Y<0||Y>=c.outWidth||Math.floor(Y)!==Y||(j+=T.get(A,K,Y,R))}}x.set(j*C,A,M,_,R)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},uOe={kernelName:Zu,backendName:"cpu",kernelFunc:function lOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:i,offset:s,mean:o,variance:l}=t;I.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I.assert(null==s||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I.assert(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ie([a,o,l,i,s],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=s?n.data.get(s.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,v=d.length,b=h.length,w=0,x=0,C=0,k=0;for(let T=0;T<c.length;++T)m[T]=f[w++]+(c[T]-h[x++])*p[C++]/Math.sqrt(d[k++]+u),w>=g&&(w=0),x>=b&&(x=0),C>=y&&(C=0),k>=v&&(k=0);return n.makeTensorInfo(a.shape,a.dtype,m)}},dOe={kernelName:lp,backendName:"cpu",kernelFunc:function cOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r;Ie([a],"batchToSpaceND");let o=i.reduce((y,v)=>y*v),l=E.getReshaped(a.shape,i,o),u=E.getPermuted(l.length,i.length),c=E.getReshapedPermuted(a.shape,i,o),h=E.getSliceBeginCoords(s,i.length),d=E.getSliceSize(c,s,i.length),p=Qt({inputs:{x:a},backend:n,attrs:{shape:l}}),f=la({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Qt({inputs:{x:f},backend:n,attrs:{shape:c}}),g=bd({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}},pOe={kernelName:up,backendName:"cpu",kernelFunc:function hOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s}=r,u=iM(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,u)}},mOe={kernelName:ry,backendName:"cpu",kernelFunc:function fOe(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,o=E.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},gOe=Ot(Go,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),yOe={kernelName:Go,backendName:"cpu",kernelFunc:gOe},bOe={kernelName:ay,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(I.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.imag,o=n.data.get(a.complexTensorInfos.real.dataId).values,l=n.data.get(s.dataId).values;for(let u=0;u<o.length;u++)r[u]=Math.hypot(o[u],l[u]);return n.makeOutput(r,t.shape,"float32")}};function zf(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var wOe={kernelName:h0,backendName:"cpu",kernelFunc:zf};function Bf(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=I.parseAxisParam(a,t[0].shape)[0],s=t.map(m=>m.shape);E.assertParamsConsistent(s,i);let o=E.computeOutShape(t.map(m=>m.shape),i);if(0===I.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>I.sizeFromShape(m.shape)>0);if(1===l.length)return Ts({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let m=l.map(w=>yd({inputs:{input:w},backend:n})),g=l.map(w=>zf({inputs:{input:w},backend:n})),y=Bf({inputs:m,backend:n,attrs:{axis:i}}),v=Bf({inputs:g,backend:n,attrs:{axis:i}}),b=Ra({inputs:{real:y,imag:v},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),b}let u=l.map(m=>{let g=[-1,I.sizeFromShape(m.shape.slice(i))];return Qt({inputs:{x:m},backend:n,attrs:{shape:g}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=E.computeOutShape(u.map(m=>m.shape),1);let d=sM(c,o,t[0].dtype,1===u[0].shape[0]),p=E.computeOutShape(l.map(m=>m.shape),i),f=n.makeTensorInfo(p,t[0].dtype,d);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var xOe={kernelName:dp,backendName:"cpu",kernelFunc:Bf};function o7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Ie([a,i],"conv2d");let h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,i.shape,s,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,v=d.padInfo.top,b="channelsLast"===d.dataFormat,w=new En(d.outShape,a.dtype),x=I.computeStrides(a.shape),C=I.computeStrides(i.shape),k=x[0],T=b?x[1]:x[2],A=b?x[2]:1,R=b?1:x[1],M=w.strides[0],_=b?w.strides[1]:w.strides[2],$=b?w.strides[2]:1,U=b?1:w.strides[1],j=n.data.get(a.dataId).values,G=n.data.get(i.dataId).values,K=w.values;for(let X=0;X<d.batchSize;++X){let Y=X*k,ee=X*M;for(let te=0;te<d.outHeight;++te){let se=ee+te*_,re=te*d.strideHeight-v;for(let oe=0;oe<p;++oe){let le=re+oe*m;if(le<0||le>=d.inHeight)continue;let Ce=oe*C[0],fe=Y+le*T;for(let _e=0;_e<d.outWidth;++_e){let De=se+_e*$,Fe=_e*d.strideWidth-y;for(let rt=0;rt<f;++rt){let dt=Fe+rt*g;if(dt<0||dt>=d.inWidth)continue;let At=fe+dt*A,St=Ce+rt*C[1];for(let _t=0;_t<d.inChannels;++_t){let Ye=j[At+_t*R];for(let Jt=0;Jt<d.outChannels;++Jt)K[De+Jt*U]+=Ye*G[St+Jt];St+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,K)}var IOe={kernelName:Ou,backendName:"cpu",kernelFunc:o7},_Oe={kernelName:a0,backendName:"cpu",kernelFunc:function SOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Ie([a,i],"conv2dBackpropFilter");let h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,c,s,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,v=new En(d.filterShape,"float32"),b=d.padInfo.left,w=d.padInfo.top,x=n.data.get(a.dataId).values,C=n.data.get(i.dataId).values,k=new En(a.shape,a.dtype,x),T=new En(i.shape,i.dtype,C);for(let A=0;A<m;++A){let R=Math.max(0,Math.ceil((w-A)/p)),M=Math.min(d.outHeight,(d.inHeight+w-A)/p);for(let _=0;_<g;++_){let $=Math.max(0,Math.ceil((b-_)/f)),U=Math.min(d.outWidth,(d.inWidth+b-_)/f);for(let j=0;j<d.inChannels;++j)for(let G=0;G<d.outChannels;++G){let K=0;for(let X=0;X<d.batchSize;++X)for(let Y=R;Y<M;++Y){let ee=A+Y*p-w;for(let te=$;te<U;++te){let se=_+te*f-b;K+=y?k.get(X,ee,se,j)*T.get(X,Y,te,G):k.get(X,j,ee,se)*T.get(X,G,Y,te)}}v.set(K,A,_,j,G)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},EOe={kernelName:$u,backendName:"cpu",kernelFunc:function COe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:s,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;Ie([a,i],"conv2dBackpropInput");let h=I.computeStrides(i.shape),d=I.computeStrides(a.shape),p=E.convertConv2DDataFormat(u),f=E.computeConv2DInfo(s,i.shape,o,1,l,c,!1,p),m=new En(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,[b,w,x]=h,{batchSize:C,filterHeight:k,filterWidth:T,inChannels:A,inHeight:R,inWidth:M,outChannels:_,outHeight:$,outWidth:U,strideHeight:j,strideWidth:G}=f;p=f.dataFormat;let K=k-1-f.padInfo.top,X=T-1-f.padInfo.left,Y="channelsLast"===p,ee=m.strides[0],te=Y?m.strides[1]:m.strides[2],se=Y?m.strides[2]:1,re=Y?1:m.strides[1],oe=d[0],le=Y?d[1]:d[2],Ce=Y?d[2]:1,fe=Y?1:d[1];for(let _e=0;_e<C;++_e)for(let De=0;De<A;++De)for(let Fe=0;Fe<R;++Fe){let rt=Fe-K,dt=Math.max(0,Math.ceil(rt/j)),qt=Math.min($,(k+rt)/j);for(let At=0;At<M;++At){let St=At-X,_t=Math.max(0,Math.ceil(St/G)),Ye=Math.min(U,(T+St)/G),Jt=0;for(let Mn=dt;Mn<qt;++Mn){let ti=Mn*j-rt;for(let gr=_t;gr<Ye;++gr){let ni=oe*_e+le*Mn+Ce*gr,da=b*(k-1-ti)+w*(T-1-(gr*G-St))+x*De;for(let jt=0;jt<_;++jt)Jt+=y[ni+fe*jt]*v[da+jt]}}g[ee*_e+te*Fe+se*At+re*De]=Jt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},NOe={kernelName:Pu,backendName:"cpu",kernelFunc:function kOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;Ie([a,i],"conv3d");let u=E.computeConv3DInfo(a.shape,i.shape,s,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,v=g.left,b=g.top,w=new En(u.outShape,a.dtype),x=n.data.get(a.dataId).values,C=n.data.get(i.dataId).values,k=w.values,T=I.computeStrides(a.shape),A=I.computeStrides(i.shape);for(let R=0;R<u.batchSize;++R){let M=R*T[0],_=R*w.strides[0];for(let $=0;$<u.outDepth;++$){let U=_+$*w.strides[1],j=$*u.strideDepth-y;for(let G=0;G<c;++G){let K=j+G*p;if(K<0||K>=u.inDepth)continue;let X=G*A[0],Y=M+K*T[1];for(let ee=0;ee<u.outHeight;++ee){let te=U+ee*w.strides[2],se=ee*u.strideHeight-b;for(let re=0;re<h;++re){let oe=se+re*f;if(oe<0||oe>=u.inHeight)continue;let le=X+re*A[1],Ce=Y+oe*T[2];for(let fe=0;fe<u.outWidth;++fe){let _e=te+fe*u.outChannels,De=fe*u.strideWidth-v;for(let Fe=0;Fe<d;++Fe){let rt=De+Fe*m;if(rt<0||rt>=u.inWidth)continue;let qt=Ce+rt*u.inChannels,At=le+Fe*A[2];for(let St=0;St<u.inChannels;++St){let _t=x[qt+St];for(let Ye=0;Ye<u.outChannels;++Ye)k[_e+Ye]+=_t*C[At+Ye];At+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},DOe={kernelName:hp,backendName:"cpu",kernelFunc:function TOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r;Ie([a,i],"conv3dBackpropFilterV2");let u=I.computeStrides(a.shape),c=I.computeStrides(i.shape),h=E.computeConv3DInfo(a.shape,l,s,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,v=new En(h.filterShape,"float32"),b=v.values,[w,x,C,k]=v.strides,T=n.data.get(i.dataId).values,[A,R,M,_]=c,$=n.data.get(a.dataId).values,[U,j,G,K]=u,X=h.padInfo.front,Y=h.padInfo.left,ee=h.padInfo.top;for(let te=0;te<m;++te){let se=Math.max(0,Math.ceil((X-te)/d)),re=Math.min(h.outDepth,(h.inDepth+X-te)/d),oe=te*w;for(let le=0;le<g;++le){let Ce=Math.max(0,Math.ceil((ee-le)/p)),fe=Math.min(h.outHeight,(h.inHeight+ee-le)/p),_e=le*x+oe;for(let De=0;De<y;++De){let Fe=Math.max(0,Math.ceil((Y-De)/f)),rt=Math.min(h.outWidth,(h.inWidth+Y-De)/f),dt=De*C+_e;for(let qt=0;qt<h.inChannels;++qt){let At=qt*k+dt;for(let St=0;St<h.outChannels;++St){let _t=0;for(let Ye=0;Ye<h.batchSize;++Ye){let Jt=Ye*U,Oa=Ye*A;for(let Mn=se;Mn<re;++Mn){let ti=(te+Mn*d-X)*j+Jt,gr=Mn*R+Oa;for(let ca=Ce;ca<fe;++ca){let ni=(le+ca*p-ee)*G+ti,da=ca*M+gr;for(let jt=Fe;jt<rt;++jt)_t+=$[(De+jt*f-Y)*K+ni+qt]*T[jt*_+da+St]}}}b[At+St]=_t}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},MOe={kernelName:pp,backendName:"cpu",kernelFunc:function AOe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r;Ie([a],"conv3dBackpropInputV2");let u=I.computeStrides(a.shape),c=I.computeStrides(i.shape),h=E.computeConv3DInfo(l,i.shape,o,1,s),d=new En(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,v=n.data.get(a.dataId).values,[b,w,x,C]=u,k=n.data.get(i.dataId).values,[T,A,R,M]=c,{batchSize:_,filterDepth:$,filterHeight:U,filterWidth:j,inChannels:G,inDepth:K,inHeight:X,inWidth:Y,outChannels:ee,outDepth:te,outHeight:se,outWidth:re,strideDepth:oe,strideHeight:le,strideWidth:Ce}=h,fe=$-1-h.padInfo.front,_e=U-1-h.padInfo.top,De=j-1-h.padInfo.left;for(let Fe=0;Fe<_;++Fe)for(let rt=0;rt<G;++rt)for(let dt=0;dt<K;++dt){let qt=dt-fe,At=Math.max(0,Math.ceil(qt/oe)),St=Math.min(te,($+qt)/oe);for(let _t=0;_t<X;++_t){let Ye=_t-_e,Jt=Math.max(0,Math.ceil(Ye/le)),Oa=Math.min(se,(U+Ye)/le);for(let Mn=0;Mn<Y;++Mn){let ti=Mn-De,gr=Math.max(0,Math.ceil(ti/Ce)),ca=Math.min(re,(j+ti)/Ce),ni=0;for(let da=At;da<St;++da){let jt=da*oe-qt;for(let ha=Jt;ha<Oa;++ha){let $a=ha*le-Ye;for(let vo=gr;vo<ca;++vo){let Fs=b*Fe+w*da+x*ha+C*vo,Wv=T*($-1-jt)+A*(U-1-$a)+R*(j-1-(vo*Ce-ti))+M*rt;for(let Si=0;Si<ee;++Si)ni+=v[Fs+Si]*k[Wv+Si]}}}p[f*Fe+m*dt+g*_t+y*Mn+rt]=ni}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},ROe=Ot(Lu,e=>Math.cos(e)),FOe={kernelName:Lu,backendName:"cpu",kernelFunc:ROe},OOe=Ot(zu,e=>Math.cosh(e)),$Oe={kernelName:zu,backendName:"cpu",kernelFunc:OOe},LOe={kernelName:mp,backendName:"cpu",kernelFunc:function POe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:s}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=a.shape,f=i.shape[0],[m,g]=o,y=Je([f,m,g,p],"float32"),v=n.data.get(i.dataId).values,b=n.data.get(s.dataId).values,w=n.data.get(a.dataId).values,x=I.computeStrides(a.shape),C=I.computeStrides(y.shape);for(let k=0;k<f;k++){let T=4*k,A=v[T],R=v[T+1],M=v[T+2],_=v[T+3],$=b[k];if($>=c)continue;let U=m>1?(M-A)*(h-1)/(m-1):0,j=g>1?(_-R)*(d-1)/(g-1):0;for(let G=0;G<m;G++){let K=m>1?A*(h-1)+G*U:.5*(A+M)*(h-1);if(K<0||K>h-1)for(let X=0;X<g;X++)for(let Y=0;Y<p;Y++)y.values[Y+X*C[2]+G*C[1]+k*C[0]]=u;else if("bilinear"===l){let X=Math.floor(K),Y=Math.ceil(K),ee=K-X;for(let te=0;te<g;te++){let se=g>1?R*(d-1)+te*j:.5*(R+_)*(d-1);if(se<0||se>d-1){for(let Ce=0;Ce<p;Ce++)y.values[Ce+te*C[2]+G*C[1]+k*C[0]]=u;continue}let re=Math.floor(se),oe=Math.ceil(se),le=se-re;for(let Ce=0;Ce<p;Ce++){let fe=Ce+re*x[2]+X*x[1]+$*x[0],_e=w[fe];fe=Ce+oe*x[2]+X*x[1]+$*x[0];let De=w[fe];fe=Ce+re*x[2]+Y*x[1]+$*x[0];let Fe=w[fe];fe=Ce+oe*x[2]+Y*x[1]+$*x[0];let rt=w[fe],dt=_e+(De-_e)*le;fe=Ce+te*C[2]+G*C[1]+k*C[0],y.values[fe]=dt+(Fe+(rt-Fe)*le-dt)*ee}}}else for(let X=0;X<g;++X){let Y=g>1?R*(d-1)+X*j:.5*(R+_)*(d-1);if(Y<0||Y>d-1){for(let se=0;se<p;se++)y.values[se+X*C[2]+G*C[1]+k*C[0]]=u;continue}let ee=Math.round(Y),te=Math.round(K);for(let se=0;se<p;se++)y.values[se+X*C[2]+G*C[1]+k*C[0]]=w[se+ee*x[2]+te*x[1]+$*x[0]]}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},BOe={kernelName:fp,backendName:"cpu",kernelFunc:function zOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;Ie(a,"cumprod");let l=E.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=la({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=E.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let h=Ga(u.dtype,"int32"),d=I.makeOnesTypedArray(I.sizeFromShape(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){let b=m(y,v);if(0===v)d[b]=s?1:p[b];else{let w=m(y,v-1);d[b]=s?p[w]*d[w]:p[b]*d[w]}}let g=n.makeTensorInfo(u.shape,h,d);if(null!=l){let v=la({inputs:{x:g},backend:n,attrs:{perm:E.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),v}return g}},UOe={kernelName:Bu,backendName:"cpu",kernelFunc:function VOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;Ie(a,"cumsum");let l=E.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=la({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=E.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let h=Ga(u.dtype,"int32"),d=I.makeZerosTypedArray(I.sizeFromShape(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){let b=m(y,v);if(0===v)d[b]=s?0:p[b];else{let w=m(y,v-1);d[b]=s?p[w]+d[w]:p[b]+d[w]}}let g=n.makeTensorInfo(u.shape,h,d);if(null!=l){let v=la({inputs:{x:g},backend:n,attrs:{perm:E.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),v}return g}},jOe={kernelName:iy,backendName:"cpu",kernelFunc:function WOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s,binaryOutput:o}=r;if(1===a.shape.length){let c=iM(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,c)}if(2===a.shape.length){let c=dK(n.bufferSync(a),n.bufferSync(i),s,o);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},GOe={kernelName:gp,backendName:"cpu",kernelFunc:function HOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:s}=r;I.assert("NHWC"===s,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`);let o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],h=l*i,d=u*i,p=c/(i*i),f=n.data.get(a.dataId).values,m=new Float32Array(o*h*d*p),g=0;for(let y=0;y<o;++y)for(let v=0;v<h;++v){let b=Math.floor(v/i),w=v%i;for(let x=0;x<d;++x){let C=Math.floor(x/i),T=(w*i+x%i)*p;for(let A=0;A<p;++A)m[g++]=f[A+T+c*(C+u*(b+l*y))]}}return n.makeTensorInfo([o,h,d,p],a.dtype,m)}};function l7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l,dimRoundingMode:u}=r;Ie([a,i],"depthwiseConv2DNative");let c=I.computeStrides(a.shape),h=I.computeStrides(i.shape),d=l;null==d&&(d=[1,1]),I.assert(E.eitherStridesOrDilationsAreOne(s,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let p=E.computeConv2DInfo(a.shape,i.shape,s,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=p,b=v.left,w=v.top,x=p.outChannels/p.inChannels,C=new En(p.outShape,a.dtype),k=n.data.get(a.dataId).values,T=n.data.get(i.dataId).values,A=C.values;for(let R=0;R<p.batchSize;++R){let M=R*c[0],_=R*C.strides[0];for(let $=0;$<p.outHeight;++$){let U=_+$*C.strides[1],j=$*p.strideHeight-w;for(let G=0;G<f;++G){let K=j+G*g;if(K<0||K>=p.inHeight)continue;let X=G*h[0],Y=M+K*c[1];for(let ee=0;ee<p.outWidth;++ee){let te=U+ee*C.strides[2],se=ee*p.strideWidth-b;for(let re=0;re<m;++re){let oe=se+re*y;if(oe<0||oe>=p.inWidth)continue;let Ce=Y+oe*p.inChannels,fe=te,_e=X+re*h[1];for(let De=0;De<p.inChannels;++De){let Fe=k[Ce+De];for(let rt=0;rt<x;++rt)A[fe+rt]+=Fe*T[_e+rt];fe+=x,_e+=x}}}}}}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var qOe={kernelName:Vu,backendName:"cpu",kernelFunc:l7},XOe={kernelName:s0,backendName:"cpu",kernelFunc:function KOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;Ie([a,i],"depthwiseConv2dNativeBackpropFilter");let h=E.computeConv2DInfo(a.shape,c,s,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new En(h.filterShape,"float32"),y=h.padInfo.left,v=h.padInfo.top,b=h.outChannels/h.inChannels,w=n.data.get(a.dataId).values,x=new En(a.shape,a.dtype,w),C=n.data.get(i.dataId).values,k=new En(i.shape,i.dtype,C);for(let T=0;T<f;++T){let A=Math.max(0,Math.ceil((v-T)/d)),R=Math.min(h.outHeight,(h.inHeight+v-T)/d);for(let M=0;M<m;++M){let _=Math.max(0,Math.ceil((y-M)/p)),$=Math.min(h.outWidth,(h.inWidth+y-M)/p);for(let U=0;U<h.outChannels;++U){let j=Math.trunc(U/b),G=U%b,K=0;for(let X=0;X<h.batchSize;++X)for(let Y=A;Y<R;++Y){let ee=T+Y*d-v;for(let te=_;te<$;++te)K+=x.get(X,ee,M+te*p-y,j)*k.get(X,Y,te,U)}g.set(K,T,M,j,G)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},YOe={kernelName:o0,backendName:"cpu",kernelFunc:function ZOe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;Ie([a,i],"depthwiseConv2DNativeBackpropInput");let h=I.computeStrides(a.shape),d=I.computeStrides(i.shape),p=E.computeConv2DInfo(c,i.shape,s,o,l,u,!0),f=new En(p.inShape,"float32"),m=f.values,[g,y,v]=f.strides,b=n.data.get(a.dataId).values,[w,x,C]=h,k=n.data.get(i.dataId).values,[T,A,R]=d,{batchSize:M,filterHeight:_,filterWidth:$,inChannels:U,inHeight:j,inWidth:G,outChannels:K,outHeight:X,outWidth:Y,strideHeight:ee,strideWidth:te}=p,se=_-1-p.padInfo.top,re=$-1-p.padInfo.left,oe=K/U;for(let le=0;le<M;++le)for(let Ce=0;Ce<U;++Ce)for(let fe=0;fe<j;++fe){let _e=fe-se,De=Math.max(0,Math.ceil(_e/ee)),Fe=Math.min(X,(_+_e)/ee);for(let rt=0;rt<G;++rt){let dt=rt-re,qt=Math.max(0,Math.ceil(dt/te)),At=Math.min(Y,($+dt)/te),St=0;for(let _t=De;_t<Fe;++_t){let Ye=_t*ee-_e;for(let Jt=qt;Jt<At;++Jt){let Mn=w*le+x*_t+C*Jt,ti=T*(_-1-Ye)+A*($-1-(Jt*te-dt))+R*Ce;for(let gr=0;gr<oe;++gr)St+=b[Mn+(Ce*oe+gr)]*k[ti+gr]}}m[g*le+y*fe+v*rt+Ce]=St}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},JOe={kernelName:sy,backendName:"cpu",kernelFunc:function QOe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=I.sizeFromShape(r.shape),i=n.data.get(r.dataId).values,s=Je([a,a],r.dtype),o=s.values;for(let u=0;u<i.length;u++)o[u*a+u]=i[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,s.dtype,s.values)}},e$e={kernelName:Uu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:i,pad:s,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:v,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:C,filterWidth:k,dilationHeight:T,dilationWidth:A,outShape:R}=E.computeDilation2DInfo(r.shape,a.shape,i,s,"NHWC",o),M=I.sizeFromShape(R),_=R.length,$=I.getArrayFromDType(r.dtype,M);for(let U=0;U<p;++U)for(let j=0;j<y;++j){let G=j*w-b.top;for(let K=0;K<v;++K){let X=K*x-b.left;for(let Y=0;Y<g;++Y){let ee=Number.MIN_SAFE_INTEGER;for(let se=0;se<C;++se){let re=G+se*T;if(re>=0&&re<f)for(let oe=0;oe<k;++oe){let le=X+oe*A;if(le>=0&&le<m){let Ce=I.locToIndex([U,re,le,Y],c,I.computeStrides(r.shape)),fe=I.locToIndex([se,oe,Y],d,I.computeStrides(a.shape)),_e=u[Ce]+h[fe];_e>ee&&(ee=_e)}}}$[I.locToIndex([U,j,K,Y],_,I.computeStrides(R))]=ee}}}return{dataId:l.write(I.toTypedArray($,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},t$e={kernelName:vp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:i}=e,{strides:s,pad:o,dilations:l}=n,u=t,c=I.toNestedArray(r.shape,u.data.get(r.dataId).values),h=I.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:x,filterWidth:C,dilationHeight:k,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,s,o,"NHWC",l);I.assert(i.rank===A.length,()=>`Error in ${vp}, dy must have the same rank as output ${A.length}, but got ${i.rank}`);let R=I.toNestedArray(A,u.data.get(i.dataId).values),M=I.makeZerosNestedTypedArray(a.shape,a.dtype);for(let _=0;_<d;++_)for(let $=0;$<g;++$){let U=$*b-v.top;for(let j=0;j<y;++j){let G=j*w-v.left;for(let K=0;K<m;++K){let X=Number.MIN_SAFE_INTEGER,Y=0,ee=0;for(let te=0;te<x;++te){let se=U+te*k;if(se>=0&&se<p)for(let re=0;re<C;++re){let oe=G+re*T;if(oe>=0&&oe<f){let le=c[_][se][oe][K]+h[te][re][K];le>X&&(X=le,Y=te,ee=re)}}}M[Y][ee][K]+=R[_][$][j][K]}}}return{dataId:u.write(I.toTypedArray(M,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},n$e={kernelName:yp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:i}=e,{strides:s,pad:o,dilations:l}=n,u=t,c=I.toNestedArray(r.shape,u.data.get(r.dataId).values),h=I.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:x,filterWidth:C,dilationHeight:k,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,s,o,"NHWC",l);I.assert(i.rank===A.length,()=>`Error in ${yp}, dy must have the same rank as output ${A.length}, but got ${i.rank}`);let R=I.toNestedArray(A,u.data.get(i.dataId).values),M=I.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<d;++_)for(let $=0;$<g;++$){let U=$*b-v.top;for(let j=0;j<y;++j){let G=j*w-v.left;for(let K=0;K<m;++K){let X=Number.MIN_SAFE_INTEGER,Y=U<0?0:U,ee=G<0?0:G;for(let te=0;te<x;++te){let se=U+te*k;if(se>=0&&se<p)for(let re=0;re<C;++re){let oe=G+re*T;if(oe>=0&&oe<f){let le=c[_][se][oe][K]+h[te][re][K];le>X&&(X=le,Y=se,ee=oe)}}}M[_][Y][ee][K]+=R[_][$][j][K]}}}return{dataId:u.write(I.toTypedArray(M,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},a$e={kernelName:l0,backendName:"cpu",kernelFunc:function r$e(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:i,options:s}=r,{contextOptions:o,imageOptions:l}=s||{},u=l?.alpha||1,c=o?.contextType||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=i.getContext(c,o?.contextAttributes||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);let[d,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let b=0;b<d*p;++b){let w=[0,0,0,255*u];for(let C=0;C<f;C++){let k=m[b*f+C];if("float32"===a.dtype){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if("int32"===a.dtype&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);1===f?(w[0]=k*g,w[1]=k*g,w[2]=k*g):w[C]=k*g}let x=4*b;y[x+0]=Math.round(w[0]),y[x+1]=Math.round(w[1]),y[x+2]=Math.round(w[2]),y[x+3]=Math.round(w[3])}i.width=p,i.height=d;let v=new ImageData(y,p,d);return h.putImageData(v,0,0),a}};function yv(e){let o,{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;Ie(a,"sum"),o="bool"===a.dtype?bl({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):Ts({inputs:{x:a},backend:n});let l=o.shape.length,u=I.parseAxisParam(i,o.shape),c=E.getAxesPermutation(u,l),h=u,d=o;null!=c&&(d=la({inputs:{x:o},backend:n,attrs:{perm:c}}),h=E.getInnerMostAxes(h.length,l)),E.assertAxesAreInnerMostDims("sum",h,d.shape.length);let[p,f]=E.computeOutAndReduceShapes(d.shape,h),g=LI(n,p,E.upcastType(d.dtype,"int32")),y=I.sizeFromShape(f),v=n.data.get(g.dataId).values,b=n.data.get(d.dataId).values;for(let w=0;w<v.length;++w){let x=w*y,C=0;for(let k=0;k<y;++k)C+=b[x+k];v[w]=C}if(s){let x=g;g=Qt({inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(g.shape,u)}}),n.disposeIntermediateTensorInfo(x)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),g}var i$e={kernelName:Oc,backendName:"cpu",kernelFunc:yv},o$e={kernelName:u0,backendName:"cpu",kernelFunc:function s$e(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:s,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,i.length);E.checkEinsumDimSizes(s.length,l,i);let{path:u,steps:c}=E.getEinsumComputePath(o,l),h=c.length,d=null,p=s.length,f=[];for(let m=0;m<h;++m){for(let g of c[m]){let b,{permutationIndices:y,expandDims:v}=E.getEinsumPermutation(p,l[g]);E.isIdentityPermutation(y)?b=i[g]:(b=la({inputs:{x:i[g]},backend:n,attrs:{perm:y}}),f.push(b));let w=b.shape.slice();for(let x=0;x<v.length;++x)w.splice(v[x],0,1);I.arraysEqual(b.shape,w)||(b=Qt({inputs:{x:b},backend:n,attrs:{shape:w}}),f.push(b)),null===d?d=b:(d=zI({inputs:{a:b,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=yv({inputs:{x:d},backend:n,attrs:{axis:u[m]-(s.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},u$e={kernelName:bp,backendName:"cpu",kernelFunc:function l$e(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;Ie([r,a],"eluGrad");let i=new Float32Array(I.sizeFromShape(a.shape)),s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<s.length;++l){let u=s[l];i[l]=u>=0?o[l]:o[l]*(u+1)}return n.makeTensorInfo(a.shape,"float32",i)}},c$e=E.ERF_P,d$e=E.ERF_A1,h$e=E.ERF_A2,p$e=E.ERF_A3,f$e=E.ERF_A4,m$e=E.ERF_A5,g$e=Ot(Hu,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+c$e*n);return t*(1-((((m$e*r+f$e)*r+p$e)*r+h$e)*r+d$e)*r*Math.exp(-n*n))}),y$e={kernelName:Hu,backendName:"cpu",kernelFunc:g$e};function UI(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:i}=r,s=a.shape.length,o=a.shape.slice(),l=i;return i<0&&(I.assert(-(s+1)<=i,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),l=s+i+1),o.splice(l,0,1),Qt({inputs:{x:a},backend:n,attrs:{shape:o}})}var v$e={kernelName:xp,backendName:"cpu",kernelFunc:UI},b$e=wn((e,t)=>e/t),yM=Hn(Wu,b$e),vM={kernelName:Wu,backendName:"cpu",kernelFunc:yM};function u7(e,t,n){let r=e.shape,a=r[0],i=r[1],s=n.data.get(e.dataId),o=s.complexTensorInfos.real,l=s.complexTensorInfos.imag,u=[a,i],c=I.sizeFromShape(u),h=I.getTypedArrayFromDType("float32",c),d=I.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){let y=bd({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,i]}}),v=bd({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,i]}}),b=Ra({inputs:{real:y,imag:v},backend:n}),{real:w,imag:x}=w$e(b,t,n),C=E.mergeRealAndImagArrays(w,x);for(let k=0;k<i;k++){let T=E.getComplexWithIndex(C,k);h[g*i+k]=T.real,d[g*i+k]=T.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(b)}let p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=Ra({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function w$e(e,t,n){let r=I.sizeFromShape(e.shape),a=n.data.get(e.dataId),i=n.data.get(a.complexTensorInfos.real.dataId).values,s=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function x$e(e){return!(e&e-1)}(r)){let o=bM(i,s,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",I.createScalarValue(r,"float32")),d=Ts({inputs:{x:h},backend:n}),p=vM.kernelFunc({inputs:{a:u,b:h},backend:n}),f=vM.kernelFunc({inputs:{a:c,b:d},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}{let l=function I$e(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let i=0,s=0;for(let o=0;o<t;o++){let l=E.exponent(a*o,t,n),u=E.getComplexWithIndex(e,o);i+=u.real*l.real-u.imag*l.imag,s+=u.real*l.imag+u.imag*l.real}n&&(i/=t,s/=t),E.assignToTypedArray(r,i,s,a)}return r}(E.mergeRealAndImagArrays(i,s),r,t);return E.splitRealAndImagArrays(l)}}function bM(e,t,n,r,a){if(1===n)return{real:e,imag:t};let i=E.mergeRealAndImagArrays(e,t),s=n/2,o=E.complexWithEvenIndex(i),l=o.real,u=o.imag,c=[l.length],h=a.makeTensorInfo(c,"float32",l),d=a.makeTensorInfo(c,"float32",u),p=Ra({inputs:{real:h,imag:d},backend:a}),f=E.complexWithOddIndex(i),m=f.real,g=f.imag,y=[m.length],v=a.makeTensorInfo(y,"float32",m),b=a.makeTensorInfo(y,"float32",g),w=Ra({inputs:{real:v,imag:b},backend:a}),x=bM(l,u,s,r,a),C=x.real,k=x.imag,T=[C.length],A=a.makeTensorInfo(T,"float32",C),R=a.makeTensorInfo(T,"float32",k),M=Ra({inputs:{real:A,imag:R},backend:a}),_=bM(m,g,s,r,a),$=_.real,U=_.imag,j=[$.length],G=a.makeTensorInfo(j,"float32",$),K=a.makeTensorInfo(j,"float32",U),X=Ra({inputs:{real:G,imag:K},backend:a}),Y=E.exponents(n,r),ee=[Y.real.length],te=a.makeTensorInfo(ee,"float32",Y.real),se=a.makeTensorInfo(ee,"float32",Y.imag),re=Ra({inputs:{real:te,imag:se},backend:a}),oe=zI({inputs:{a:re,b:X},backend:a}),le=Lf({inputs:{a:M,b:oe},backend:a}),Ce=fM({inputs:{a:M,b:oe},backend:a}),fe=yd({inputs:{input:le},backend:a}),_e=yd({inputs:{input:Ce},backend:a}),De=zf({inputs:{input:le},backend:a}),Fe=zf({inputs:{input:Ce},backend:a}),rt=Bf({inputs:[fe,_e],backend:a,attrs:{axis:0}}),dt=Bf({inputs:[De,Fe],backend:a,attrs:{axis:0}}),qt=a.data.get(rt.dataId).values,At=a.data.get(dt.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(X),a.disposeIntermediateTensorInfo(te),a.disposeIntermediateTensorInfo(se),a.disposeIntermediateTensorInfo(re),a.disposeIntermediateTensorInfo(oe),a.disposeIntermediateTensorInfo(le),a.disposeIntermediateTensorInfo(Ce),a.disposeIntermediateTensorInfo(fe),a.disposeIntermediateTensorInfo(De),a.disposeIntermediateTensorInfo(_e),a.disposeIntermediateTensorInfo(Fe),a.disposeIntermediateTensorInfo(rt),a.disposeIntermediateTensorInfo(dt),{real:qt,imag:At}}var _$e={kernelName:c0,backendName:"cpu",kernelFunc:function S$e(e){let{inputs:t,backend:n}=e,{input:r}=t,a=I.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],o=Qt({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),l=u7(o,!1,n),u=Qt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};function wM(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:i}=n,s=i||I.inferDtype(a),o=I.getArrayFromDType(s,I.sizeFromShape(r));return function E$e(e,t,n){e.fill(t)}(o,a),t.makeTensorInfo(r,s,o)}var C$e={kernelName:oy,backendName:"cpu",kernelFunc:wM},k$e={kernelName:Ip,backendName:"cpu",kernelFunc:({inputs:e,backend:n})=>{let{image:r}=e,a=n,i=I.getTypedArrayFromDType(r.dtype,I.sizeFromShape(r.shape)),[s,o,l,u]=r.shape,c=a.data.get(r.dataId).values;for(let h=0;h<s;h++){let d=h*l*o*u;for(let p=0;p<o;p++){let f=p*(l*u);for(let m=0;m<l;m++){let g=m*u;for(let y=0;y<u;y++){let v=Math.round(l-m-1),b=d+f+g+y,w=c[b];v>=0&&v<l&&(w=c[d+f+v*u+y]),i[b]=w}}}}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},T$e={kernelName:Uc,backendName:"cpu",kernelFunc:function N$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=o7({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(s){let g=m;if("NCHW"===c&&1===s.shape.length&&1!==s.shape[0]){let y=Qt({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=Lf({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Lf({inputs:{a:m,b:s},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){let g=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){let y=Qt({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=VI(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=VI(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}},A$e={kernelName:Wc,backendName:"cpu",kernelFunc:function D$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=l7({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(s){let g=m;m=Lf({inputs:{a:m,b:s},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=VI(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}},R$e={kernelName:_p,backendName:"cpu",kernelFunc:function M$e(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=I.sizeFromShape(r.shape),s=a.shape,o=s[s.length-1],[l,u,c,h]=E.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let f=xK(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,i);return n.makeTensorInfo(l,r.dtype,f.values)}},O$e={kernelName:Sp,backendName:"cpu",kernelFunc:function F$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:s,batchDims:o}=r;Ie([a,i],"gatherV2");let l=I.parseAxisParam(s,a.shape)[0],u=n.data.get(i.dataId).values,c=a.shape[l];for(let w=0;w<u.length;++w){let x=u[w];I.assert(x<=c-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${c-1}]`)}let h=o;null==o&&(h=0);let d=I.sizeFromShape(i.shape),p=E.segment_util.collectGatherOpShapeInfo(a,i,l,h),f=Qt({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Qt({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=IK(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},P$e={kernelName:d0,backendName:"cpu",kernelFunc:function $$e(e){let{inputs:t,backend:n}=e,{input:r}=t,a=I.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],o=Qt({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),l=u7(o,!0,n),u=Qt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}},L$e=Ot(Ju,e=>Number.isFinite(e)?1:0,"bool"),z$e={kernelName:Ju,backendName:"cpu",kernelFunc:L$e},B$e=Ot(ec,e=>Math.abs(e)===1/0?1:0,"bool"),V$e={kernelName:ec,backendName:"cpu",kernelFunc:B$e},U$e=Ot(tc,e=>Number.isNaN(e)?1:0,"bool"),W$e={kernelName:tc,backendName:"cpu",kernelFunc:U$e},H$e={kernelName:Np,backendName:"cpu",kernelFunc:function j$e(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,s=kK(r,a,i);return t.makeTensorInfo([s.length],"float32",s)}},G$e=Ot(ac,e=>Math.log1p(e)),q$e={kernelName:ac,backendName:"cpu",kernelFunc:G$e},K$e=wn((e,t)=>e&&t),X$e=Hn(Tp,K$e,null,"bool"),Z$e={kernelName:Tp,backendName:"cpu",kernelFunc:X$e},Y$e=Ot(Dp,e=>e?0:1,"bool"),Q$e={kernelName:Dp,backendName:"cpu",kernelFunc:Y$e},J$e=wn((e,t)=>e||t),ePe=Hn(Ap,J$e,null,"bool"),tPe={kernelName:Ap,backendName:"cpu",kernelFunc:ePe},rPe={kernelName:ic,backendName:"cpu",kernelFunc:function nPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r;Ie(a,"LRN");let u=a.shape[3],c=u-1,h=n.data.get(a.dataId).values,d=I.sizeFromShape(a.shape),p=new Float32Array(d);function f(m){let g=m%u,y=m-g+Math.max(0,g-i),v=m-g+Math.min(g+i,c),b=0;for(;y<=v;y++){let w=h[y];b+=w*w}return b}for(let m=0;m<d;m++){let g=f(m),y=h[m]*Math.pow(s+o*g,-l);p[m]=y}return n.makeTensorInfo(a.shape,a.dtype,p)}},iPe={kernelName:Mp,backendName:"cpu",kernelFunc:function aPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;Ie(s,"LRNGrad");let h=I.sizeFromShape(s.shape),d=s.shape[3],p=n.data.get(s.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let v=0;v<y;v++){let b=v%d,w=v-b+Math.max(0,b-o),x=v-b+Math.min(d,b+o+1),C=0;for(let k=w;k<x;k++)C+=Math.pow(f[k],2);C=u*C+l;for(let k=w;k<x;k++){let T=-2*u*c*f[k]*m[v]/C;v===k&&(T+=Math.pow(C,-c)),T*=p[v],g[k]+=T}}return n.makeTensorInfo(s.shape,a.dtype,g)}};function c7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:s}=r,o=n,l=a.shape,u=l.length,c=I.parseAxisParam(i,l),h=c,d=E.getAxesPermutation(h,u),p=o.data.get(a.dataId).values;if(null!=d){let w=new Array(u);for(let x=0;x<w.length;x++)w[x]=l[d[x]];p=lM(p,l,a.dtype,d,w),h=E.getInnerMostAxes(h.length,u),l=w}Ie(a,"max"),E.assertAxesAreInnerMostDims("max",h,u);let[f,m]=E.computeOutAndReduceShapes(l,h),y=TK(p,I.sizeFromShape(m),f,a.dtype),v=o.write(y,f,a.dtype),b=f;return s&&(b=E.expandShapeToKeepDim(f,c)),{dataId:v,shape:b,dtype:a.dtype}}var sPe={kernelName:sc,backendName:"cpu",kernelFunc:c7},lPe={kernelName:lc,backendName:"cpu",kernelFunc:function oPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;I.assert(E.eitherStridesOrDilationsAreOne(s,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let h,c=E.computePool2DInfo(a.shape,i,s,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&I.arraysEqual(c.inShape,c.outShape))h=Ts({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,p=I.computeStrides(a.shape),f=gM(d,0,a.dtype,p,c,"max");h=n.makeTensorInfo(c.outShape,a.dtype,f.values)}return h}},cPe={kernelName:Rp,backendName:"cpu",kernelFunc:function uPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r;Ie(a,"maxPool3d");let c=E.computePool3DInfo(a.shape,i,s,1,o,l,u),d=s7(n.data.get(a.dataId).values,0,a.dtype,I.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}},hPe={kernelName:uy,backendName:"cpu",kernelFunc:function dPe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r;Ie([a,i],"maxPool3DGrad");let c=E.computePool3DInfo(i.shape,s,o,1,l,u),d=function JFe(e,t){let n=Je(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let v=y*r-d,b=v;for(;b<0;)b+=s;let w=Math.min(t.inDepth,u+v);for(let x=0;x<t.outHeight;++x){let C=x*a-p,k=C;for(;k<0;)k+=o;let T=Math.min(t.inHeight,c+C);for(let A=0;A<t.outWidth;++A){let R=A*i-f,M=R;for(;M<0;)M+=l;let _=Math.min(t.inWidth,h+R),$=Number.NEGATIVE_INFINITY,U=-1;for(let j=b;j<w;j+=s){let G=j-v;for(let K=k;K<T;K+=o){let X=K-C;for(let Y=M;Y<_;Y+=l){let ee=Y-R,te=e.get(m,j,K,Y,g);te>=$&&($=te,U=G*c*h+X*c+ee)}}}n.set(U,m,y,x,A,g)}}}return n}(n.bufferSync(i),c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterDepth,w=c.effectiveFilterHeight,x=c.effectiveFilterWidth,C=b-1-c.padInfo.front,k=x-1-c.padInfo.left,T=w-1-c.padInfo.top,A=Je(i.shape,"float32"),R=n.bufferSync(a);for(let M=0;M<c.batchSize;++M)for(let _=0;_<c.inChannels;++_)for(let $=0;$<c.inDepth;++$)for(let U=0;U<c.inHeight;++U)for(let j=0;j<c.inWidth;++j){let G=$-C,K=U-T,X=j-k,Y=0;for(let ee=0;ee<b;ee+=g){let te=(G+ee)/p;if(!(te<0||te>=c.outDepth||Math.floor(te)!==te))for(let se=0;se<w;se+=y){let re=(K+se)/f;if(!(re<0||re>=c.outHeight||Math.floor(re)!==re))for(let oe=0;oe<x;oe+=v){let le=(X+oe)/m;if(le<0||le>=c.outWidth||Math.floor(le)!==le)continue;let _e=b*w*x-1-d.get(M,te,re,le,_)===ee*w*x+se*x+oe?1:0;0!==_e&&(Y+=R.get(M,te,re,le,_)*_e)}}}A.set(Y,M,$,U,j,_)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}},fPe={kernelName:ly,backendName:"cpu",kernelFunc:function pPe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:s}=t,o=i;Ie([i,s],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=E.computePool2DInfo(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Je(d.outShape,o.dtype,i7(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,v=d.dilationWidth,b=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,C=b-1-d.padInfo.top,k=Je(o.shape,"float32"),T=n.data.get(a.dataId).values,A=Je(a.shape,"float32",T);for(let R=0;R<d.batchSize;++R)for(let M=0;M<d.inChannels;++M)for(let _=0;_<d.inHeight;++_)for(let $=0;$<d.inWidth;++$){let U=_-C,j=$-x,G=0;for(let K=0;K<b;K+=y){let X=(U+K)/m;if(!(X<0||X>=d.outHeight||Math.floor(X)!==X))for(let Y=0;Y<w;Y+=v){let ee=(j+Y)/g;if(ee<0||ee>=d.outWidth||Math.floor(ee)!==ee)continue;let re=b*w-1-f.get(R,X,ee,M)===K*w+Y?1:0;0!==re&&(G+=A.get(R,X,ee,M)*re)}}k.set(G,R,_,$,M)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},gPe={kernelName:cy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:i,pad:s,includeBatchInIndex:o}=t,l=n;Ie(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=E.computePool2DInfo(r.shape,a,i,[1,1],s),[h,d]=function mPe(e,t,n,r,a){let s=gM(e,0,n,I.computeStrides(t),a,"max"),o=i7(e,t,n,a,!0,r);return[s.values,o.values]}(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},vPe={kernelName:uc,backendName:"cpu",kernelFunc:function yPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=I.parseAxisParam(i,a.shape),l=E.computeOutAndReduceShapes(a.shape,o)[1],u=I.sizeFromShape(l),c=[],h=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(h);let d=bl({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(d);let p=yM({inputs:{a:d,b:h},backend:n});c.push(p);let f=yv({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:s}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}},wPe={kernelName:cc,backendName:"cpu",kernelFunc:function bPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;Ie(a,"min");let o=I.parseAxisParam(i,a.shape),l=o,u=E.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=la({inputs:{x:a},backend:n,attrs:{perm:u}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",l,c.shape.length);let[h,d]=E.computeOutAndReduceShapes(c.shape,l),p=I.sizeFromShape(d),f=I.makeZerosTypedArray(I.sizeFromShape(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,b=m[v];for(let w=0;w<p;++w){let x=m[v+w];(Number.isNaN(x)||x<b)&&(b=x)}f[y]=b}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(h,c.dtype,f);if(s){let v=Qt({inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),v}return g}},IPe={kernelName:hc,backendName:"cpu",kernelFunc:function xPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,mode:s}=r;Ie(a,"mirrorPad");let o=i.map((v,b)=>v[0]+a.shape[b]+v[1]),l=i.map(v=>v[0]),u=i.map((v,b)=>v[0]+a.shape[b]),c="reflect"===s?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=I.computeStrides(a.shape),f=I.sizeFromShape(o),m=o.length,g=I.computeStrides(o),y=I.getTypedArrayFromDType(a.dtype,f);for(let v=0;v<f;v++){let b=I.indexToLoc(v,m,g);for(let x=0;x<m;x++)b[x]<l[x]?b[x]=2*l[x]-b[x]-c:b[x]>=u[x]&&(b[x]=2*(u[x]-1)-b[x]+c);b=b.map((x,C)=>x-l[C]);let w=I.locToIndex(b,d,p);y[v]=h[w]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},SPe=wn((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),_Pe=Hn(pc,SPe),CPe={kernelName:pc,backendName:"cpu",kernelFunc:_Pe},EPe=Uo(Zx());function d7(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,s=a.shape.length,o=i;if(-1===o&&(o=s-1),o!==s-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${o}`);let l=I.parseAxisParam([o],a.shape),u=c7({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=E.expandShapeToKeepDim(u.shape,l),h=Qt({inputs:{x:u},backend:n,attrs:{shape:c}}),d=fM({inputs:{a,b:h},backend:n}),p=yK({inputs:{x:d},backend:n}),f=yv({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Qt({inputs:{x:f},backend:n,attrs:{shape:c}}),g=yM({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var kPe={kernelName:$c,backendName:"cpu",kernelFunc:d7},TPe={kernelName:Fp,backendName:"cpu",kernelFunc:function NPe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r;Ie(a,"multinomial");let l=o?a:d7({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],p=I.makeZerosTypedArray(I.sizeFromShape(d),"int32");for(let f=0;f<u;++f){let m=f*c,g=new Float32Array(c-1);g[0]=h[m];for(let b=1;b<g.length;++b)g[b]=g[b-1]+h[m+b];let y=EPe.alea(s.toString()),v=f*i;for(let b=0;b<i;++b){let w=y();p[v+b]=g.length;for(let x=0;x<g.length;x++)if(w<g[x]){p[v+b]=x;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}},DPe=_s.nonMaxSuppressionV3Impl,MPe={kernelName:Pp,backendName:"cpu",kernelFunc:function APe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=r;Ie(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=DPe(u,c,s,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},RPe=_s.nonMaxSuppressionV4Impl,OPe={kernelName:Lp,backendName:"cpu",kernelFunc:function FPe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;Ie(a,"NonMaxSuppressionPadded");let c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=RPe(c,h,s,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},$Pe=_s.nonMaxSuppressionV5Impl,LPe={kernelName:zp,backendName:"cpu",kernelFunc:function PPe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;Ie(a,"NonMaxSuppressionWithScore");let c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=s,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=$Pe(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},BPe={kernelName:mc,backendName:"cpu",kernelFunc:function zPe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r;Ie(a,"oneHot");let u=I.sizeFromShape(a.shape),c=new Float32Array(u*s);c.fill(l);let h=n.data.get(a.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<s&&(c[d*s+h[d]]=o);return n.makeTensorInfo([...a.shape,s],i,c)}};function WI(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let a=yd({inputs:{input:r},backend:n}),i=WI({inputs:{x:a},backend:n}),s=zf({inputs:{input:r},backend:n}),o=WI({inputs:{x:s},backend:n}),l=Ra({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}return wM({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var VPe={kernelName:af,backendName:"cpu",kernelFunc:WI},UPe={kernelName:Bp,backendName:"cpu",kernelFunc:function h7(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){let a=yd({inputs:{input:r},backend:n}),i=h7({inputs:{x:a},backend:n}),s=zf({inputs:{input:r},backend:n}),o=WI({inputs:{x:s},backend:n}),l=Ra({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}return wM({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function p7(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return UI({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{I.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),I.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=Bf({inputs:t.map(c=>{let h=UI({inputs:{input:c},backend:n,attrs:{dim:a}});return o.push(h),h}),backend:n,attrs:{axis:a}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var WPe={kernelName:Vp,backendName:"cpu",kernelFunc:p7},f7={kernelName:gc,backendName:"cpu",kernelFunc:function jPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:s}=r;Ie(a,"pad");let o=i.map((y,v)=>y[0]+a.shape[v]+y[1]),l=i.map(y=>y[0]),u=n.data.get(a.dataId).values,c=I.sizeFromShape(a.shape),h=a.shape.length,d=I.computeStrides(a.shape),p=I.sizeFromShape(o),f=o.length,m=I.computeStrides(o),g=I.getTypedArrayFromDType(a.dtype,p);0!==s&&g.fill(s);for(let y=0;y<c;y++){let v=I.indexToLoc(y,h,d).map((w,x)=>w+l[x]);g[I.locToIndex(v,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},HPe=wn((e,t)=>Math.pow(e,t)),GPe=Hn(yc,HPe),qPe={kernelName:yc,backendName:"cpu",kernelFunc:GPe},XPe={kernelName:p0,backendName:"cpu",kernelFunc:function KPe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:s}=t,l=a.map(y=>n.data.get(y.dataId).values),u=a.map(y=>y.shape),c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,[d,p,f]=$K(l,u,c,i.shape,i.dtype,h,s.shape),m=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,i.dtype,p);return m.concat([g])}},YPe={kernelName:f0,backendName:"cpu",kernelFunc:function ZPe(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,c]=LK(s,r.shape,r.dtype,o,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},JPe={kernelName:m0,backendName:"cpu",kernelFunc:function QPe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,d=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=VK(u,a.shape,c,i.shape,i.dtype,h,s.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,m)}},tLe={kernelName:dy,backendName:"cpu",kernelFunc:function eLe(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:i,step:s}=n,o=uM(r,a,s,i);return t.makeTensorInfo([o.length],i,o)}},nLe=Ot(wc,e=>1/e),rLe={kernelName:wc,backendName:"cpu",kernelFunc:nLe},iLe={kernelName:Sc,backendName:"cpu",kernelFunc:function aLe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r;Ie(a,"resizeBilinear");let l=I.computeStrides(a.shape),[u,c]=o,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(I.sizeFromShape([h,u,c,f])),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],v=[i&&u>1?u-1:u,i&&c>1?c-1:c],b=0,w=y[0]/v[0],x=y[1]/v[1];for(let C=0;C<h;C++)for(let k=0;k<u;k++){let T;T=s?w*(k+.5)-.5:w*k;let A=Math.max(0,Math.floor(T)),R=T-A,M=Math.min(d-1,Math.ceil(T)),_=C*l[0]+A*l[1],$=C*l[0]+M*l[1];for(let U=0;U<c;U++){let j;j=s?x*(U+.5)-.5:x*U;let G=Math.max(0,Math.floor(j)),K=j-G,X=Math.min(p-1,Math.ceil(j)),Y=_+G*l[2],ee=$+G*l[2],te=_+X*l[2],se=$+X*l[2];for(let re=0;re<f;re++){let oe=m[Y+re],le=m[ee+re],_e=oe+(m[te+re]-oe)*K;g[b++]=_e+(le+(m[se+re]-le)*K-_e)*R}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},oLe={kernelName:jp,backendName:"cpu",kernelFunc:function sLe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r;Ie([i,a],"resizeBilinearGrad");let o=I.computeStrides(a.shape),[l,u,c,h]=a.shape,[,d,p]=i.shape,f=new Float32Array(l*u*c*h),m=[s&&d>1?u-1:u,s&&p>1?c-1:c],g=[s&&d>1?d-1:d,s&&p>1?p-1:p],y=m[0]/g[0],v=m[1]/g[1],b=n.data.get(i.dataId).values,w=0;for(let x=0;x<l;x++){let C=x*o[0];for(let k=0;k<d;k++){let T=k*y,A=Math.floor(T),R=Math.min(Math.ceil(T),u-1),M=C+A*o[1],_=C+R*o[1],$=T-A,U=1-$;for(let j=0;j<p;j++){let G=j*v,K=Math.floor(G),X=Math.min(Math.ceil(G),c-1),Y=G-K,ee=1-Y,te=M+K*o[2],se=M+X*o[2],re=_+K*o[2],oe=_+X*o[2],le=U*ee,Ce=U*Y,fe=$*ee,_e=$*Y;for(let De=0;De<h;De++){let Fe=b[w++];f[te+De]+=Fe*le,f[se+De]+=Fe*Ce,f[re+De]+=Fe*fe,f[oe+De]+=Fe*_e}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},uLe={kernelName:Ic,backendName:"cpu",kernelFunc:function lLe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r;Ie(a,"resizeNearestNeighbor");let l=I.computeStrides(a.shape),[u,c]=o,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(h*u*c*f),y=[i&&u>1?d-1:d,i&&c>1?p-1:p],v=[i&&u>1?u-1:u,i&&c>1?c-1:c],b=y[0]/v[0],w=y[1]/v[1],x=0;for(let C=0;C<h;C++){let k=C*l[0];for(let T=0;T<u;T++){let A=s?b*(T+.5):b*T,R=Math.min(d-1,i?Math.round(A):Math.floor(A));s&&(R=Math.max(0,R));let M=k+R*l[1];for(let _=0;_<c;_++){let $=s?w*(_+.5):w*_,U=Math.min(p-1,i?Math.round($):Math.floor($));s&&(U=Math.max(0,U));let j=M+U*l[2];for(let G=0;G<f;G++)g[x++]=m[j+G]}}}return n.makeTensorInfo([h,u,c,f],a.dtype,g)}},dLe={kernelName:Wp,backendName:"cpu",kernelFunc:function cLe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r;Ie([i,a],"resizeNearestNeighborGrad");let o=I.computeStrides(a.shape),l=I.computeStrides(i.shape),[u,c,h,d]=a.shape,[,p,f]=i.shape,m=new Float32Array(u*c*h*d),g=n.data.get(i.dataId).values,y=[s&&p>1?c-1:c,s&&f>1?h-1:h],v=[s&&p>1?p-1:p,s&&f>1?f-1:f],b=y[0]/v[0],w=y[1]/v[1],x=1/b,C=1/w,k=2*Math.ceil(x)+2,T=2*Math.ceil(C)+2;for(let A=0;A<u;A++){let R=A*o[0];for(let M=0;M<c;M++){let _=R+M*o[1],$=Math.floor(M*x),U=Math.floor($-k/2);for(let j=0;j<h;j++){let G=_+j*o[2],K=Math.floor(j*C),X=Math.floor(K-T/2);for(let Y=0;Y<d;Y++){let ee=0;for(let te=0;te<k;te++){let se=te+U;if(se<0||se>=p)continue;let re=R+se*l[1],oe=se*b;if(M===Math.min(c-1,s?Math.round(oe):Math.floor(oe)))for(let Ce=0;Ce<T;Ce++){let fe=Ce+X;if(fe<0||fe>=f)continue;let _e=re+fe*l[2],De=fe*w;j===Math.min(h-1,s?Math.round(De):Math.floor(De))&&(ee+=g[_e+Y])}}m[G+Y]=ee}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}},pLe={kernelName:Cc,backendName:"cpu",kernelFunc:function hLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r;Ie(a,"reverse");let s=a.shape.length,o=I.parseAxisParam(i,a.shape);if(0===s)return Ts({inputs:{x:a},backend:n});let l=new En(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){let h=l.indexToLoc(c),d=h.slice();o.forEach(p=>d[p]=a.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},fLe={kernelName:sf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:i,center:s}=t,o=n,l=I.getTypedArrayFromDType(r.dtype,I.sizeFromShape(r.shape)),[u,c,h,d]=r.shape,[p,f]=E.getImageCenter(s,c,h),g=Math.sin(a),y=Math.cos(a),v=o.data.get(r.dataId).values;for(let b=0;b<u;b++){let w=b*h*c*d;for(let x=0;x<c;x++){let C=x*(h*d);for(let k=0;k<h;k++){let T=k*d;for(let A=0;A<d;A++){let R=[u,x,k,A],M=R[2],_=R[1],$=(M-p)*y-(_-f)*g,U=(M-p)*g+(_-f)*y;$=Math.round($+p),U=Math.round(U+f);let j=i;"number"!=typeof i&&(j=3===A?255:i[A]),$>=0&&$<h&&U>=0&&U<c&&(j=v[w+U*(h*d)+$*d+A]),l[w+C+T+A]=j}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},mLe=Ot(Ec,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),gLe={kernelName:Ec,backendName:"cpu",kernelFunc:mLe},vLe={kernelName:Hp,backendName:"cpu",kernelFunc:function yLe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:s}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=E.calculateShapes(i,a,s),m=vd(n.bufferSync(a),n.bufferSync(i),s,h,u,l,o,c,0,!0);return n.makeTensorInfo(s,m.dtype,m.values)}};function bLe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function wLe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var SLe={kernelName:qp,backendName:"cpu",kernelFunc:function ILe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r,u=function xLe(e,t,n,r,a,i){let s=I.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),u=o*a;for(let c=0;c<a;++c)s[u+c]="left"===i?bLe(l,t[c+u]):wLe(l,t[c+u])}return s}(n.data.get(a.dataId).values,n.data.get(i.dataId).values,a.shape[0],a.shape[1],i.shape[1],s);return n.makeTensorInfo(i.shape,"int32",u)}},CLe={kernelName:Kp,backendName:"cpu",kernelFunc:function _Le(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t;Ie([r,a,i],"select");let s=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,c=Ga(a.dtype,i.dtype),h=I.makeZerosTypedArray(I.sizeFromShape(a.shape),c),d=0,p=0===s||s>1||1===a.shape.length?1:I.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)h[d++]=1===o[f]?l[f]:u[f];return n.makeTensorInfo(a.shape,c,h)}},ELe=E.SELU_SCALEALPHA,kLe=E.SELU_SCALE,NLe=Ot(Nc,e=>e>=0?kLe*e:ELe*(Math.exp(e)-1)),TLe={kernelName:Nc,backendName:"cpu",kernelFunc:NLe},DLe=Ot(Ac,e=>e<0?-1:e>0?1:0),ALe={kernelName:Ac,backendName:"cpu",kernelFunc:DLe},MLe=Ot(Tc,e=>Math.sin(e)),RLe={kernelName:Tc,backendName:"cpu",kernelFunc:MLe},FLe=Ot(Dc,e=>Math.sinh(e)),OLe={kernelName:Dc,backendName:"cpu",kernelFunc:FLe},m7=Math.log(1.1920928955078125e-7)+2,PLe=Ot(Rc,e=>{let a,t=e>-m7,n=e<m7,r=Math.exp(e);return a=n?r:t?e:Math.log(1+r),a}),LLe={kernelName:Rc,backendName:"cpu",kernelFunc:PLe},BLe={kernelName:Zp,backendName:"cpu",kernelFunc:function zLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r;Ie([a],"spaceToBatchND");let o=I.sizeFromShape(i),l=[[0,0]];l.push(...s);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=f7.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=E.getReshaped(u.shape,i,o,!1),h=E.getPermuted(c.length,i.length,!1),d=E.getReshapedPermuted(u.shape,i,o,!1),p=Qt({inputs:{x:u},backend:n,attrs:{shape:c}}),f=la({inputs:{x:p},backend:n,attrs:{perm:h}}),m=Qt({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}},ULe={kernelName:hy,backendName:"cpu",kernelFunc:function VLe(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:s}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values[0],[h,d,p,f,m]=jK(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},jLe={kernelName:Qp,backendName:"cpu",kernelFunc:function WLe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=HK(o,r.shape,r.dtype,s,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},GLe={kernelName:py,backendName:"cpu",kernelFunc:function HLe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,c]=cM(s,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},KLe={kernelName:fy,backendName:"cpu",kernelFunc:function qLe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,c]=cM(s,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},ZLe={kernelName:Jp,backendName:"cpu",kernelFunc:function XLe(e){let m,{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=E.calculateShapes(i,a,o),p=!1,f=n.bufferSync(a);switch(i.dtype){case"bool":m=vd(f,n.bufferSync(i),o,d,c,u,l,h,!!n.data.get(s.dataId).values[0],p);break;case"float32":case"int32":m=vd(f,n.bufferSync(i),o,d,c,u,l,h,n.data.get(s.dataId).values[0],p);break;case"string":m=vd(f,n.bufferSync(i),o,d,c,u,l,h,I.decodeString(n.data.get(s.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},QLe={kernelName:Yp,backendName:"cpu",kernelFunc:function YLe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=r,o=I.parseAxisParam(s,a.shape)[0],l=E.prepareSplitSize(a,i,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map(h=>{let d=[...c];d[o]=h;let p=bd({inputs:{x:a},backend:n,attrs:{begin:u,size:d}});return u[o]+=h,p})}},JLe={kernelName:my,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;Ie(n,"square");let a=r.data.get(n.dataId).values,i=new Float32Array(a.length);for(let s=0;s<a.length;++s){let o=a[s];i[s]=o*o}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},e3e=Ot(Ko,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),t3e={kernelName:Ko,backendName:"cpu",kernelFunc:e3e},r3e={kernelName:ef,backendName:"cpu",kernelFunc:function n3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,end:s,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;Ie(a,"stridedSlice");let x,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:b,strides:w}=Vn.sliceInfo(a.shape,i,s,o,l,u,c,h,d);if(m)x=Qt({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){I.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let C=Vn.computeOutShape(v,b,w),k=bd({inputs:{x:a},backend:n,attrs:{begin:v,size:C}});x=Qt({inputs:{x:k},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(k)}else{let k=KK(p,n.bufferSync(a),w,v);x=n.makeTensorInfo(f,k.dtype,k.values)}return x}},i3e={kernelName:yy,backendName:"cpu",kernelFunc:function a3e(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:s,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=dM(d,p,a,i,s,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},o3e={kernelName:vy,backendName:"cpu",kernelFunc:function s3e(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:s}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values[0],[u,c,h]=hM(o,l,a),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},u3e={kernelName:by,backendName:"cpu",kernelFunc:function l3e(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let o=pM(n.data.get(i.dataId).values,a);return n.makeTensorInfo(i.shape,"int32",o)}},c3e=Ot(zc,e=>Math.tan(e)),d3e={kernelName:zc,backendName:"cpu",kernelFunc:c3e},h3e=Ot(Bc,e=>Math.tanh(e)),m3e={kernelName:Gp,backendName:"cpu",kernelFunc:function f3e(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:i}=t,{sliceRank:s,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=E.calculateShapes(i,a,r.shape),d=n.bufferSync(a),p=n.bufferSync(i),f=n.bufferSync(r),m=vd(d,p,r.shape,c,l,o,s,u,f,!1);return n.makeTensorInfo(r.shape,m.dtype,m.values)}},y3e={kernelName:qo,backendName:"cpu",kernelFunc:function g3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;Ie(a,"tile");let s=ZK(n.bufferSync(a),i);return n.makeTensorInfo(s.shape,s.dtype,s.values)}},b3e={kernelName:tf,backendName:"cpu",kernelFunc:function v3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:s}=r;Ie(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=QK(o,a.shape,a.dtype,i,s);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},x3e={kernelName:nf,backendName:"cpu",kernelFunc:function w3e(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=a.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=I.computeStrides(a.shape),v=y[0],b=y[1],w=y[2],x=I.computeStrides(g),C=x[0],k=x[1],T=x[2],A=I.getTypedArrayFromDType(a.dtype,I.sizeFromShape(g));A.fill(l);let R=r.data.get(a.dataId).values,M=r.data.get(i.dataId).values;for(let _=0;_<c;++_){let $=1===i.shape[0]?M:M.subarray(8*_,8*_+8);for(let U=0;U<f;++U)for(let j=0;j<m;++j)for(let G=0;G<p;++G){let K,X=$[6]*j+$[7]*U+1;if(0===X)continue;let ee=($[3]*j+$[4]*U+$[5])/X,te=g7(($[0]*j+$[1]*U+$[2])/X,d,o),se=g7(ee,h,o);switch(s){case"nearest":K=E3e(R,h,d,v,b,w,_,se,te,G,l);break;case"bilinear":K=k3e(R,h,d,v,b,w,_,se,te,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`)}A[_*C+U*k+j*T+G]=K}return r.makeTensorInfo(g,a.dtype,A)}return{dataId:r.write(A,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function g7(e,t,n){switch(n){case"reflect":return function I3e(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return I.clamp(0,n,t-1)}(e,t);case"wrap":return function S3e(e,t){let n=e;return n<0?t<=1?n=0:n+=t*(Math.trunc(-n/(t-1))+1):n>t-1&&(t<=1?n=0:n-=t*Math.trunc(n/(t-1))),I.clamp(0,n,t-1)}(e,t);case"nearest":return function C3e(e,t){return I.clamp(0,e,t-1)}(e,t);default:return function _3e(e,t){return e}(e)}}function vv(e,t,n,r,a,i,s,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[s*r+o*a+l*i+u]:c}function E3e(e,t,n,r,a,i,s,o,l,u,c){return vv(e,t,n,r,a,i,s,Math.round(o),Math.round(l),u,c)}function k3e(e,t,n,r,a,i,s,o,l,u,c){let h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*vv(e,t,n,r,a,i,s,h,d,u,c)+(l-d)*vv(e,t,n,r,a,i,s,h,f,u,c))+(o-h)*((f-l)*vv(e,t,n,r,a,i,s,p,d,u,c)+(l-d)*vv(e,t,n,r,a,i,s,p,f,u,c))}var T3e={kernelName:wy,backendName:"cpu",kernelFunc:function N3e(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;Ie(i,"unique");let s=r.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=mM(s,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},A3e={kernelName:rf,backendName:"cpu",kernelFunc:function D3e(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a.shape.length,o=a.shape[i],l=new Array(s-1),u=0;for(let p=0;p<s;p++)p!==i&&(l[u++]=a.shape[p]);let c=new Array(s).fill(0),h=a.shape.slice();h[i]=1;let d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;let f=bd({inputs:{x:a},backend:n,attrs:{begin:c,size:h}});d[p]=Qt({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}},R3e={kernelName:xy,backendName:"cpu",kernelFunc:function M3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:s}=r;Ie(a,"unsortedSegmentSum");let u=[],c=[],h=a.shape.length-i.shape.length,d=i;for(let f=0;f<h;++f){let m=UI({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=m,c.push(m)}for(let f=0;f<s;++f){let m=I.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=mK({inputs:{a:g,b:d},backend:n}),v=bl({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),b=zI({inputs:{a:v,b:a},backend:n}),w=yv({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(y),c.push(v),c.push(b),c.push(w)}let p=p7({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}},F3e=[kFe,sRe,TFe,AFe,hRe,RFe,OFe,PFe,zFe,VFe,WFe,HFe,qFe,ZFe,QFe,tOe,rOe,iOe,oOe,CFe,uOe,dOe,pOe,fRe,mOe,cRe,gRe,yOe,oRe,bOe,xOe,IOe,_Oe,EOe,NOe,DOe,MOe,FOe,$Oe,LOe,BOe,UOe,jOe,GOe,qOe,XOe,YOe,JOe,e$e,t$e,n$e,a$e,o$e,vFe,u$e,yRe,y$e,vRe,v$e,wRe,_$e,C$e,k$e,IRe,_Re,T$e,A$e,R$e,O$e,ERe,NRe,lRe,P$e,wOe,z$e,V$e,W$e,bFe,DRe,MRe,H$e,FRe,q$e,Z$e,Q$e,tPe,rPe,iPe,sPe,$Re,lPe,cPe,hPe,fPe,gPe,vPe,wPe,LRe,IPe,CPe,TPe,BRe,URe,MPe,OPe,LPe,jRe,BPe,UPe,WPe,f7,qPe,xFe,qRe,XPe,YPe,JPe,tLe,uRe,vM,rLe,IFe,SFe,_Fe,iLe,oLe,uLe,dLe,pLe,fLe,gLe,nFe,vLe,SLe,CLe,TLe,aFe,ALe,RLe,OLe,iFe,kPe,LLe,BLe,ULe,jLe,GLe,KLe,ZLe,QLe,lFe,JLe,cFe,hFe,t3e,r3e,i3e,o3e,u3e,gFe,i$e,d3e,{kernelName:Bc,backendName:"cpu",kernelFunc:h3e},m3e,y3e,b3e,x3e,HRe,T3e,A3e,R3e,VPe];for(let e of F3e)_y(e);var y7={};je(y7,{assertNotComplex:()=>Uf,bindCanvasToFramebuffer:()=>H3e,bindColorTextureToFramebuffer:()=>qI,bindTextureToProgramUniformSampler:()=>R7,bindTextureUnit:()=>D7,bindVertexBufferToProgramAttribute:()=>SM,callAndCheck:()=>ge,canBeRepresented:()=>b7,createFragmentShader:()=>I7,createFramebuffer:()=>T7,createProgram:()=>S7,createStaticIndexBuffer:()=>E7,createStaticVertexBuffer:()=>C7,createTexture:()=>k7,createVertexShader:()=>x7,getBatchDim:()=>xd,getExtensionOrThrow:()=>xv,getFramebufferErrorMessage:()=>F7,getMaxTexturesInShader:()=>L7,getNumChannels:()=>W3e,getProgramUniformLocation:()=>M7,getProgramUniformLocationOrThrow:()=>A7,getRowsCols:()=>Id,getShapeAs3D:()=>Sv,getTextureShapeFromLogicalShape:()=>$7,getWebGLDisjointQueryTimerVersion:()=>z7,getWebGLErrorMessage:()=>w7,getWebGLMaxTextureSize:()=>P7,hasExtension:()=>Ja,isCapableOfRenderingToFloatTexture:()=>B7,isDownloadFloatTextureEnabled:()=>V7,isReshapeFree:()=>_v,isWebGLFenceEnabled:()=>U7,isWebGLVersionEnabled:()=>CM,linkProgram:()=>_7,logShaderSourceAndInfoLog:()=>IM,resetMaxTextureSize:()=>G3e,resetMaxTexturesInShader:()=>q3e,unbindColorTextureFromFramebuffer:()=>_M,unbindTextureUnit:()=>j3e,validateFramebuffer:()=>Iv,validateProgram:()=>GI,validateTextureSize:()=>N7});var bv,Qa,fr,wd={},jI={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function v7(e,t){wd[e]=t}function Yi(e,t){if(!(e in wd)||null!=t){let r=function $3e(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??function O3e(e){if(!H().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===e)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete wd[e]},!1),H().getBool("SOFTWARE_WEBGL_ENABLED")&&(jI.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",jI)||n.getContext("experimental-webgl",jI):n.getContext("webgl2",jI)}(e,t);if(null===r)return console.log("Could not get context for WebGL version",e),null;wd[e]=r}let n=wd[e];return null==n||n.isContextLost()?(delete wd[e],Yi(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),wd[e])}function wv(e,t){return[t,e]}function HI(e){let t=I.sizeFromShape(e),n=Math.ceil(t/4);return I.sizeToSquarishShape(n)}function Vf(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xM(e,t){let r,a,i,s,o,l,u,c,h,d,n=e;return 2===H().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,i=n.RGBA16F,s=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,i=e.RGBA,s=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:s,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function ge(e,t){let n=t();return H().getBool("DEBUG")&&function z3e(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+w7(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(bv||(bv={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(Qa||(Qa={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(fr||(fr={}));var B3e=5.96e-8,V3e=65504;function b7(e){return!!(H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||B3e<Math.abs(e)&&Math.abs(e)<V3e)}function w7(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function xv(e,t){return mo(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function x7(e,t){let n=mo(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ge(e,()=>e.shaderSource(n,t)),ge(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function I7(e,t){let n=mo(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ge(e,()=>e.shaderSource(n,t)),ge(e,()=>e.compileShader(n)),H().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw IM(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var XI,ZI,U3e=/ERROR: [0-9]+:([0-9]+):/g;function IM(e,t){let n=U3e.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),i=a.length.toString().length+2,s=a.map((h,d)=>I.rightPad((d+1).toString(),i)+h),o=0;for(let h=0;h<s.length;h++)o=Math.max(s[h].length,o);let l=s.slice(0,r-1),u=s.slice(r-1,r),c=s.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${I.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function S7(e){return mo(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function _7(e,t){if(ge(e,()=>e.linkProgram(t)),!H().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function GI(e,t){if(ge(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function C7(e,t){let n=mo(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ge(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function E7(e,t){let n=mo(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ge(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function W3e(){return 2===H().getNumber("WEBGL_VERSION")?1:4}function k7(e){return mo(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function N7(e,t){let n=H().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function T7(e){return mo(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function SM(e,t,n,r,a,i,s){let o=e.getAttribLocation(t,n);return-1!==o&&(ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ge(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,i,s)),ge(e,()=>e.enableVertexAttribArray(o)),!0)}function D7(e,t,n){O7(e,n),ge(e,()=>e.activeTexture(e.TEXTURE0+n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function j3e(e,t){O7(e,t),ge(e,()=>e.activeTexture(e.TEXTURE0+t)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function A7(e,t,n){return mo(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function M7(e,t,n){return e.getUniformLocation(t,n)}function R7(e,t,n,r){ge(e,()=>D7(e,t,r)),ge(e,()=>e.uniform1i(n,r))}function H3e(e){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ge(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),ge(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function qI(e,t,n){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ge(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function _M(e,t){ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ge(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Iv(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+F7(e,t))}function F7(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function mo(e,t,n){let r=ge(e,()=>t());if(null==r)throw new Error(n);return r}function O7(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function xd(e,t=2){return I.sizeFromShape(e.slice(0,e.length-t))}function Id(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Sv(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[xd(e),...Id(e)]),t}function $7(e,t=!1){let n=H().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=H().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&H().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map((o,l)=>l>=e.length-2?I.nearestLargerEven(e[l]):e[l])).length&&(e=[2,e[0]])),2!==e.length&&(e=I.squeezeShape(e).newShape);let a=I.sizeFromShape(e),i=null;e.length<=1&&a<=n?i=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);let s=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||s)if(t){let o=xd(e),l=2,u=2;e.length&&([l,u]=Id(e)),a=o*(l/2)*(u/2),i=I.sizeToSquarishShape(a).map(c=>2*c)}else i=I.sizeToSquarishShape(a);return i}function KI(e){return e%2==0}function _v(e,t){if(e=e.slice(-2),t=t.slice(-2),I.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||KI(n)&&KI(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&KI(e[0])&&KI(t[0])}function P7(e){if(null==XI){let t=Yi(e);XI=t.getParameter(t.MAX_TEXTURE_SIZE)}return XI}function G3e(){XI=null}function q3e(){ZI=null}function L7(e){if(null==ZI){let t=Yi(e);ZI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ZI)}function z7(e){if(0===e)return 0;let t,n=Yi(e);return t=Ja(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Ja(n,"EXT_disjoint_timer_query")?1:0,t}function Ja(e,t){return null!=e.getExtension(t)}function CM(e){try{if(null!=Yi(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function B7(e){if(0===e)return!1;let t=Yi(e);if(1===e){if(!Ja(t,"OES_texture_float"))return!1}else if(!Ja(t,"EXT_color_buffer_float"))return!1;return EM(t)}function V7(e){if(0===e)return!1;let t=Yi(e);if(1!==e){if(Ja(t,"EXT_color_buffer_float"))return EM(t);let n="EXT_color_buffer_half_float";if(Ja(t,n)){let r=t.getExtension(n);return function K3e(e,t){let n=xM(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),i}(t,r)}return!1}return!(!Ja(t,"OES_texture_float")||!Ja(t,"WEBGL_color_buffer_float"))&&EM(t)}function EM(e){let t=xM(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function U7(e){return 2===e&&null!=Yi(e).fenceSync}function Uf(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{null!=n&&I.assert("complex64"!==n.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Se=H();function Vr(){let e,t,n,r,a,i,s,o,l,u;return 2===H().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",i="outputColor",s="out vec4 outputColor;",o=H().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",i="gl_FragColor",s="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:i,defineOutput:s,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Sd(e,t,n="index"){let r=I.computeStrides(t);return r.map((a,i)=>`int ${e[i]} = ${n} / ${a}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a}`:`index -= ${e[i]} * ${a}`};`).join("")}function YI(e,t,n="index"){let r=I.computeStrides(t);return r.map((a,i)=>`int ${e[i]} = ${n} / outShapeStrides[${i}]; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`};`).join("")}function kM(e){let t=I.computeStrides(e).map(n=>n.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Se.registerFlag("HAS_WEBGL",()=>Se.getNumber("WEBGL_VERSION")>0),Se.registerFlag("WEBGL_VERSION",()=>CM(2)?2:CM(1)?1:0),Se.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Se.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Se.get("WEBGL_VERSION")),Se.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Se.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Se.registerFlag("WEBGL_PACK",()=>Se.getBool("HAS_WEBGL")),Se.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_CLIP",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_REDUCE",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_LAZILY_UNPACK",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_CONV_IM2COL",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Se.getBool("WEBGL_PACK")),Se.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>P7(Se.getNumber("WEBGL_VERSION"))),Se.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>L7(Se.getNumber("WEBGL_VERSION"))),Se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Se.getNumber("WEBGL_VERSION");return 0===e?0:z7(e)}),Se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Se.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ay.isMobile()),Se.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>B7(Se.getNumber("WEBGL_VERSION"))),Se.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Se.getBool("WEBGL_FORCE_F16_TEXTURES")&&Se.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Se.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>V7(Se.getNumber("WEBGL_VERSION"))),Se.registerFlag("WEBGL_FENCE_API_ENABLED",()=>U7(Se.getNumber("WEBGL_VERSION"))),Se.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Se.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Se.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),Se.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Ay.isMobile()?1:-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),Se.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Se.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Se.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Se.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Se.registerFlag("WEBGL_EXP_CONV",()=>!1),Se.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Se.getBool("IS_TEST")),Se.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Se.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Se.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Se.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var W7="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:j7}=E;function Y3e(e,t,n){let r=[];if(e.forEach(d=>{let p=I.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){let{uniformShape:f}=TM(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`)}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let u,c,a=r.join("\n"),i=e.map(d=>function Q3e(e,t,n=!1,r){let a="";return a+=n?H7(e,r):Wf(e,r),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(a+=n?function Aze(e,t){let c,n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,o=j7(e.shapeInfo.logicalShape,t.logicalShape),l=Ut(s),u=s-i,h=["x","y","z","w","u","v"];c=0===i?"":s<2&&o.length>=1?"coords = 0;":o.map(g=>`coords.${h[g+u]} = 0;`).join("\n");let d="";d=s<2&&i>0?"coords":e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+u]}`).join(", ");let p="return outputValue;",f=1===I.sizeFromShape(e.shapeInfo.logicalShape),m=1===I.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){let g=i-2,y=i-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?p="return vec4(outputValue.x);":o.indexOf(g)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function Mze(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&I.arraysEqual(e.shapeInfo.texShape,t.texShape))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let d,u=Ut(l),c=j7(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map(m=>`coords.${p[m+h]} = 0;`).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(d,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),s=t.texShape,o=Vr(),l=function tze(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o),h=function aze(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${ize}\n    ${sze}\n    ${oze}\n  `}(o);return t.isPacked?(u=function J3e(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function uze(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function yze(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(I.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function dze(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),i=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function pze(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),i=a*Math.ceil(e[e.length-2]/2),s=i,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)s*=e[e.length-u-1],o=`\n      int b${u} = index / ${s};\n      index -= b${u} * ${s};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,s,n.enableShapeUniforms),c=function rze(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function eze(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function cze(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function vze(e,t,n){return I.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function hze(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${YI(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=Sd(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function fze(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${YI(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=Sd(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function mze(e,t){let n=Sd(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function gze(e,t){let n=Sd(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,s,n.enableShapeUniforms),c=function nze(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=lze),[h,l,c,a,u,i,n.userCode].join("\n")}function Wf(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function wze(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,i]=e.shapeInfo.texShape;if(1===a&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let s=_d(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function Ize(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${jf(e)}\n      }\n    `;let a=e.shapeInfo.texShape,i=a[0],s=a[1];if(1===s&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=_d(n);return 1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${s}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function _ze(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&I.arraysEqual(n,i))return t?`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let{newShape:s,keptDims:o}=I.squeezeShape(n);if(s.length<n.length){let p=["row","col"];return`\n      ${Wf(Hf(e,s),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${Gf(p,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${jf(e)}\n      }\n    `;let u=i[0],c=i[1],h=_d(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function Eze(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],s=n[2],{newShape:o,keptDims:l}=I.squeezeShape(n);if(o.length<n.length){let g=["row","col","depth"];return`\n        ${Wf(Hf(e,o),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Gf(g,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${s}, 1)));\n        ${jf(e)}\n      }\n    `;let c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=_d(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${s} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function Nze(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],s=n[2]*i,o=n[1]*s,{newShape:l,keptDims:u}=I.squeezeShape(n);if(l.length<n.length){let b=["row","col","depth","depth2"];return`\n      ${Wf(Hf(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Gf(b,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${s}, ${i}, 1)));\n        ${jf(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===i&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=_d(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${s} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function Tze(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],i=t[3]*a,s=t[2]*i,o=t[1]*s,{newShape:l,keptDims:u}=I.squeezeShape(t);if(l.length<t.length){let g=["row","col","depth","depth2","depth3"];return`\n      ${Wf(Hf(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Gf(g,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${s}, ${i}, ${a})) +\n          depth3;\n        ${jf(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===a&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${s} + depth * ${i} +\n          depth2 * ${a} + depth3 + ${_d(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function Dze(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:i}=I.squeezeShape(t);if(a.length<t.length){let y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Wf(Hf(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Gf(y,i)});\n      }\n    `}let s=t[5],o=t[4]*s,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${jf(e)}\n      }\n    `;let h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===s&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${s} + depth4 + ${_d(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function H7(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function bze(e){let t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Vr().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function xze(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,i=Vr();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;let s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function Sze(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,s=i[0],o=i[1],l=Vr();if(null!=i&&I.arraysEqual(n,i))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function Cze(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,s=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){let p=[1,2],m=["b","row","col"];return`\n        ${H7(Hf(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${Gf(m,p)});\n        }\n      `}let o=Vr();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=s[0],u=s[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function kze(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=Vr();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let i=e.shapeInfo.logicalShape,s=i.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[s-1]/2),d=h*Math.ceil(i[s-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<s-1;m++)p=`int b${m}, `+p,d*=i[s-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var ize="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sze="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",oze="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",lze="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function _d(e){return`offset${e}`}function jf(e){let t=e.name,n=I.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Ut(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function TM(e,t,n){let{newShape:r,keptDims:a}=I.squeezeShape(t),i=t.length,s=e&&3===i&&1===t[0],o=s?t.slice(1):r,l=!e&&i>1&&!I.arraysEqual(t,n)&&r.length<i||s;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Hf(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Gf(e,t){return t.map(n=>e[n]).join(", ")}function q7(e,t,n){let i,s,o,r=[],a=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===H().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let h of t.variableNames){let d={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(d.shape=e.getUniformLocation(n,`${h}Shape`,c),d.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),r.push(d)}if(t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),s=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let h of t.customUniforms)a.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:s}}function K7(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,i=t[r],s=i.shape;if(!I.arraysEqual(a,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${s} must match`);if(n.isUniform&&i.isUniform)return;let o=n.texShape,l=i.isUniform?null:i.texData.texShape;if(!I.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Cr(e){return H().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var $ze=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=bv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Vr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?YI(["r","c","d"],e):Sd(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},Pze=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=bv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Vr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?YI(["r","c","d"],e):Sd(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},Lze=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Qa.DOWNLOAD;let t=Vr();this.outputShape=e,this.userCode=`\n      ${W7}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},zze=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Qa.DOWNLOAD;let t=Vr();this.outputShape=e,this.userCode=`\n      ${W7}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},Bze={R:0,G:1,B:2,A:3},X7=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Vr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let i="";for(let s=0;s<n.length;s++)i+=`\n          if(offset == ${s}) {\n            result = values[${Bze[n[s]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kM(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${i}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},Vze=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Vr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){let o=2*i+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kM(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},Z7={};function Y7(e){let t=Vr();return x7(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Q7(e){return C7(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function J7(e){return E7(e,new Uint16Array([0,1,2,2,1,3]))}function Cv(e,t,n,r,a,i){N7(t,n);let s=k7(e),o=e.TEXTURE_2D;return ge(e,()=>e.bindTexture(o,s)),ge(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ge(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ge(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),ge(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===H().getNumber("WEBGL_VERSION")?ge(e,()=>e.texImage2D(o,0,r,t,n,0,a,i,null)):ge(e,()=>e.texStorage2D(o,1,r,t,n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:s,texShape:[n,t]}}function DM(e){return e.internalFormatFloat}function e9(e,t,n,r){let[a,i]=wv(t,n);return Cv(e,a,i,DM(r),r.textureFormatFloat,e.FLOAT)}function AM(e){return e.internalFormatHalfFloat}function t9(e,t,n,r){let[a,i]=wv(t,n);return Cv(e,a,i,AM(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function MM(e){return e.downloadTextureFormat}function n9(e,t,n,r){let[a,i]=wv(t,n);return Cv(e,a,i,MM(r),e.RGBA,e.UNSIGNED_BYTE)}function RM(e){return e.internalFormatPackedFloat}function r9(e,t,n,r){let[a,i]=Vf(t,n);return Cv(e,a,i,RM(r),e.RGBA,e.FLOAT)}function FM(e){return e.internalFormatPackedHalfFloat}function a9(e,t,n,r){let[a,i]=Vf(t,n);return Cv(e,a,i,FM(r),e.RGBA,r.textureTypeHalfFloat)}function i9(e,t,n){return ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),SM(e,t,"clipSpacePos",n,3,20,0)&&SM(e,t,"uv",n,2,20,12)}function s9(e,t,n,r,a,i){let s,o,l;ge(e,()=>e.bindTexture(e.TEXTURE_2D,t)),a instanceof Uint8Array?(s=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(s=new Float32Array(n*r*4),o=e.FLOAT,l=i.internalFormatPackedFloat),s.set(a),2===H().getNumber("WEBGL_VERSION")?ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,s)):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,s)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function o9(e,t,n){ge(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===H().getNumber("WEBGL_VERSION")?ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===H().getNumber("WEBGL_VERSION")?ge(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):ge(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ge(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function l9(e,t,n,r){let a=e.createBuffer();ge(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let i=16*t*n;return ge(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),ge(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ge(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function u9(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function c9(e,t,n,r){let[a,i]=wv(t,n),o=new Uint8Array(function P3e(e,t){return e*t}(t*n,4));return ge(e,()=>e.readPixels(0,0,a,i,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function d9(e,t,n,r,a,i,s,o){let l=e,u=new Float32Array(function L3e(e,t){let[n,r]=Vf(e,t);return n*r*4}(i,s));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function h9(e,t,n){let r=new Float32Array(t*n*4);return ge(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}je(Z7,{bindVertexProgramAttributeStreams:()=>i9,createBufferFromOutputTexture:()=>l9,createFloat16MatrixTexture:()=>t9,createFloat16PackedMatrixTexture:()=>a9,createFloat32MatrixTexture:()=>e9,createIndexBuffer:()=>J7,createPackedMatrixTexture:()=>r9,createUnsignedBytesMatrixTexture:()=>n9,createVertexBuffer:()=>Q7,createVertexShader:()=>Y7,downloadByteEncodedFloatMatrixFromOutputTexture:()=>c9,downloadFloat32MatrixFromBuffer:()=>u9,downloadMatrixFromPackedOutputTexture:()=>h9,downloadPackedMatrixFromBuffer:()=>d9,getInternalFormatForFloat16MatrixTexture:()=>AM,getInternalFormatForFloat16PackedMatrixTexture:()=>FM,getInternalFormatForFloat32MatrixTexture:()=>DM,getInternalFormatForPackedMatrixTexture:()=>RM,getInternalFormatForUnsignedBytesMatrixTexture:()=>MM,uploadDenseMatrixToTexture:()=>s9,uploadPixelDataToTexture:()=>o9});var QI=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=H().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,v7(t,e)):this.gl=Yi(t),e=this.gl,2===H().getNumber("WEBGL_VERSION")){let a=e;this.createVertexArray=()=>ge(a,()=>a.createVertexArray()),this.bindVertexArray=i=>ge(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>ge(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>ge(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(null!=e){let a=e.getExtension("OES_vertex_array_object");if(null==a)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ge(e,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>ge(e,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ge(e,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>ge(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===H().getNumber("WEBGL_VERSION")){let i="OES_texture_half_float";if(this.textureFloatExtension=xv(this.gl,"OES_texture_float"),Ja(this.gl,i))this.textureHalfFloatExtension=xv(this.gl,i);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Ja(this.gl,r))this.colorBufferHalfFloatExtension=xv(this.gl,r);else if(H().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Ja(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Ja(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Q7(this.gl),this.indexBuffer=J7(this.gl),this.framebuffer=T7(this.gl),this.textureConfig=xM(this.gl,this.textureHalfFloatExtension)}get debug(){return H().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;ge(e,()=>e.finish()),ge(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ge(e,()=>e.deleteFramebuffer(this.framebuffer)),ge(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ge(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),e9(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),t9(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),n9(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),o9(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),s9(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),a9(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),r9(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(_M(this.gl,this.framebuffer),this.outputTexture=null),ge(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>c9(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,i){return d9(this.gl,e,0,0,0,a,i)}downloadFloat32MatrixFromBuffer(e,t){return u9(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=l9(this.gl,t,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(H().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let i=r.clientWaitSync(a,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},t=a}else H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>h9(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=Y7(t));let n=S7(t);ge(t,()=>t.attachShader(n,this.vertexShader)),ge(t,()=>t.attachShader(n,e)),_7(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&GI(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;ge(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),i9(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(ge(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&GI(this.gl,this.program),ge(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?A7(this.gl,e,t):M7(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ge(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),R7(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Vf(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&GI(this.gl,this.program),Iv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ge(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ge(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=xv(this.gl,2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();return void t.endQuery(n.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return F(function*(){return yield I.repeatedTry(()=>t.disposed||t.isQueryAvailable(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=function Uze(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in H().platform&&(n=H().platform.setTimeoutCustom.bind(H().platform)),I.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),qI(this.gl,e,this.framebuffer),this.debug&&Iv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(qI(this.gl,this.outputTexture,this.framebuffer),this.debug&&Iv(this.gl)):_M(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;qI(r,e,this.framebuffer),this.debug&&Iv(r),this.outputTexture=e,ge(r,()=>r.viewport(0,0,t,n)),ge(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),ge(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}},{addImpl:Wze,bincountImpl:p9,bincountReduceImpl:jze,bitwiseAndImpl:Hze,castImpl:Gze,ceilImpl:qze,concatImpl:Kze,equalImpl:Xze,expImpl:Zze,expm1Impl:Yze,floorImpl:Qze,gatherNdImpl:Jze,gatherV2Impl:eBe,greaterImpl:tBe,greaterEqualImpl:nBe,lessImpl:rBe,lessEqualImpl:aBe,linSpaceImpl:iBe,logImpl:sBe,maxImpl:oBe,maximumImpl:lBe,minimumImpl:uBe,multiplyImpl:cBe,negImpl:dBe,notEqualImpl:hBe,prodImpl:pBe,raggedGatherImpl:fBe,raggedRangeImpl:mBe,raggedTensorToTensorImpl:gBe,rangeImpl:yBe,rsqrtImpl:vBe,scatterImpl:bBe,sigmoidImpl:wBe,simpleAbsImpl:f9,sliceImpl:xBe,sparseFillEmptyRowsImpl:IBe,sparseReshapeImpl:SBe,sparseSegmentReductionImpl:m9,sqrtImpl:_Be,staticRegexReplaceImpl:CBe,stridedSliceImpl:EBe,stringNGramsImpl:kBe,stringSplitImpl:NBe,stringToHashBucketFastImpl:TBe,subImpl:DBe,tileImpl:ABe,topKImpl:MBe,transposeImpl:OM,uniqueImpl:RBe}=rM;function g9(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ur(e,t){return 1===t?[e]:g9(e,t)}var OBe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Cr(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let t=Ur("rc",this.rank),n=Ut(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),i=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${e[e.length-1-i]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2);return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},y9=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`\n        ${a}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function $Be(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Z3e(e,t,n="index"){let a=function X3e(e,t){let n=e.length,r=e.map(i=>`${t}[${i}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let i=n-3;i>=0;--i)a[i]=`(${a[i+1]} * ${r[i+1]})`;return a}(e.map((i,s)=>s),t);return a.map((i,s)=>`int ${e[s]} = ${n} / ${a[s]}; ${s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a[s]}`:`index -= ${e[s]} * ${a[s]}`};`).join("")}(["r","c","d"],"inputShape"):Sd(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kM(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}},PBe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=b9(t,n),a=w9(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=v9(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let o=this.freeTextures[a].pop();return this.usedTextures[a].push(o),o}return r===fr.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===fr.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===fr.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===fr.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===fr.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=b9(n,r),i=w9(t,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);let s=v9(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=H().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;let l=this.usedTextures[i],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function v9(e,t,n,r,a){let s,i=function zBe(e,t){switch(e){case fr.PACKED_2X2_FLOAT32:return RM(t);case fr.PACKED_2X2_FLOAT16:return FM(t);case fr.UNPACKED_FLOAT32:return DM(t);case fr.UNPACKED_FLOAT16:return AM(t);case fr.PACKED_4X1_UNSIGNED_BYTE:return MM(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[l,u]=Vf(e[0],e[1]);s=l*u}else{let[l,u]=wv(e[0],e[1]);s=l*u}let o=function LBe(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F||t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return s*o}function b9(e,t){if(e===Qa.UPLOAD)return fr.PACKED_2X2_FLOAT32;if(e===Qa.RENDER||null==e)return function BBe(e){return H().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?fr.PACKED_2X2_FLOAT32:fr.UNPACKED_FLOAT32:e?fr.PACKED_2X2_FLOAT16:fr.UNPACKED_FLOAT16}(t);if(e===Qa.DOWNLOAD||e===Qa.PIXELS)return fr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function w9(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var As=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},xi="if (isnan(x)) return x;",VBe="return x;",x9="return abs(x);",UBe="return (x >= 0.0) ? x : (exp(x) - 1.0);",WBe=xi+"\n  return (x < 0.0) ? 0.0 : x;\n",jBe=xi+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",xl="return x;",HBe="return 1.0 / (1.0 + exp(-1.0 * x));",GBe="return x;",qBe="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",KBe="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",XBe="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",ZBe="return 1.0 / (1.0 + exp(-1.0 * x));",Il=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},YBe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let t=e.length,n=Ur("rc",t),r=Ut(t),a=function FBe(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),s=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}},QBe=_s.whereImpl,$M={},nVe=H().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),I9=(()=>{let e=class CQ extends Yg{nextDataId(){return CQ.nextDataId++}constructor(n){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!H().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=n){if(n instanceof QI)r=n;else{let a=Yi(H().getNumber("WEBGL_VERSION"),n);r=new QI(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=Yi(H().getNumber("WEBGL_VERSION"));r=new QI(a),this.binaryCache=function tVe(e){return e in $M||($M[e]={}),$M[e]}(H().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new PBe(this.gpgpu),this.numMBBeforeWarning=function aVe(){return null==H().global.screen?1024:H().global.screen.height*H().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new Yx(this,fi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(n,r,a,i,s,o){let l=this.makeTensorInfo(r,a),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:n,texShape:[i,s]},u.texShape=[i,s];let c=Sv(r),h=new X7(c,!1,o),d=this.runWebGLProgram(h,[l],a,[[i,s]]);return d.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),d.dataId}write(n,r,a){if((H().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||H().getBool("DEBUG"))&&this.checkNumericalProblems(n),"complex64"===a&&null!=n)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:a,values:n,usage:Qa.UPLOAD,refCount:1}),i}refCount(n){return this.texData.has(n)?this.texData.get(n).refCount:0}incRef(n){this.texData.get(n).refCount++}decRef(n){this.texData.has(n)&&this.texData.get(n).refCount--}move(n,r,a,i,s){if(H().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(n,{shape:a,dtype:i,values:r,usage:Qa.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(n){this.disposeData(n.dataId)}readSync(n){let r=this.texData.get(n),{values:a,dtype:i,complexTensorInfos:s,slice:o,shape:l,isPacked:u}=r;if(null!=o){let p;p=u?new Il(l,xl):new As(l,xl);let f=this.runWebGLProgram(p,[{dataId:n,shape:l,dtype:i}],i),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(null!=a)return this.convertAndCacheOnCPU(n);if("string"===i)return a;let h,d,c=null!=this.activeTimers;if(c&&(h=I.now()),"complex64"===i){let p=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);d=E.mergeRealAndImagArrays(p,f)}else d=this.getValuesFromTexture(n);return c&&(this.downloadWaitMs+=I.now()-h),this.convertAndCacheOnCPU(n,d)}read(n){var r=this;return F(function*(){if(r.pendingRead.has(n)){let g=r.pendingRead.get(n);return new Promise(y=>g.push(y))}let a=r.texData.get(n),{values:i,shape:s,slice:o,dtype:l,complexTensorInfos:u,isPacked:c}=a;if(null!=o){let g;g=c?new Il(s,xl):new As(s,xl);let y=r.runWebGLProgram(g,[{dataId:n,shape:s,dtype:l}],l),v=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),v}if(null!=i)return r.convertAndCacheOnCPU(n);if(H().getBool("DEBUG")&&!H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===H().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d,p,h=null;if("complex64"!==l&&H().get("WEBGL_BUFFER_SUPPORTED")){d=r.decode(n);let g=r.texData.get(d.dataId);h=r.gpgpu.createBufferFromTexture(g.texture.texture,...HI(s))}if(r.pendingRead.set(n,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){let g=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);p=E.mergeRealAndImagArrays(g[0],g[1])}else if(null==h)p=r.getValuesFromTexture(n);else{let g=I.sizeFromShape(s);p=r.gpgpu.downloadFloat32MatrixFromBuffer(h,g)}if(null!=d&&r.disposeIntermediateTensorInfo(d),null!=h){let g=r.gpgpu.gl;ge(g,()=>g.deleteBuffer(h))}let f=r.convertAndCacheOnCPU(n,p),m=r.pendingRead.get(n);return r.pendingRead.delete(n),m.forEach(g=>g(f)),r.pendingDisposal.has(n)&&(r.pendingDisposal.delete(n),r.disposeData(n)&&fi().removeDataId(n,r),r.pendingDeletes--),f})()}readToGPU(n,r={}){let a=this.texData.get(n),{values:i,shape:s,slice:o,dtype:l,isPacked:u,texture:c}=a;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let f;f=u?new Il(s,xl):new As(s,xl);let m=this.runWebGLProgram(f,[{dataId:n,shape:s,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==c)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let h=this.decode(n,r.customTexShape),d=fi().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(n){let r=this.readSync(n.dataId);if("string"===n.dtype)try{let a=r.map(i=>I.decodeString(i));return Je(n.shape,n.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Je(n.shape,n.dtype,r)}checkNumericalProblems(n){if(null!=n)for(let r=0;r<n.length;r++){let a=n[r];if(!b7(a))throw H().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(n){let{shape:r,dtype:a,isPacked:i}=this.texData.get(n),s=I.sizeFromShape(r);if(H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(n),f=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...HI(r)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),m}let o=H().getBool("WEBGL_PACK")&&!0===i,l=o?Sv(r):r,u=o?new zze(l):new Lze(l),c=this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:n}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(n){var r=this;let a=this.activeTimers,i=[],s=!1;null==this.programTimersStack?(this.programTimersStack=i,s=!0):this.activeTimers.push(i),this.activeTimers=i,n();let o=I.flatten(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=I.flatten(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=a,s&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return F(function*(){if(H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let c=yield Promise.all(o);u.kernelMs=I.sum(c),u.getExtraProfileInfo=()=>c.map((h,d)=>({name:l[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:I.now(),endMs:null}}endTimer(n){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),n):(n.endMs=I.now(),n)}getQueryTime(n){var r=this;return F(function*(){return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(n):n.endMs-n.startMs})()}disposeData(n,r=!1){if(this.pendingDisposal.has(n))return!1;if(!this.texData.has(n))return!0;if(r?this.texData.get(n).refCount=0:this.texData.get(n).refCount--,!r&&this.texData.get(n).refCount>0)return!1;if(this.pendingRead.has(n))return this.pendingDisposal.add(n),this.pendingDeletes++,!1;this.releaseGPUData(n);let{complexTensorInfos:a}=this.texData.get(n);return null!=a&&(this.disposeData(a.real.dataId,r),this.disposeData(a.imag.dataId,r)),this.texData.delete(n),!0}releaseGPUData(n){let{texture:r,dtype:a,texShape:i,usage:s,isPacked:o,slice:l}=this.texData.get(n),u=l&&l.origDataId||n,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,a),this.textureManager.releaseTexture(r,i,s,o)));let h=this.texData.get(n);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(n){return this.uploadToGPU(n),this.texData.get(n).texture.texture}getDataInfo(n){return this.texData.get(n)}shouldExecuteOnCPU(n,r=nVe){return H().getBool("WEBGL_CPU_FORWARD")&&n.every(a=>null==this.texData.get(a.dataId).texture&&I.sizeFromShape(a.shape)<r)}getGPGPUContext(){return this.gpgpu}where(n){E.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=n.dataSync();return QBe(n.shape,r)}packedUnaryOp(n,r,a){let i=new Il(n.shape,r),s=this.compileAndRun(i,[n],a);return fi().makeTensorFromTensorInfo(s)}abs(n){if(this.shouldExecuteOnCPU([n])&&"complex64"!==n.dtype){let i=f9(this.texData.get(n.dataId).values);return this.makeOutput(n.shape,n.dtype,i)}if(H().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(n,x9,n.dtype);let r=new As(n.shape,x9),a=this.compileAndRun(r,[n]);return fi().makeTensorFromTensorInfo(a)}makeTensorInfo(n,r,a){let i;if("string"===r&&null!=a&&a.length>0&&I.isString(a[0])){let s=a.map(o=>I.encodeString(o));i=this.write(s,n,r)}else i=this.write(a,n,r);return this.texData.get(i).usage=null,{dataId:i,shape:n,dtype:r}}makeOutput(n,r,a){return fi().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,a),this)}unpackTensor(n){let r=new YBe(n.shape);return this.runWebGLProgram(r,[n],n.dtype)}packTensor(n){let r=new OBe(n.shape);return this.runWebGLProgram(r,[n],n.dtype,null,!0)}packedReshape(n,r){let a=[xd(n.shape),...Id(n.shape)],i={dtype:n.dtype,shape:a,dataId:n.dataId},s=[xd(r),...Id(r)],o=new y9(s,a),c=this.runWebGLProgram(o,[i],n.dtype,[a],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(n,r){let a=this.texData.get(n),{isPacked:i,shape:s,dtype:o}=a;if(null!=r){let p=I.sizeFromShape(s);I.assert(p<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let u,l=Sv(s);u=i?new Pze(l):new $ze(l);let h=[r??HI(l)];return{dtype:o,shape:s,dataId:this.runWebGLProgram(u,[{shape:l,dtype:o,dataId:n}],o,h,!0,r).dataId}}runWebGLProgram(n,r,a,i,s=!1,o){let l=this.makeTensorInfo(n.outputShape,a),u=this.texData.get(l.dataId);if(n.packedOutput&&(u.isPacked=!0),n.outPackingScheme===bv.DENSE){let v=o??HI(n.outputShape);u.texShape=v.map(b=>2*b)}if(null!=n.outTexUsage&&(u.usage=n.outTexUsage),0===I.sizeFromShape(l.shape))return u.values=I.getTypedArrayFromDType(l.dtype,0),l;let c=[],h=r.map(v=>{if("complex64"===v.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(v.dataId);if(null==b.texture){if(!n.packedInputs&&I.sizeFromShape(v.shape)<=H().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:b.values};n.packedInputs&&(b.isPacked=!0,b.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!b.isPacked!=!!n.packedInputs)v=b.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),b=this.texData.get(v.dataId);else if(b.isPacked&&!_v(b.shape,v.shape)){let w=v,x=v.shape;v.shape=b.shape,v=this.packedReshape(v,x),c.push(v),b=this.texData.get(v.dataId),w.shape=x}return{shape:v.shape,texData:b,isUniform:!1}});this.uploadToGPU(l.dataId);let g,d={shape:l.shape,texData:u,isUniform:!1},p=function Oze(e,t,n){let r="";t.concat(n).forEach(s=>{let o=null!=s.texData&&null!=s.texData.slice&&s.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!s.isUniform){let l=s.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=TM(e.packedInputs,s.shape,l),d="",p="",f="";if(1===c.length&&e.packedInputs){let x=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${x[0]>1}_${x[1]>1}`}else if(2!==c.length||e.packedInputs){if(c.length>2&&!e.packedInputs){let x=I.computeStrides(c);f=`${x[0]===l[1]}_${x[x.length-1]===l[1]}`}}else p=`${c[0]>1}_${c[1]>1}`;let m=s.shape.length,g=2===c.length&&I.arraysEqual(s.shape,l),y=1===I.sizeFromShape(s.shape),v=E.getBroadcastDims(s.shape,n.shape),b=!e.packedInputs&&m===n.shape.length&&I.arraysEqual(l,n.texData.texShape);r+=`${m}_${b}_${u?h:""}_${c.length}_${y}_${v}_${g}_${d}_${p}_${f}_${e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${o}`}else r+=`${s.shape}_${s.isUniform?"uniform":s.texData.texShape}_${o}`});let i=e.constructor.name;return i+="_"+r+"_"+e.userCode+`${H().getNumber("WEBGL_VERSION")}`,i}(n,h,d),f=this.getAndSaveBinary(p,()=>function Rze(e,t,n,r){let a=n.map((c,h)=>{let d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),i=a.map(c=>c.shapeInfo),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Y3e(a,s,t),l=I7(e.gl,o),u=e.createProgram(l);return H().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:s,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:s},q7(e,t,u)))}(this.gpgpu,n,h,d)),m=null!=this.activeTimers;m&&(g=this.startTimer()),H().get("ENGINE_COMPILE_ONLY")||function Fze(e,t,n,r,a){t.program.enableShapeUniforms||(K7(t.inShapeInfos,n),K7([t.outShapeInfo],[r]));let i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,s[0],s[1]):e.setOutputMatrixTexture(i.texture,s[0],s[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===H().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:h,shape:d,texShape:p}=t.variablesLocations[l];if(d){let{uniformShape:f}=TM(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(d,new Int32Array(f));break;case 2:e.gl.uniform2iv(d,new Int32Array(f));break;case 3:e.gl.uniform3iv(d,new Int32Array(f));break;case 4:e.gl.uniform4iv(d,new Int32Array(f))}}if(p&&e.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(I.sizeFromShape(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(c,f)}continue}null!=u.texData.slice&&null!=h&&e.gl.uniform1i(h,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let l=I.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],h=a[l];if("float"===u.type)e.gl.uniform1fv(c,h);else if("vec2"===u.type)e.gl.uniform2fv(c,h);else if("vec3"===u.type)e.gl.uniform3fv(c,h);else if("vec4"===u.type)e.gl.uniform4fv(c,h);else if("int"===u.type)e.gl.uniform1iv(c,h);else if("ivec2"===u.type)e.gl.uniform2iv(c,h);else if("ivec3"===u.type)e.gl.uniform3iv(c,h);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);e.gl.uniform4iv(c,h)}}e.executeProgram()}(this.gpgpu,f,h,d,i),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),m&&(g=this.endTimer(g),this.activeTimers.push({name:n.constructor.name,query:this.getQueryTime(g)}));let y=H().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let v=I.now();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!H().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===s){let v=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),v}return l}compileAndRun(n,r,a,i,s=!1){return this.runWebGLProgram(n,r,a=a||r[0].dtype,i,s)}getAndSaveBinary(n,r){return n in this.binaryCache||(this.binaryCache[n]=r()),this.binaryCache[n]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(H().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=V(()=>{if(!H().get("WEBGL_RENDER_FLOAT32_ENABLED")){let n=H().getBool("DEBUG");H().set("DEBUG",!1);let r=this.abs(ke(1e-8)).dataSync()[0];if(H().set("DEBUG",n),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(n){let r=this.texData.get(n),{shape:a,dtype:i,values:s,texture:o,usage:l,isPacked:u}=r;if(null!=o)return;let h,c=null!=this.activeTimers;c&&(h=I.now());let d=r.texShape;if(null==d&&(d=$7(a,u),r.texShape=d),null!=s){let f,p=Sv(a),m=d[1],g=d[0],y=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!y)&&([m,g]=Vf(d[0],d[1])),f=u?new Vze(p,y):new X7(p,y);let v=y?[g,m]:d,b=this.makeTensorInfo(v,i),w=this.texData.get(b.dataId);w.usage=y?Qa.PIXELS:Qa.UPLOAD,w.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),m,g,s);let C=this.runWebGLProgram(f,[b],i,[[g,m]],!0),k=this.texData.get(C.dataId);r.texShape=k.texShape,r.isPacked=k.isPacked,r.usage=k.usage,H().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(r.texture=k.texture,r.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=I.now()-h)}else{let p=this.acquireTexture(d,l,i,u);r.texture=p}}convertAndCacheOnCPU(n,r){let a=this.texData.get(n),{dtype:i}=a;return null!=r&&(a.values=function iVe(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}throw new Error(`Unknown dtype ${t}`)}(r,i)),a.values}acquireTexture(n,r,a,i){if(this.numBytesInGPU+=this.computeBytes(n,a),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(n,r,i)}computeBytes(n,r){return n[0]*n[1]*I.bytesPerElement(r)}checkCompileCompletion(){for(let[,n]of Object.entries(this.binaryCache))this.checkCompletion_(n)}checkCompileCompletionAsync(){var n=this;return F(function*(){let r=[];if(n.gpgpu.parallelCompilationExtension){for(let[,a]of Object.entries(n.binaryCache))r.push(n.checkCompletionAsync_(a));return Promise.all(r)}for(let[,a]of Object.entries(n.binaryCache)){let i=new Promise(s=>{try{n.checkCompletion_(a),s(!0)}catch(o){throw o}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(n){var r=this;return F(function*(){return r.gpgpu.gl.getProgramParameter(n.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(n):(yield xD(),r.checkCompletionAsync_(n))})()}checkCompletion_(n){if(!1===this.gpgpu.gl.getProgramParameter(n.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(n.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(n.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(IM(n.source,this.gpgpu.gl.getShaderInfoLog(n.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let n of Object.values(this.binaryCache)){this.gpgpu.buildVao(n.webGLProgram);let{variablesLocations:r,customUniformLocations:a,infLoc:i,nanLoc:s,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=q7(this.gpgpu,n.program,n.webGLProgram);n.variablesLocations=r,n.customUniformLocations=a,n.infLoc=i,n.nanLoc=s,n.outShapeLocation=o,n.outShapeStridesLocation=l,n.outTexShapeLocation=u}}createTensorFromGPUData(n,r,a){n.channels=n.channels||"RGBA";let{texture:i,height:s,width:o,channels:l}=n,u=fi().backend;if(!u.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=u.writeTexture(i,r,a,s,o,l);return fi().makeTensorFromDataId(c,r,a,u)}};return e.nextDataId=0,e})(),sVe="4.16.0";function S9(){H().set("WEBGL_FORCE_F16_TEXTURES",!0)}Ay.isBrowser()&&C0("webgl",()=>new I9,2);var oVe={forceHalfFloat:S9},PM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",Cd=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Ed="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",qf=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=E.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=Cr(a);let i="";if(r)if(0===a||1===I.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Ut(a)} coords = getOutputCoords();\n        `,1===a)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let s=Ur("coords",a);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${s[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${s[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${s[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${s[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}};function Fa(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var lVe={kernelName:Qu,backendName:"webgl",kernelFunc:Fa};function Sl(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.makeTensorInfo(r.shape,"complex64"),s=n.texData.get(i.dataId),o=Fa({inputs:{x:r},backend:n}),l=Fa({inputs:{x:a},backend:n});return s.complexTensorInfos={real:o,imag:l},i}var uVe={kernelName:r0,backendName:"webgl",kernelFunc:Sl},_9="return (a < 0.) ? b * a : a;",C9="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",dVe={kernelName:nc,backendName:"webgl",kernelFunc:function cVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r,s=n.makeTensorInfo([],"float32",I.createScalarValue(i,"float32")),o=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qf(C9,a.shape,s.shape):new Cd(_9,a.shape,s.shape),l=n.runWebGLProgram(o,[a,s],"float32");return n.disposeIntermediateTensorInfo(s),l}},E9="return (a < 0.) ? b * a : a;",k9="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",pVe={kernelName:vc,backendName:"webgl",kernelFunc:function hVe(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qf(k9,r.shape,a.shape):new Cd(E9,r.shape,a.shape);return n.runWebGLProgram(i,[r,a],"float32")}},Kf="if (isnan(x)) return x;";function yt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:i})=>{let c,{x:s}=a,o=i,l=r||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=n){let h=o.texData.get(s.dataId),d=n(h.values,l);return o.makeTensorInfo(s.shape,l,d)}return c=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Il(s.shape,t):new As(s.shape,e),o.runWebGLProgram(c,[s],l)}}function mr({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:i}){return({inputs:s,backend:o})=>{let{a:l,b:u}=s,c=o;if(r&&"complex64"===l.dtype){let f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{let[w,x]=b,C={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:x.dataId,dtype:x.dtype,shape:u.shape},T=new Cd(e,l.shape,u.shape);return c.runWebGLProgram(T,[C,k],Ga(w.dtype,x.dtype))}),v=Sl({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),v}let p,h=i||Ga(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=a){let f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g="string"===l.dtype?E.fromUint8ToStringArray(f):f,y="string"===l.dtype?E.fromUint8ToStringArray(m):m,[v,b]=a(l.shape,u.shape,g,y,h),w=c.makeTensorInfo(b,h);return c.texData.get(w.dataId).values=v,w}return p=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new qf(t,l.shape,u.shape,n):new Cd(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Ev(e,t=!1){if("linear"===e)return t?GBe:VBe;if("relu"===e)return t?KBe:WBe;if("elu"===e)return t?qBe:UBe;if("relu6"===e)return t?XBe:jBe;if("prelu"===e)return t?k9:E9;if("leakyrelu"===e)return t?C9:_9;if("sigmoid"===e)return t?ZBe:HBe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var N9=class{constructor(e,t,n,r=!1,a=!1,i=!1,s=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Cr(this.outputShape.length);let c=Math.ceil((r?e[1]:e[2])/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";s&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");let y=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let v="rc.x",b="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(b=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${v};\n        int batchB = ${b};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},T9={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},D9=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},A9="return a * b;";function LM(e){let s,{inputs:t,backend:n}=e,{a:r,b:a}=t,i=E.upcastType(r.dtype,a.dtype);if("complex64"===r.dtype){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),u=new D9(T9.REAL,r.shape,a.shape),c=new D9(T9.IMAG,r.shape,a.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=Sl({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[u,c]=cBe(r.shape,a.shape,o.values,l.values,i),h=n.makeTensorInfo(c,i);return n.texData.get(h.dataId).values=u,h}return s=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qf(A9,r.shape,a.shape):new Cd(A9,r.shape,a.shape),n.runWebGLProgram(s,[r,a],i)}var fVe={kernelName:fc,backendName:"webgl",kernelFunc:LM};function me(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,s=n,o=I.sizeFromShape(a.shape),l=I.inferFromImplicitShape(i,o),u=I.sizeFromShape(l);I.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=s.texData.get(a.dataId);return!c.isPacked||_v(a.shape,l)||null!==c.texture&&_v(c.shape,l)?(s.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function mVe(e,t,n){let r=[xd(e.shape),...Id(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},i=[xd(t),...Id(t)],s=new y9(i,r),u=n.runWebGLProgram(s,[a],e.dtype,[r],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(a,l,s)}var gVe={kernelName:Up,backendName:"webgl",kernelFunc:me},M9=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let s=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let c=1/t;l=`sumValue += dot(values * ${I.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},yVe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let s="0.0",o="";"prod"===t?s="1.0":"min"===t?(s="1.0 / 1e-20",o="min"):"max"===t&&(s="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),c=n%4,h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(s="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(s="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}};function kd(e,t,n,r){let a=function vVe(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=E.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),i=e;for(let s=0;s<a.length;s++){let c,h,{inSize:o,windowSize:l,outSize:u}=a[s];c="mean"===n?0===s?new M9({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new M9({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new yVe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=i,i=r.runWebGLProgram(c,[i],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return i}var bVe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let r=Ut(this.rank),a=function wVe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}},xVe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Ut(this.rank),a=g9("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=a[u];let s=`vec2(${i.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function JI(e,t,n){let r=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xVe(e.shape,t):new bVe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function e1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r;return function IVe(e,t,n,r){let i=e.shape.length,s=I.parseAxisParam(t,e.shape),o=s,l=E.getAxesPermutation(o,i),u=null!=l,c=e;u&&(c=JI(e,l,r),o=E.getInnerMostAxes(o.length,i)),E.assertAxesAreInnerMostDims("sum",o,i);let[h,d]=E.computeOutAndReduceShapes(c.shape,o),p=h;n&&(p=E.expandShapeToKeepDim(h,s));let f=I.sizeFromShape(d),g=me({inputs:{x:c},attrs:{shape:[I.sizeFromShape(e.shape)/f,f]},backend:r}),v=kd(g,S0(e.dtype),"sum",r),b=me({inputs:{x:v},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),b}(a,i,s,n)}var SVe={kernelName:Oc,backendName:"webgl",kernelFunc:e1};function Wr(e){let u,{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:i}=r,s=n,l=new Array(a.shape.length);for(let c=0;c<l.length;c++)l[c]=a.shape[i[c]];if(s.shouldExecuteOnCPU([a])){let c=s.texData.get(a.dataId).values,h=OM(c,a.shape,a.dtype,i,l);u=s.makeTensorInfo(l,a.dtype),s.texData.get(u.dataId).values=h}else u=JI(a,i,s);return u}var _Ve={kernelName:eo,backendName:"webgl",kernelFunc:Wr},R9=1e3;function t1({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=I.sizeFromShape(m),v=I.sizeFromShape(g),b=mf.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);I.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let G,w=n?[y,h,p]:[y,p,h],x=r?[v,f,d]:[v,d,f],C=me({inputs:{x:e},backend:a,attrs:{shape:w}}),k=me({inputs:{x:t},backend:a,attrs:{shape:x}}),T=[C,k],A=Math.max(y,v),R=n?C.shape[1]:C.shape[2],M=null!=i,_=null!=s,$="leakyrelu"===l,U=null!=l?Ev(l,!0):null;if((1===p||1===f)&&R>R9&&!1===(M||_||$||null!=U)){let X=C,Y=k;n&&(X=Wr({inputs:{x:C},backend:a,attrs:{perm:[0,2,1]}}),T.push(X)),r&&(Y=Wr({inputs:{x:k},backend:a,attrs:{perm:[0,2,1]}}),T.push(Y));let te=1===f,se=X;1!==f&&(se=me({inputs:{x:X},backend:a,attrs:{shape:[A,R,1]}}),T.push(se));let re=1===f?2:1,oe=Y;te&&(oe=me({inputs:{x:Y},backend:a,attrs:{shape:[A,1,R]}}),T.push(oe));let le=LM({inputs:{a:se,b:oe},backend:a});G=e1({inputs:{x:le},backend:a,attrs:{axis:re,keepDims:!0}}),T.push(le)}else{let X=Ga(e.dtype,t.dtype),Y=new N9(w,x,[A,p,f],n,r,M,U,_,$),ee=[C,k];if(null!=i&&ee.push(i),_&&ee.push(s),$){let te=a.makeTensorInfo([],"float32",I.createScalarValue(o,"float32"));ee.push(te),T.push(te)}G=a.runWebGLProgram(Y,ee,X)}let K=me({inputs:{x:G},backend:a,attrs:{shape:b}});T.push(G);for(let X of T)a.disposeIntermediateTensorInfo(X);return K}var EVe={kernelName:Vc,backendName:"webgl",kernelFunc:function CVe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:i,bias:s,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return t1({a,b:i,transposeA:l,transposeB:u,backend:n,bias:s,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},F9="return abs(x);",NVe={kernelName:np,backendName:"webgl",kernelFunc:function kVe(e){let a,{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){let i=n.texData.get(r.dataId),s=f9(i.values);return n.makeTensorInfo(r.shape,r.dtype,s)}return a=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Il(r.shape,F9):new As(r.shape,F9),n.runWebGLProgram(a,[r],r.dtype)}},DVe=yt({opSnippet:xi+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),AVe={kernelName:Su,backendName:"webgl",kernelFunc:DVe},RVe=yt({opSnippet:xi+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),FVe={kernelName:_u,backendName:"webgl",kernelFunc:RVe},O9="return a + b;",OVe=mr({opSnippet:O9,packedOpSnippet:O9,supportsComplex:!0,cpuKernelImpl:Wze}),$Ve={kernelName:Ho,backendName:"webgl",kernelFunc:OVe},PVe=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,i)=>`T${i}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},LVe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,i)=>`T${i}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}},zVe={kernelName:Cu,backendName:"webgl",kernelFunc:function n1(e){let{inputs:t,backend:n}=e,r=t;if(1===r.length)return Fa({inputs:{x:r[0]},backend:n});if(r.length>H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=n1({inputs:r.slice(0,o),backend:n}),u=n1({inputs:r.slice(o),backend:n});return n1({inputs:[l,u],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>Ga(o,l)),i=r.map(o=>o.shape),s=H().getBool("WEBGL_PACK")?new LVe(r[0].shape,i):new PVe(r[0].shape,i);return n.runWebGLProgram(s,r,a)}},VVe={kernelName:rp,backendName:"webgl",kernelFunc:function BVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=I.parseAxisParam(i,a.shape),u=l,c=E.getAxesPermutation(u,o),h=a;null!=c&&(h=Wr({inputs:{x:a},backend:n,attrs:{perm:c}}),u=E.getInnerMostAxes(u.length,o)),E.assertAxesAreInnerMostDims("all",u,o);let y,[d,p]=E.computeOutAndReduceShapes(h.shape,u),m=me({inputs:{x:h},backend:n,attrs:{shape:[-1,I.sizeFromShape(p)]}}),g=kd(m,m.dtype,"all",n);return y=me(s?{inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}},WVe={kernelName:ap,backendName:"webgl",kernelFunc:function UVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=I.parseAxisParam(i,a.shape),u=l,c=E.getAxesPermutation(u,o),h=a;null!=c&&(h=Wr({inputs:{x:a},backend:n,attrs:{perm:c}}),u=E.getInnerMostAxes(u.length,o)),E.assertAxesAreInnerMostDims("any",u,o);let y,[d,p]=E.computeOutAndReduceShapes(h.shape,u),m=me({inputs:{x:h},backend:n,attrs:{shape:[-1,I.sizeFromShape(p)]}}),g=kd(m,m.dtype,"any",n);return y=me(s?{inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}},jVe=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},HVe=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let i=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");let c,h,s=this.outputShape,o=s.length,l=Ut(o),u=Ur("coords",o);if(1===i){h=o+1;let k=Ut(h);c=`\n        ${k} sourceLocR = ${k}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${k} sourceLocG = ${k}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${k} sourceLocA = ${k}(${u.join()}, 0);\n        --${u[o-1]};\n        ${k} sourceLocB = ${k}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;let d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(k=>"int "+k),m=Ur("sourceLocR",h-1).concat("inIdx.r"),g=Ur("sourceLocG",h-1).concat("inIdx.g"),y=Ur("sourceLocB",h-1).concat("inIdx.b"),v=Ur("sourceLocA",h-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,C=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${C}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${s[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${s[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function $9(e,t,n,r=null){let a=t.shape[0],i=t.shape[1];null!=r&&(a=r.shape[0],i=r.shape[1]);let s=E.computeOptimalWindowSize(i),o={windowSize:s,inSize:i,batchSize:a,outSize:Math.ceil(i/s)},l=new jVe(o,n,null==r),u=[t];null!=r&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;let h=$9(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function P9(e,t,n,r=null){let a=null!=r?r.shape:t.shape,s=E.computeOptimalWindowSize(a[a.length-1]),o=new HVe(a,s,n,null==r),u=e.runWebGLProgram(o,null==r?[t]:[t,r],"int32");if(u.shape.length===t.shape.length){let c=P9(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function L9(e,t,n,r){let a=[n];if(E.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!H().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let i=[],s=e.texData.get(t.dataId),l=t;null!==s&&s.isPacked&&(l=e.unpackTensor(t),i.push(l));let[u,c]=E.computeOutAndReduceShapes(l.shape,a),h=I.sizeFromShape(c),d=me({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});i.push(d);let p=$9(e,d,r);i.push(p);let f=me({inputs:{x:p},backend:e,attrs:{shape:u}});return i.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return P9(e,t,r)}var qVe={kernelName:ip,backendName:"webgl",kernelFunc:function GVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,s=I.parseAxisParam(i,a.shape),o=E.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=Wr({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=E.getInnerMostAxes(s.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMax",[s[0]],l.shape.length);let c=L9(n,l,s[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}},XVe={kernelName:sp,backendName:"webgl",kernelFunc:function KVe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,s=I.parseAxisParam(i,a.shape),o=E.getAxesPermutation(s,a.shape.length),l=a,u=[];null!=o&&(l=Wr({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),s=E.getInnerMostAxes(s.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMin",[s[0]],l.shape.length);let c=L9(n,l,s[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}},YVe=yt({opSnippet:xi+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),QVe={kernelName:Eu,backendName:"webgl",kernelFunc:YVe},eUe=yt({opSnippet:xi+"return log(x + sqrt(x * x + 1.0));"}),tUe={kernelName:ku,backendName:"webgl",kernelFunc:eUe},rUe=yt({opSnippet:xi+"\n  return atan(x);\n"}),aUe={kernelName:Nu,backendName:"webgl",kernelFunc:rUe},oUe=mr({opSnippet:PM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Ed+"\n  return result;\n"}),lUe={kernelName:Du,backendName:"webgl",kernelFunc:oUe},cUe=yt({opSnippet:xi+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),dUe={kernelName:Tu,backendName:"webgl",kernelFunc:cUe},kv=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,y="0.0";if(f||(y="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let w=4*Math.floor(i/4),x=i%4,C=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${C}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${C}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${C}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${C}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},zM=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let v="avg"===t,b="0.0";if(v||(b="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let C=4*Math.floor(i/4),k=i%4,T=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${C}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${C};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}},pUe={kernelName:Au,backendName:"webgl",kernelFunc:function hUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Uf(a,"avgPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;I.assert(E.eitherStridesOrDilationsAreOne(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let c=E.computePool2DInfo(a.shape,i,s,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&I.arraysEqual(c.inShape,c.outShape))return Fa({inputs:{x:a},backend:n});let h=new kv(c,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}},mUe={kernelName:op,backendName:"webgl",kernelFunc:function fUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,h=E.computePool3DInfo(a.shape,i,s,[1,1,1],o,l,u),d=new zM(h,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},gUe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let o=e.effectiveFilterHeight,l=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-e.padInfo.top}, ${l-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},yUe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${c-1-e.padInfo.front}, ${h-1-e.padInfo.top}, ${d-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},bUe={kernelName:ny,backendName:"webgl",kernelFunc:function vUe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=E.computePool3DInfo(s.shape,o,l,[1,1,1],u,c),p=new yUe(d);return n.runWebGLProgram(p,[a],s.dtype)}},xUe={kernelName:ty,backendName:"webgl",kernelFunc:function wUe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i;Uf([a,i],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=E.computePool2DInfo(s.shape,o,l,1,u),h=new gUe(c);return n.runWebGLProgram(h,[a],s.dtype)}},SUe={kernelName:Mu,backendName:"webgl",kernelFunc:function IUe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:i}=t,{transposeA:s,transposeB:o}=r;return t1({a,b:i,transposeA:s,transposeB:o,backend:n})}},_Ue=class{constructor(e,t,n,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let s="0.0";null!=r&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="1.0";null!=a&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${s};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},CUe=class{constructor(e,t,n,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let s="vec4(0.0)";null!=r&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${s};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},kUe={kernelName:Zu,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:i,offset:s,scale:o}=e;I.assert(a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I.assert(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,i],c=null;null!=s&&(c=s.shape,u.push(s));let h=null;null!=o&&(h=o.shape,u.push(o));let d=H().getBool("WEBGL_PACK_NORMALIZATION")?new CUe(r.shape,a.shape,i.shape,c,h,l):new _Ue(r.shape,a.shape,i.shape,c,h,l);return t.runWebGLProgram(d,u,u[0].dtype)}},NUe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Ut(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r,n=function TUe(e){if(1===e)return"sourceLoc";if(e<=6)return BM.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((i,s)=>`sourceLoc.${BM[s]} = start[${s}] + coords.${BM[s]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}},BM=["x","y","z","w","u","v"],DUe=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Ut(this.rank),n=Ur("coords",this.rank),r=Ur("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,s=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${s}\n        ${o}\n        setOutput(result);\n      }\n    `}};function Xf(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:s}=r,[o,l]=Vn.parseSliceParams(a,i,s);if(Vn.assertParamsValid(a,o,l),0===I.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let h=n.texData.get(a.dataId),d=xBe(h.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,d)}let{isPacked:u}=n.texData.get(a.dataId),c=Vn.isSliceContinous(a.shape,o,l);if(u||!c){let h=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DUe(l):new NUe(l);return n.runWebGLProgram(h,[a],a.dtype,[o])}return n.uploadToGPU(a.dataId),function AUe(e,t,n,r){let a=r.texData.get(e.dataId),i=r.makeTensorInfo(n,e.dtype),s=r.texData.get(i.dataId);Object.assign(s,a),s.refCount=1,s.shape=n,s.dtype=e.dtype;let o=Vn.computeFlatOffset(t,I.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),s.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(s.slice.origDataId)||1;return r.dataRefCount.set(s.slice.origDataId,l+1),i}(a,o,l,n)}var MUe={kernelName:Xp,backendName:"webgl",kernelFunc:Xf},FUe={kernelName:lp,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r;I.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=i.reduce((v,b)=>v*b),l=E.getReshaped(a.shape,i,o),u=E.getPermuted(l.length,i.length),c=E.getReshapedPermuted(a.shape,i,o),h=E.getSliceBeginCoords(s,i.length),d=E.getSliceSize(c,s,i.length),p=[],f=me({inputs:{x:a},backend:n,attrs:{shape:l}}),m=Wr({inputs:{x:f},backend:n,attrs:{perm:u}}),g=me({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Xf({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(v=>n.disposeIntermediateTensorInfo(v)),y}},$Ue={kernelName:up,backendName:"webgl",kernelFunc:function OUe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s}=r,o=n.readSync(a.dataId),l=n.readSync(i.dataId),u=p9(o,l,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,u)}},BUe={kernelName:cp,backendName:"webgl",kernelFunc:function zUe(e){let o,{inputs:t,backend:n}=e,{a:r,b:a}=t,i=H().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=H().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===s){let l=n.texData.get(r.dataId).values,u=n.texData.get(a.dataId).values,[c,h]=Hze(r.shape,a.shape,l,u,r.dtype),d=n.makeTensorInfo(h,r.dtype);return n.texData.get(d.dataId).values=c,d}return o=i?new qf("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new Cd("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}},UUe={kernelName:ry,backendName:"webgl",kernelFunc:function VUe(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.readSync(r.dataId),s=n.readSync(a.dataId),o=E.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},z9=mr({opSnippet:"return float(a != b);",cpuKernelImpl:hBe,dtype:"bool"}),jUe={kernelName:$p,backendName:"webgl",kernelFunc:z9};function Nv(e){let{inputs:t,backend:n}=e,{input:r}=t;return Fa({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var HUe={kernelName:g0,backendName:"webgl",kernelFunc:Nv},KUe={kernelName:Ru,backendName:"webgl",kernelFunc:function VM(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===a.dtype)return Fa({inputs:{x:a},backend:n});let s=mn(a.shape),o=VM({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=Sl({inputs:{real:o,imag:s},backend:n});return s.dispose(),n.disposeIntermediateTensorInfo(o),l}if("complex64"===a.dtype){let s=Nv({inputs:{input:a},backend:n}),o=VM({inputs:{x:s},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(s),o}if(!I.hasEncodingLoss(a.dtype,i)){let s=Fa({inputs:{x:a},backend:n});return{dataId:s.dataId,shape:s.shape,dtype:i}}if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId).values,[o,l,u]=Gze(s,a.shape,a.dtype,i);return n.makeTensorInfo(o,l,u)}if("int32"===i)return function qUe(e,t){let n=new As(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,n);if("bool"===i){let s=n.makeTensorInfo([],"bool",I.getTypedArrayFromDType("bool",1)),o=z9({inputs:{a,b:s},backend:n});return n.disposeIntermediateTensorInfo(s),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},B9="return ceil(x);",XUe=yt({opSnippet:B9,packedOpSnippet:B9,cpuKernelImpl:qze}),ZUe={kernelName:Fu,backendName:"webgl",kernelFunc:XUe},YUe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},QUe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}},eWe={kernelName:Go,backendName:"webgl",kernelFunc:function JUe(e){let o,{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:i,clipValueMax:s}=r;return o=H().getBool("WEBGL_PACK_CLIP")?new QUe(a.shape):new YUe(a.shape),n.runWebGLProgram(o,[a],a.dtype,[[i],[s]])}},tWe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function V9(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var rWe={kernelName:ay,backendName:"webgl",kernelFunc:function nWe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),i=new tWe(r.shape),s=[V9(r,a.complexTensorInfos.real),V9(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(i,s,s[0].dtype)}},aWe=class{constructor(e){this.outputShape=[],this.outputShape=E.computeOutShape(e,1),this.variableNames=e.map((i,s)=>`T${s}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++)n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${t[i-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},iWe=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=E.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=Ut(r),i=Ur("coords",r),s=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=s[t],u=s.slice(-2),c=s.join(),h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let m=o[f-1];h+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${r1(s,l,m)}),\n            vec2(${r1(u,l,m)}));\n        }`}let p=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${r1(s,l,p)}),\n          vec2(${r1(u,l,p)}));`,this.userCode=`\n      float getValue(${s.map(f=>"int "+f)}) {\n        ${h}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}};function r1(e,t,n){let r=e.indexOf(t);return e.map((a,i)=>i===r?`${a} - ${n}`:a).join()}function a1(e){let{inputs:t,backend:n}=e,{input:r}=t;return Fa({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var sWe={kernelName:h0,backendName:"webgl",kernelFunc:a1};function Tv(e,t,n){let r=e[0].dtype;if("complex64"===r){let p=e.map(v=>Nv({inputs:{input:v},backend:n})),f=e.map(v=>a1({inputs:{input:v},backend:n})),m=Tv(p,t,n),g=Tv(f,t,n),y=Sl({inputs:{real:m,imag:g},backend:n});return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),f.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let p=e.map(w=>{let x=[-1,I.sizeFromShape(w.shape.slice(t))];return me({inputs:{x:w},backend:n,attrs:{shape:x}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=E.computeOutShape(p.map(w=>w.shape),1),y=Kze(f,m,r,1===p[0].shape[0]),v=E.computeOutShape(e.map(w=>w.shape),t),b=n.makeTensorInfo(v,r,y);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),b}let i=e.filter(p=>I.sizeFromShape(p.shape)>0),s=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){let p=s?new As(e[0].shape,xl):new Il(e[0].shape,xl);return n.runWebGLProgram(p,e,r)}let o=H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){let p=[];for(let m=0;m<i.length;m+=o){let g=i.slice(m,m+o);p.push(Tv(g,t,n))}let f=Tv(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(s){let p=new iWe(i.map(f=>f.shape),t);return n.runWebGLProgram(p,i,r)}let{tensors2D:l,outShape:u}=function oWe(e,t,n){let r=E.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>me({inputs:{x:a},attrs:{shape:[-1,I.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}(i,t,n),c=new aWe(l.map(p=>p.shape)),h=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let d=me({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function U9(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=I.parseAxisParam(a,t[0].shape)[0],s=t.map(u=>u.shape);E.assertParamsConsistent(s,i);let o=E.computeOutShape(t.map(u=>u.shape),i);if(0===I.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>I.sizeFromShape(u.shape)>0);return 1===l.length?Fa({inputs:{x:l[0]},backend:n}):Tv(l,i,n)}var lWe={kernelName:dp,backendName:"webgl",kernelFunc:U9},W9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,s=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,v=m?3:1,b="",w="";n&&(b=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");let x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${w}\n        setOutput(result);\n      }\n    `}},uWe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${i}, ${s});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},j9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);let i=e.padInfo.left,s=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){let g=2*m;if(h+=`\n           xC = xCCorner + ${g*o};\n           `,1===s){if(g<u&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n               `,h+=1===o&&g>0?`\n                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);\n                   } else {\n                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xC${g} = xTexelC${g};\n                 `,g+1<u)){let y=i%2==0?I.nearestLargerEven(o):o;o%2==0&&i%2==1||o%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${y};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${g+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${g+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);\n                     } else {\n                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);\n                     }\n                     `:`\n                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);\n                     `):h+=1===y?`\n                     xC${g+1} = xTexelC${g};\n                     `:`\n                     xCOffset = xC + ${y};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${g+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${g+1}Ready = 1;\n                     }\n\n                     xC${g+1} = xTexelC${g+1};\n                     `}}else g<u&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n               `,g+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(\n                   xTexelC${g}.xy, xTexelC${g+1}.xy);\n               `,g+1<u&&(h+=`\n                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n                 `)));g<u&&(h+=`\n             wTexel = getW(r, ${g}, d1, d2);\n             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,g+1<u&&(h+=`\n               wTexel = getW(r, ${g+1}, d1, d2);\n               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}},cWe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let{dataFormat:n}=t,r=Vr(),a="channelsLast"===n,i=a?1:2,s=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`\n          blockIndex = rc.z + ${c};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${s}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+c}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+c}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function i1(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function H9({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:o=null}){let g,l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p="channelsLast"===n.dataFormat,m=!1,y=[];if(null!=i){let v=i1(i.shape,p);null!=v&&(i=me({inputs:{x:i},backend:r,attrs:{shape:v}}),y.push(i))}if(null!=a){let v=i1(a.shape,p);null!=v&&(a=me({inputs:{x:a},backend:r,attrs:{shape:v}}),y.push(a))}if((1!==h&&1!==d||!(c>R9))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&I.arraysEqual(u.shape.slice(-3),l.slice(-3))){let b={dataId:e.dataId,shape:[1,l[0]*l[1]*(l[2]+1),n.inChannels],dtype:e.dtype},w=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,I.assert(_v(u.shape,b.shape),()=>`packed reshape ${u.shape} to ${b.shape} isn't free`);let x=me({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(x);let C=t1({a:b,b:x,backend:r,transposeA:!1,transposeB:m,bias:a,activation:o,preluActivationWeights:i,leakyreluAlpha:s}),k=r.texData.get(C.dataId);I.assert(k.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=w,k.shape=n.outShape,g=Fa({inputs:{x:C},backend:r}),g.shape=n.outShape,y.push(C)}else{let v=n.outHeight*n.outWidth,b=me({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,v,n.inChannels]:[n.batchSize,n.inChannels,v]}}),w=me({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),x=t1({a:p?b:w,b:p?w:b,transposeA:!p,transposeB:m,backend:r,bias:a,activation:o,preluActivationWeights:i,leakyreluAlpha:s});g=me({inputs:{x},backend:r,attrs:{shape:n.outShape}}),y.push(b),y.push(w),y.push(x)}for(let v of y)r.disposeIntermediateTensorInfo(v);return g}function G9({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,y=[n.batchSize,m,g],w=[];if(null!=i){let X=i1(i.shape,f);null!=X&&(i=me({inputs:{x:i},backend:r,attrs:{shape:X}}),w.push(i))}if(null!=a){let X=i1(a.shape,f);null!=X&&(a=me({inputs:{x:a},backend:r,attrs:{shape:X}}),w.push(a))}let x=me({inputs:{x:t},backend:r,attrs:{shape:[1,m,I.sizeFromShape(t.shape)/m]}});w.push(x);let C=new cWe(y,n),T=r.runWebGLProgram(C,[e],"float32",[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]]),A=me({inputs:{x:T},backend:r,attrs:{shape:y}});w.push(T),w.push(A);let R=null!=a,M=null!=i,_="leakyrelu"===o,$=o?Ev(o,!0):null,U=new N9(f?A.shape:x.shape,f?x.shape:A.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,R,$,M,_),j=f?[A,x]:[x,A];if(a&&j.push(a),M&&j.push(i),_){let X=r.makeTensorInfo([],"float32",I.createScalarValue(s,"float32"));j.push(X),w.push(X)}let G=r.runWebGLProgram(U,j,"float32"),K=me({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});w.push(G);for(let X of w)r.disposeIntermediateTensorInfo(X);return K}var Dv,hWe={kernelName:Ou,backendName:"webgl",kernelFunc:function dWe(e){let p,{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,i.shape,s,u,o,c,!1,h);if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&H().getBool("WEBGL_EXP_CONV")){let m=new j9(d);p=n.runWebGLProgram(m,[a,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}else if(H().getBool("WEBGL_CONV_IM2COL"))p=G9({x:a,filter:i,convInfo:d,backend:n});else{let m=new W9(d);p=n.runWebGLProgram(m,[a,i],"float32")}else p=H9({x:a,filter:i,convInfo:d,backend:n});let f=me({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}},pWe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===e.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},fWe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,i="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},mWe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},gWe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},vWe={kernelName:a0,backendName:"webgl",kernelFunc:function yWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,c,s,1,o,u,!1,h),p=new pWe(d);return n.runWebGLProgram(p,[a,i],"float32")}},bWe=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Cr(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}},xWe={kernelName:$u,backendName:"webgl",kernelFunc:function wWe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:s,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=E.convertConv2DDataFormat(u),d=E.computeConv2DInfo(s,i.shape,o,1,l,c,!1,h);if(H().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){let p=[[d.strideHeight,d.strideWidth]],f=new bWe(d);return n.runWebGLProgram(f,[a,i],"float32",p)}{let p=new fWe(d);return n.runWebGLProgram(p,[a,i],"float32")}}},SWe={kernelName:Pu,backendName:"webgl",kernelFunc:function IWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r,u=E.computeConv3DInfo(a.shape,i.shape,s,l,o),c=new uWe(u);return n.runWebGLProgram(c,[a,i],"float32")}},CWe={kernelName:hp,backendName:"webgl",kernelFunc:function _We(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r,u=E.computeConv3DInfo(a.shape,l,s,1,o),c=new mWe(u);return n.runWebGLProgram(c,[a,i],"float32")}},kWe={kernelName:pp,backendName:"webgl",kernelFunc:function EWe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r,u=E.computeConv3DInfo(l,i.shape,o,1,s),c=new gWe(u);return n.runWebGLProgram(c,[a,i],"float32")}},DWe=yt({opSnippet:Kf+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Ed}\n  return result;\n`}),AWe={kernelName:Lu,backendName:"webgl",kernelFunc:DWe},RWe=yt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),FWe={kernelName:zu,backendName:"webgl",kernelFunc:RWe},OWe=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,s,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];let d="bilinear"===r?1:0,[p,f]=[s-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(s-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,b,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},PWe={kernelName:mp,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:s}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new OWe(a.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[a,i,s],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(Dv||(Dv={}));var q9=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=n?this.op===Dv.Prod?"1.0":"0.0":`getX(${K9(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Ut(a)} coords = getOutputCoords();\n        int end = ${X9(a,"coords",this.op)};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${X9(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${K9(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function K9(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function X9(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Z9(e,t,n,r,a,i){let s=t.shape.length,o=E.getAxesPermutation([r],s),l=t;null!=o&&(l=Wr({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=E.getInnerMostAxes(1,s)[0];if(u!==s-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],h=Fa({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){let p=new q9(e,l.shape,!1,i),m=h;h=n.runWebGLProgram(p,[h],h.dtype,[[d]]),n.disposeIntermediateTensorInfo(m)}if(a){let d=new q9(e,l.shape,a,i),p=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(p)}if(null!=o){let p=Wr({inputs:{x:h},backend:n,attrs:{perm:E.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),p}return h}var zWe={kernelName:fp,backendName:"webgl",kernelFunc:function LWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;return Z9(Dv.Prod,a,n,i,s,o)}},VWe={kernelName:Bu,backendName:"webgl",kernelFunc:function BWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r;return Z9(Dv.Sum,a,n,i,s,o)}},WWe={kernelName:iy,backendName:"webgl",kernelFunc:function UWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:s,binaryOutput:o}=r;if(1===a.shape.length){let l=n.readSync(a.dataId),u=n.readSync(i.dataId),c=p9(l,u,i.dtype,i.shape,s);return n.makeTensorInfo([s],i.dtype,c)}if(2===a.shape.length){let l=n.bufferSync(a),u=n.bufferSync(i),c=jze(l,u,s,o);return n.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},jWe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}},GWe={kernelName:gp,backendName:"webgl",kernelFunc:function HWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:s}=r,o=a.shape[0],h=("NHWC"===s?a.shape[1]:a.shape[2])*i,d=("NHWC"===s?a.shape[2]:a.shape[3])*i,p=("NHWC"===s?a.shape[3]:a.shape[1])/(i*i),m=new jWe("NHWC"===s?[o,h,d,p]:[o,p,h,d],i,s);return n.runWebGLProgram(m,[a],a.dtype)}},Y9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);let i=e.filterHeight,s=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},Q9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);let i=e.outChannels/e.inChannels,s=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c,d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)d+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)d+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){let y=2*g;if(d+=`\n          xC = xCCorner + ${y*l};\n          `,1===o){if(y<c&&(s%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n              `,d+=1===l&&y>0?`\n                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                  } else {\n                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                xC${y} = xTexelC${y};\n                `,y+1<c)){let v=s%2==0?I.nearestLargerEven(l):l;l%2==0&&s%2==1||l%2!=0&&s%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${y+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${y+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                    } else {\n                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                    }\n                    `:`\n                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                    `):d+=1===v?`\n                    xC${y+1} = xTexelC${y};\n                    `:`\n                    xCOffset = xC + ${v};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${y+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${y+1}Ready = 1;\n                    }\n\n                    xC${y+1} = xTexelC${y+1};\n                    `}}else y<c&&(s%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${y+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${y+1}Ready = 1;\n                }\n\n                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n              `,y+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                  xTexelC${y} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${y}.zw = vec2(0.0);\n                  }\n                  xTexelC${y}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${y+1}.zw = vec2(0.);\n                  }\n                  xTexelC${y+1}Ready = 1;\n                }\n\n                xC${y} = vec4(\n                  xTexelC${y}.xy, xTexelC${y+1}.xy);\n              `,y+1<c&&(d+=`\n                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                `)));y<c&&(d+=`\n            wTexel = getW(r, ${y}, d1, q);\n            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);\n          `,y+1<c&&(d+=`\n              wTexel = getW(r, ${y+1}, d1, q);\n              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}},KWe={kernelName:Vu,backendName:"webgl",kernelFunc:function qWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;null==c&&(c=[1,1]),I.assert(E.eitherStridesOrDilationsAreOne(s,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);let d,h=E.computeConv2DInfo(a.shape,i.shape,s,c,o,u,!0);return d=H().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new Q9(h):new Y9(h),n.runWebGLProgram(d,[a,i],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}},XWe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},ZWe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},QWe={kernelName:s0,backendName:"webgl",kernelFunc:function YWe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=E.computeConv2DInfo(a.shape,c,s,o,l,u,!0),d=new XWe(h);return n.runWebGLProgram(d,[a,i],"float32")}},e4e={kernelName:o0,backendName:"webgl",kernelFunc:function JWe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:s,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=E.computeConv2DInfo(c,i.shape,s,o,l,u,!0),d=new ZWe(h);return n.runWebGLProgram(d,[a,i],"float32")}},t4e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}},r4e={kernelName:sy,backendName:"webgl",kernelFunc:function n4e(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],i=I.sizeFromShape(r.shape),s=me({inputs:{x:r},backend:n,attrs:{shape:[i]}}),o=new t4e(i),l=n.runWebGLProgram(o,[s],s.dtype),u=me({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),u}},a4e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:s,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}},s4e={kernelName:Uu,backendName:"webgl",kernelFunc:function i4e(e){let c,{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r,u=E.computeDilation2DInfo(a.shape,i.shape,s,o,"NHWC",l),h=new a4e(u);c=n.runWebGLProgram(h,[a,i],"float32");let d=me({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},l4e={kernelName:u0,backendName:"webgl",kernelFunc:function o4e(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:s,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,i.length);E.checkEinsumDimSizes(s.length,l,i);let{path:u,steps:c}=E.getEinsumComputePath(o,l),h=c.length,d=null,p=s.length,f=[];for(let m=0;m<h;++m){for(let g of c[m]){let b,{permutationIndices:y,expandDims:v}=E.getEinsumPermutation(p,l[g]);E.isIdentityPermutation(y)?b=i[g]:(b=Wr({inputs:{x:i[g]},backend:n,attrs:{perm:y}}),f.push(b));let w=b.shape.slice();for(let x=0;x<v.length;++x)w.splice(v[x],0,1);I.arraysEqual(b.shape,w)||(b=me({inputs:{x:b},backend:n,attrs:{shape:w}}),f.push(b)),null===d?d=b:(d=LM({inputs:{a:b,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=e1({inputs:{x:d},backend:n,attrs:{axis:u[m]-(s.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},d4e=yt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),h4e={kernelName:ju,backendName:"webgl",kernelFunc:d4e},g4e={kernelName:bp,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=H().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qf("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new Cd("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(i,[r,a],r.dtype)}},b4e=mr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Xze}),w4e={kernelName:wp,backendName:"webgl",kernelFunc:b4e},I4e=yt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${E.ERF_P};\n  float a1 = ${E.ERF_A1};\n  float a2 = ${E.ERF_A2};\n  float a3 = ${E.ERF_A3};\n  float a4 = ${E.ERF_A4};\n  float a5 = ${E.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),S4e={kernelName:Hu,backendName:"webgl",kernelFunc:I4e},J9=yt({opSnippet:Kf+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Zze,dtype:"float32"}),E4e={kernelName:Gu,backendName:"webgl",kernelFunc:J9};function UM(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:i}=t,s=i.shape.length,o=i.shape.slice(),l=a;return a<0&&(I.assert(-(s+1)<=a,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),l=s+a+1),o.splice(l,0,1),me({inputs:{x:i},backend:r,attrs:{shape:o}})}var k4e={kernelName:xp,backendName:"webgl",kernelFunc:UM},eX="return exp(x) - 1.0;",N4e=yt({opSnippet:eX,packedOpSnippet:eX,cpuKernelImpl:Yze}),T4e={kernelName:qu,backendName:"webgl",kernelFunc:N4e},tX=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s,a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);s="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${s}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function nX(e,t,n){let r=n.texData.get(e.dataId),a=I.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=me({inputs:{x:e},backend:n,attrs:{shape:[a/i,i]}}),l=o.shape,u=new tX("real",l,t),c=new tX("imag",l,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,h,"float32"),p=n.runWebGLProgram(c,h,"float32"),f=Sl({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);let m=me({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}var A4e={kernelName:c0,backendName:"webgl",kernelFunc:function D4e(e){let{inputs:t,backend:n}=e,{input:r}=t;return nX(r,!1,n)}},M4e=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function Av(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:i}=n;if(i=i||I.inferDtype(a),"string"===i){let s=I.getArrayFromDType(i,I.sizeFromShape(r));return s.fill(a),t.makeTensorInfo(r,i,s)}{let s=new M4e(r,a);return t.runWebGLProgram(s,[],i,[[a]])}}var Zf,R4e={kernelName:oy,backendName:"webgl",kernelFunc:Av},F4e=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},O4e={kernelName:Ip,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new F4e(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},rX="return floor(x);",$4e=yt({opSnippet:rX,packedOpSnippet:rX,cpuKernelImpl:Qze}),P4e={kernelName:Ku,backendName:"webgl",kernelFunc:$4e},B4e=mr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),V4e={kernelName:Xu,backendName:"webgl",kernelFunc:B4e},U4e=class{constructor(e){this.variableNames=["A"];let t=Vr(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},W4e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Vr(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},j4e={kernelName:y0,backendName:"webgl",kernelFunc:function H4e(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:i}=r,s=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[l,u]=s?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],h=[u,l,i];if(o||s){let m=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Zf||m!==WM)&&(WM=m,Zf=document.createElement("canvas").getContext("2d",{willReadFrequently:WM})),Zf.canvas.width=l,Zf.canvas.height=u,Zf.drawImage(a,0,0,l,u),a=Zf.canvas}let d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=Qa.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let p=H().getBool("WEBGL_PACK")?new W4e(h):new U4e(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}},WM=H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),q4e={kernelName:Uc,backendName:"webgl",kernelFunc:function G4e(e){let y,{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=E.convertConv2DDataFormat(c),g=E.computeConv2DInfo(a.shape,i.shape,l,h,u,d,!1,m),v=[],b=null!=s,w=null!=o,x="leakyrelu"===p,C=()=>{let T=[a,i],A=(R,M)=>{if("NCHW"===M&&1===R.shape.length&&1!==R.shape[0]){let _=me({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return v.push(_),_}return R};if(b&&T.push(A(s,c)),w&&T.push(A(o,c)),x){let R=n.makeTensorInfo([],"float32",I.createScalarValue(f,"float32"));T.push(R),v.push(R)}return T};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&H().getBool("WEBGL_EXP_CONV")){let T=p?Ev(p,!0):null,A=new j9(g,b,T,w,x),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=C();y=n.runWebGLProgram(A,M,"float32",R)}else if(H().getBool("WEBGL_CONV_IM2COL"))y=G9({x:a,filter:i,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let T=p?Ev(p,!1):null,A=new W9(g,b,T,w,x),R=C();y=n.runWebGLProgram(A,R,"float32")}else y=H9({x:a,filter:i,convInfo:g,backend:n,bias:s,activation:p,preluActivationWeights:o,leakyreluAlpha:f});let k=me({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return v.push(y),v.forEach(T=>n.disposeIntermediateTensorInfo(T)),k}},X4e={kernelName:Wc,backendName:"webgl",kernelFunc:function K4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[],m=c;null==m&&(m=[1,1]),I.assert(E.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let k,g=E.computeConv2DInfo(a.shape,i.shape,l,m,u,h,!0),y=H().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,v=d?Ev(d,y):null,b=[a,i],w=null!=s,x=null!=o,C="leakyrelu"===d;if(w&&b.push(s),x&&b.push(o),C){let R=n.makeTensorInfo([],"float32",I.createScalarValue(p,"float32"));b.push(R),f.push(R)}k=y?new Q9(g,w,v,x,C):new Y9(g,w,v,x,C);let A=n.runWebGLProgram(k,b,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),A}},Z4e=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=Ut(n.length),i="\n    int index;";for(let s=0;s<this.sliceDim;s++)i+=`\n          index = round(getIndices(coords[0], ${s}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[s]};\n          flattenIndex += index * ${this.strides[s]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}},Q4e={kernelName:_p,backendName:"webgl",kernelFunc:function Y4e(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=a.shape,s=i[i.length-1],o=I.sizeFromShape(r.shape),[l,u,c,h]=E.prepareAndValidate(r,a),d=me({inputs:{x:a},backend:n,attrs:{shape:[u,s]}}),p=me({inputs:{x:r},backend:n,attrs:{shape:[I.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let y=n.readSync(a.dataId),v=n.bufferSync(r),b=Jze(y,v,r.dtype,u,s,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,b.values)}let f=new Z4e(s,h,[u,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=me({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}},J4e=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Ut(this.rank),r=function eje(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)r.push(2===a?"index":`${n[a]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function aX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:s,batchDims:o}=r,l=I.parseAxisParam(s,a.shape)[0];if(H().get("DEBUG")){let v=n.readSync(i.dataId),b=a.shape[l];for(let w=0;w<v.length;++w){let x=v[w];I.assert(x<=b-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${b-1}]`)}}let u=E.segment_util.collectGatherOpShapeInfo(a,i,l,o),c=I.sizeFromShape(i.shape),h=[],d=me({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=me({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,i])||"string"===a.dtype){let v=n.bufferSync(p),b=n.bufferSync(d),w=eBe(b,v,f);return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(u.outputShape,w.dtype,w.values)}let m=new J4e(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);let y=me({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),y}var tje={kernelName:Sp,backendName:"webgl",kernelFunc:aX},aje=mr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:tBe,dtype:"bool"}),ije={kernelName:Cp,backendName:"webgl",kernelFunc:aje},lje=mr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:nBe}),uje={kernelName:Yu,backendName:"webgl",kernelFunc:lje},dje={kernelName:d0,backendName:"webgl",kernelFunc:function cje(e){let{inputs:t,backend:n}=e,{input:r}=t;return nX(r,!0,n)}},pje=yt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),fje={kernelName:Ju,backendName:"webgl",kernelFunc:pje},gje=yt({opSnippet:"return float(isinf(x));",dtype:"bool"}),yje={kernelName:ec,backendName:"webgl",kernelFunc:gje},bje=yt({opSnippet:"return float(isnan(x));",dtype:"bool"}),wje={kernelName:tc,backendName:"webgl",kernelFunc:bje},Sje=mr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:rBe,dtype:"bool"}),_je={kernelName:Ep,backendName:"webgl",kernelFunc:Sje},kje=mr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:aBe,dtype:"bool"}),Nje={kernelName:kp,backendName:"webgl",kernelFunc:kje},Dje={kernelName:Np,backendName:"webgl",kernelFunc:function Tje(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,s=iBe(r,a,i);return t.makeTensorInfo([s.length],"float32",s)}},Rje=yt({opSnippet:Kf+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:sBe}),Fje={kernelName:rc,backendName:"webgl",kernelFunc:Rje},$je=yt({opSnippet:Kf+"\n  return log(1.0 + x);\n"}),Pje={kernelName:ac,backendName:"webgl",kernelFunc:$je},Bje=mr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Vje={kernelName:Tp,backendName:"webgl",kernelFunc:Bje},Wje=yt({opSnippet:"return float(!(x >= 1.0));"}),jje={kernelName:Dp,backendName:"webgl",kernelFunc:Wje},qje=mr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Kje={kernelName:Ap,backendName:"webgl",kernelFunc:qje},Xje=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let i=t,s=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},Zje=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,s=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},Qje={kernelName:ic,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r,u=H().getBool("WEBGL_PACK_NORMALIZATION")?new Zje(a.shape,i,s,o,l):new Xje(a.shape,i,s,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},Jje=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},tHe={kernelName:Mp,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new Jje(a.shape,o,l,u,c);return n.runWebGLProgram(h,[a,i,s],a.dtype)}};function iX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:s}=r,o=a.shape.length,l=I.parseAxisParam(i,a.shape),u=l,c=E.getAxesPermutation(u,o),h=null!=c,d=n.shouldExecuteOnCPU([a]),p=a;if(h){if(d){let v=n.texData.get(p.dataId).values,b=new Array(o);for(let C=0;C<b.length;C++)b[C]=a.shape[c[C]];let w=OM(v,a.shape,a.dtype,c,b);p=n.makeTensorInfo(b,a.dtype),n.texData.get(p.dataId).values=w}else p=JI(a,c,n);u=E.getInnerMostAxes(u.length,o)}E.assertAxesAreInnerMostDims("max",u,o);let y,[f,m]=E.computeOutAndReduceShapes(p.shape,u),g=f;if(s&&(g=E.expandShapeToKeepDim(f,l)),d){let v=n.texData.get(p.dataId).values,b=oBe(v,I.sizeFromShape(m),g,a.dtype);y=n.makeTensorInfo(g,a.dtype),n.texData.get(y.dataId).values=b}else y=function nHe(e,t,n,r){let a=I.sizeFromShape(t),s=me({inputs:{x:e},attrs:{shape:[I.sizeFromShape(e.shape)/a,a]},backend:r}),o=kd(s,e.dtype,"max",r),l=me({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),l}(p,m,g,n);return h&&n.disposeIntermediateTensorInfo(p),y}var rHe={kernelName:sc,backendName:"webgl",kernelFunc:iX},sHe=mr({opSnippet:PM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Ed+"\n  return result;\n",cpuKernelImpl:lBe}),oHe={kernelName:oc,backendName:"webgl",kernelFunc:sHe},uHe={kernelName:lc,backendName:"webgl",kernelFunc:function lHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Uf(a,"maxPool");let{filterSize:i,strides:s,pad:o,dimRoundingMode:l}=r;I.assert(E.eitherStridesOrDilationsAreOne(s,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let c=E.computePool2DInfo(a.shape,i,s,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&I.arraysEqual(c.inShape,c.outShape))return Fa({inputs:{x:a},backend:n});let h=new kv(c,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}},dHe={kernelName:Rp,backendName:"webgl",kernelFunc:function cHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dataFormat:l,dimRoundingMode:u}=r,h=E.computePool3DInfo(a.shape,i,s,[1,1,1],o,u,l),d=new zM(h,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},hHe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let a=e.effectiveFilterHeight,i=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${a-1-e.padInfo.top}, ${i-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},pHe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${o-1-e.padInfo.front}, ${l-1-e.padInfo.top}, ${u-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${o*l*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},mHe={kernelName:uy,backendName:"webgl",kernelFunc:function fHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,s=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=E.computePool3DInfo(s.shape,o,l,[1,1,1],u,c),p=new zM(d,"max",!0),f=n.runWebGLProgram(p,[s],s.dtype),m=new pHe(d),g=n.runWebGLProgram(m,[a,f],s.dtype);return n.disposeIntermediateTensorInfo(f),g}},yHe={kernelName:ly,backendName:"webgl",kernelFunc:function gHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:s}=t,o=i;Uf([i,s],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=E.computePool2DInfo(o.shape,l,u,1,c,h),f=new kv(d,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),g=new hHe(d),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}},bHe={kernelName:cy,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:i,pad:s,includeBatchInIndex:o}=t,l=n;I.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];I.assert(E.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=E.computePool2DInfo(r.shape,a,i,u,s),[h,d]=function vHe(e,t,n,r){let a=new kv(n,"max",!1),i=r.runWebGLProgram(a,[e],"float32");return a=new kv(n,"max",!0,!0,t),[i,r.runWebGLProgram(a,[e],"float32")]}(r,o,c,l);return[h,d]}},xHe={kernelName:uc,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:i}=t,s=n,o=r.shape.length,l=I.parseAxisParam(i,r.shape),u=l,c=E.getAxesPermutation(u,o),h=null!=c,d=s.shouldExecuteOnCPU([r]),p=[],f=r;if(h){if(d){let b=s.texData.get(f.dataId).values,w=new Array(o);for(let k=0;k<w.length;k++)w[k]=r.shape[c[k]];let x=OM(b,r.shape,r.dtype,c,w);f=s.makeTensorInfo(w,r.dtype),s.texData.get(f.dataId).values=x}else f=JI(r,c,s);p.push(f),u=E.getInnerMostAxes(u.length,o)}E.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=E.computeOutAndReduceShapes(f.shape,u),y=m;a&&(y=E.expandShapeToKeepDim(m,l));let v=function wHe(e,t,n,r){let a=I.sizeFromShape(t),s=me({inputs:{x:e},attrs:{shape:[I.sizeFromShape(e.shape)/a,a]},backend:r}),o=kd(s,"float32","mean",r),l=me({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),l}(f,g,y,s);for(let b of p)s.disposeIntermediateTensorInfo(b);return v}},SHe={kernelName:cc,backendName:"webgl",kernelFunc:function IHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=I.parseAxisParam(i,a.shape),u=l,c=E.getAxesPermutation(u,o),h=a;null!=c&&(h=Wr({inputs:{x:a},backend:n,attrs:{perm:c}}),u=E.getInnerMostAxes(u.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",u,o);let y,[d,p]=E.computeOutAndReduceShapes(h.shape,u),m=me({inputs:{x:h},backend:n,attrs:{shape:[-1,I.sizeFromShape(p)]}}),g=kd(m,m.dtype,"min",n);return y=me(s?{inputs:{x:g},backend:n,attrs:{shape:E.expandShapeToKeepDim(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}},EHe=mr({opSnippet:PM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Ed+"\n  return result;\n",cpuKernelImpl:uBe}),kHe={kernelName:dc,backendName:"webgl",kernelFunc:EHe},NHe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,a=Ut(r),i=t.map(u=>u[0]).join(","),s=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},THe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let r=e.length,a=Ut(r),i=t.map(p=>p[0]).join(","),s=t.map((p,f)=>p[0]+e[f]).join(","),o=Ur("rc",r),l=Ur("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1,d="";if(1===r){let p=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{let p=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${p}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}},AHe={kernelName:hc,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:i}=n,s=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new THe(r.shape,a,i):new NHe(r.shape,a,i);return t.runWebGLProgram(s,[r],r.dtype)}},FHe=mr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Ed+"\n  return result;\n"}),OHe={kernelName:pc,backendName:"webgl",kernelFunc:FHe},$He=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},sX=mr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),zHe={kernelName:Wu,backendName:"webgl",kernelFunc:sX},oX="return a - b;",lX=mr({opSnippet:oX,packedOpSnippet:oX,supportsComplex:!0,cpuKernelImpl:DBe}),BHe={kernelName:Lc,backendName:"webgl",kernelFunc:lX};function uX(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,s=I.parseAxisParam([i],a.shape),o=iX({inputs:{x:a},backend:n,attrs:{reductionIndices:s,keepDims:!1}}),l=E.expandShapeToKeepDim(o.shape,s),u=me({inputs:{x:o},backend:n,attrs:{shape:l}}),c=lX({inputs:{a,b:u},backend:n}),h=J9({inputs:{x:c},backend:n}),d=e1({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:!1}}),p=me({inputs:{x:d},backend:n,attrs:{shape:l}}),f=sX({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}var VHe={kernelName:$c,backendName:"webgl",kernelFunc:uX},WHe={kernelName:Fp,backendName:"webgl",kernelFunc:function UHe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r,l=o?a:uX({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),h=new $He(l.shape[0],l.shape[1],i),p=n.runWebGLProgram(h,[l],"int32",[[s]]);return o||n.disposeIntermediateTensorInfo(l),p}},jHe=xi+"\n  return -x;\n",qHe={kernelName:Op,backendName:"webgl",kernelFunc:function GHe(e){let a,{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId),[s,o]=dBe(i.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}return a=H().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Il(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new As(r.shape,jHe),n.runWebGLProgram(a,[r],r.dtype)}},KHe=_s.nonMaxSuppressionV3Impl,ZHe={kernelName:Pp,backendName:"webgl",kernelFunc:function XHe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=KHe(u,c,s,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},YHe=_s.nonMaxSuppressionV4Impl,JHe={kernelName:Lp,backendName:"webgl",kernelFunc:function QHe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=YHe(c,h,s,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},eGe=_s.nonMaxSuppressionV5Impl,nGe={kernelName:zp,backendName:"webgl",kernelFunc:function tGe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=s,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=eGe(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},rGe=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},iGe={kernelName:mc,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r,u=I.sizeFromShape(a.shape),c=new rGe(u,s,o,l),h=me({inputs:{x:a},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],i);n.disposeIntermediateTensorInfo(h);let f=me({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,s]}});return n.disposeIntermediateTensorInfo(d),f}};function s1(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let a=Nv({inputs:{input:r},backend:n}),i=s1({inputs:{x:a},backend:n}),s=a1({inputs:{input:r},backend:n}),o=s1({inputs:{x:s},backend:n}),l=Sl({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}return Av({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var sGe={kernelName:af,backendName:"webgl",kernelFunc:s1},oGe={kernelName:Bp,backendName:"webgl",kernelFunc:function cX(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){let a=Nv({inputs:{input:r},backend:n}),i=cX({inputs:{x:a},backend:n}),s=a1({inputs:{input:r},backend:n}),o=s1({inputs:{x:s},backend:n}),l=Sl({inputs:{real:i,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),l}return Av({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}},uGe={kernelName:Vp,backendName:"webgl",kernelFunc:function lGe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return UM({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{I.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),I.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=U9({inputs:t.map(c=>{let h=UM({inputs:{input:c},backend:n,attrs:{dim:a}});return o.push(h),h}),backend:n,attrs:{axis:a}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}},cGe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,a=Ut(r),i=t.map(l=>l[0]).join(","),s=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},dGe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,a=Ut(r),i=t.map(f=>f[0]).join(","),s=t.map((f,m)=>f[0]+e[m]).join(","),o=Ur("rc",r),l=Ur("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${s});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},dX=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:s}=r;if(0===I.sizeFromShape(a.shape))return Av({backend:n,attrs:{shape:i.map((c,h)=>c[0]+a.shape[h]+c[1]),value:s,dtype:a.dtype}});let o=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dGe(a.shape,i,s):new cGe(a.shape,i,s);return n.runWebGLProgram(o,[a],a.dtype,[[s]])},hGe={kernelName:gc,backendName:"webgl",kernelFunc:dX},mGe=mr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Ed+"\n  return result;\n"}),gGe={kernelName:yc,backendName:"webgl",kernelFunc:mGe},vGe={kernelName:bc,backendName:"webgl",kernelFunc:function yGe(e){let p,{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:s}=r,o=a.shape.length,l=[],u=I.parseAxisParam(i,a.shape),c=u,h=E.getAxesPermutation(c,o),d=a;if(null!=h&&(d=Wr({inputs:{x:a},backend:n,attrs:{perm:h}}),c=E.getInnerMostAxes(c.length,o),l.push(d)),E.assertAxesAreInnerMostDims("prod",c,o),n.shouldExecuteOnCPU([d])){let f=n.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=pBe(d.shape,d.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{let[f,m]=E.computeOutAndReduceShapes(d.shape,c),g=I.sizeFromShape(m),y=me({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),b=kd(y,S0(a.dtype),"prod",n);p=me({inputs:{x:b},backend:n,attrs:{shape:f}}),l.push(y),l.push(b)}if(s){l.push(p);let f=E.expandShapeToKeepDim(p.shape,u);p=me({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}},wGe={kernelName:p0,backendName:"webgl",kernelFunc:function bGe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:s}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.readSync(y.dataId)),u=a.map(y=>y.shape),c=n.readSync(i.dataId),h=n.readSync(s.dataId),[d,p,f]=fBe(l,u,c,i.shape,i.dtype,h,s.shape,o),m=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,i.dtype,p);return m.concat([g])}},IGe={kernelName:f0,backendName:"webgl",kernelFunc:function xGe(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,c]=mBe(s,r.shape,r.dtype,o,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},_Ge={kernelName:m0,backendName:"webgl",kernelFunc:function SGe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:s,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(i.dataId),h=n.readSync(s.dataId),d=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=gBe(u,a.shape,c,i.shape,i.dtype,h,s.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,m)}},hX=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:s}=n,o=yBe(r,a,i,s);return t.makeTensorInfo([o.length],s,o)},CGe={kernelName:dy,backendName:"webgl",kernelFunc:hX},kGe=yt({opSnippet:"return 1.0 / x;"}),NGe={kernelName:wc,backendName:"webgl",kernelFunc:kGe},AGe=yt({opSnippet:xi+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),MGe={kernelName:xc,backendName:"webgl",kernelFunc:AGe},OGe=yt({opSnippet:xi+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),$Ge={kernelName:_c,backendName:"webgl",kernelFunc:OGe},PGe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let h,u=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},LGe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let h,u=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}},BGe={kernelName:Sc,backendName:"webgl",kernelFunc:function zGe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new LGe(a.shape,l,u,i,s):new PGe(a.shape,l,u,i,s);return n.runWebGLProgram(c,[a],"float32")}},VGe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,s]=e,o=[n&&i>1?r-1:r,n&&s>1?a-1:a],l=[n&&i>1?i-1:i,n&&s>1?s-1:s],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}},WGe={kernelName:jp,backendName:"webgl",kernelFunc:function UGe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=new VGe(i.shape,a.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}},jGe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let d,u=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];d=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},HGe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,s,o,l]=e;this.outputShape=[i,t,n,l];let d,u=[r&&t>1?s-1:s,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];d=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}},qGe={kernelName:Ic,backendName:"webgl",kernelFunc:function GGe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,c=H().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HGe(a.shape,l,u,i,s):new jGe(a.shape,l,u,i,s);return n.runWebGLProgram(c,[a],a.dtype)}},KGe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,s]=e,o=[n&&i>1?r-1:r,n&&s>1?a-1:a],l=[n&&i>1?i-1:i,n&&s>1?s-1:s],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}},ZGe={kernelName:Wp,backendName:"webgl",kernelFunc:function XGe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=new KGe(i.shape,a.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}},YGe=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let a=e.map((s,o)=>(s=>-1!==t.indexOf(s)&&1!==e[s]?`${e[s]} - coords[${s}] - 1`:`coords[${s}]`)(o)).join(","),i=Ut(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}},QGe=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Ur("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,s=Ut(n);function h(p){let f=e.map((y,v)=>function d(p,f){return-1!==t.indexOf(p)&&1!==e[p]?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}(v,p));return`getChannel(getX(${f.join(",")}), vec2(${f.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function o(p){return h(p)}(r.slice())};\n          if(${a}){\n            result.g = ${function l(p){return p[n-1]="("+p[n-1]+" + 1)",h(p)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function u(p){return p[n-2]="("+p[n-2]+" + 1)",h(p)}(r.slice())};\n            if(${a}) {\n              result.a = ${function c(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",h(p)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}},e6e={kernelName:Cc,backendName:"webgl",kernelFunc:function JGe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,s=a.shape.length,o=I.parseAxisParam(i,a.shape);if(0===s)return Fa({inputs:{x:a},backend:n});let l=H().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QGe(a.shape,o):new YGe(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},t6e=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},n6e={kernelName:sf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:i,center:s}=t,o=n,l=new t6e(r.shape,i),[u,c]=E.getImageCenter(s,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},a6e=yt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),i6e={kernelName:Ec,backendName:"webgl",kernelFunc:a6e},o6e=yt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:vBe}),l6e={kernelName:kc,backendName:"webgl",kernelFunc:o6e},jM=class{constructor(e,t,n,r,a,i,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=Ut(a.length),u=Ut(i.length),c="";1===n?c="i":2===n&&(c="i, j");let d="";1===r?d="i":2===r&&(d="i, coords[1]");let f="";o&&(f="coords[0], coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${c}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${d});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${f}), sum, float(found)));\n        }\n      `}},u6e=class{constructor(e,t,n,r,a,i,s=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let l=Ut(a.length),u=Ut(i.length),c="";1===n?c="i":2===n&&(c="i, j");let d="";1===r?d="i":2===r&&(d="i, coords[1]");let f="";o&&(f="coords[0], coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(getIndices(${c}));\n              flattenedIndex += index.xz * ${t>1?"strides[j]":"strides"};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${t>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${d});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${f}), sum, found));\n        }\n      `}},d6e={kernelName:Hp,backendName:"webgl",kernelFunc:function c6e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:s}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=E.calculateShapes(i,a,s),d=[h/u,u];if(0===h)return n.makeTensorInfo(s,a.dtype);let g,p=me({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=me({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));g=H().getBool("WEBGL_PACK")?new u6e(l,o,p.shape.length,f.shape.length,c,d):new jM(l,o,p.shape.length,f.shape.length,c,d);let y=n.runWebGLProgram(g,[f,p,m],f.dtype),v=me({inputs:{x:y},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),v}},h6e=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===H().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}},f6e={kernelName:qp,backendName:"webgl",kernelFunc:function p6e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r,o=new h6e(a.shape[0],a.shape[1],i.shape[1],s);return n.runWebGLProgram(o,[a,i],"int32",[[a.shape[1]]])}},m6e=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${s[u]}`),u<e&&o.push(`${s[u]}`);r=o.join(),a=l.join()}let i=Ut(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}},y6e={kernelName:Kp,backendName:"webgl",kernelFunc:function g6e(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,s=new m6e(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(s,[r,a,i],Ga(a.dtype,i.dtype))}},b6e=yt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${E.SELU_SCALEALPHA};\n  float scale = ${E.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),w6e={kernelName:Nc,backendName:"webgl",kernelFunc:b6e},S6e=yt({opSnippet:Kf+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:wBe}),_6e={kernelName:Mc,backendName:"webgl",kernelFunc:S6e},E6e=yt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),k6e={kernelName:Ac,backendName:"webgl",kernelFunc:E6e},D6e=yt({opSnippet:Kf+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Ed}\n  return result;\n`}),A6e={kernelName:Tc,backendName:"webgl",kernelFunc:D6e},R6e=yt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),F6e={kernelName:Dc,backendName:"webgl",kernelFunc:R6e},$6e=yt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),P6e={kernelName:Rc,backendName:"webgl",kernelFunc:$6e},z6e={kernelName:Zp,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r;I.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=i.reduce((y,v)=>y*v),l=[[0,0]];l.push(...s);for(let y=1+i.length;y<a.shape.length;++y)l.push([0,0]);let u=[],c=dX({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=E.getReshaped(c.shape,i,o,!1),d=E.getPermuted(h.length,i.length,!1),p=E.getReshapedPermuted(c.shape,i,o,!1),f=me({inputs:{x:c},backend:n,attrs:{shape:h}}),m=Wr({inputs:{x:f},backend:n,attrs:{perm:d}}),g=me({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}},V6e={kernelName:hy,backendName:"webgl",kernelFunc:function B6e(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:s}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(i.dataId),c=n.readSync(s.dataId)[0],[h,d,p,f,m]=IBe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},W6e={kernelName:Qp,backendName:"webgl",kernelFunc:function U6e(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=SBe(o,r.shape,r.dtype,s,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},H6e={kernelName:py,backendName:"webgl",kernelFunc:function j6e(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);let s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,c]=m9(s,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},q6e={kernelName:fy,backendName:"webgl",kernelFunc:function G6e(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);let s=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,c]=m9(s,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},X6e={kernelName:Jp,backendName:"webgl",kernelFunc:function K6e(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=E.calculateShapes(i,a,o),p=!1;if("string"===i.dtype){let y=n.bufferSync(a),v=n.bufferSync(i),b=I.decodeString(n.readSync(s.dataId)[0]),w=bBe(y,v,o,d,c,u,l,h,b,p);return n.makeTensorInfo(o,w.dtype,w.values)}let f=new jM(u,l,a.shape.length,i.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[i,a,s],i.dtype),g=me({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}},Y6e={kernelName:Yp,backendName:"webgl",kernelFunc:function Z6e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=r,o=I.parseAxisParam(s,a.shape)[0],l=E.prepareSplitSize(a,i,o),c=new Array(a.shape.length).fill(0),h=a.shape.slice();return l.map(d=>{let p=[...h];p[o]=d;let f=Xf({inputs:{x:a},backend:n,attrs:{begin:c,size:p}});return c[o]+=d,f})}},pX="return sqrt(x);",Q6e=yt({opSnippet:pX,packedOpSnippet:pX,cpuKernelImpl:_Be}),J6e={kernelName:Fc,backendName:"webgl",kernelFunc:Q6e},t5e=yt({opSnippet:"return x * x;"}),n5e={kernelName:my,backendName:"webgl",kernelFunc:t5e},fX="return (a - b) * (a - b);",r5e=mr({opSnippet:fX,packedOpSnippet:fX}),a5e={kernelName:Pc,backendName:"webgl",kernelFunc:r5e},s5e={kernelName:gy,backendName:"webgl",kernelFunc:function i5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let i=n.readSync(a.dataId),s=E.fromUint8ToStringArray(i),o=CBe(s,"string",r);return n.makeTensorInfo(a.shape,"string",o)}},l5e={kernelName:Ko,backendName:"webgl",kernelFunc:function o5e({inputs:e,attrs:t,backend:n}){let{x:r}=e,i=new As(r.shape,xi+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(i,[r],r.dtype)}},u5e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=Ut(n.length),i=Ut(n.length),s="";if(1===r)s="coords * strides + begin";else{let o=0;s=n.map((l,u)=>(o++,1===n.length?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}},d5e={kernelName:ef,backendName:"webgl",kernelFunc:function c5e(e){let x,{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,end:s,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:b,strides:w}=Vn.sliceInfo(a.shape,i,s,o,l,u,c,h,d);if(m)x=me({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){I.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let k=Vn.computeOutShape(v,b,w),T=Xf({inputs:{x:a},backend:n,attrs:{begin:v,size:k}});x=me({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([a])){let k=n.readSync(a.dataId),T=Je(a.shape,a.dtype,k),A=EBe(p,T,w,v);x=n.makeTensorInfo(f,a.dtype,A.values)}else{let k=new u5e(v,w,p);x=n.runWebGLProgram(k,[a],a.dtype)}let C=me({inputs:{x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),C}},p5e={kernelName:yy,backendName:"webgl",kernelFunc:function h5e(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:s,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=kBe(d,p,a,i,s,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},m5e={kernelName:vy,backendName:"webgl",kernelFunc:function f5e(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:s}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);let o=n.readSync(i.dataId),l=n.readSync(s.dataId)[0],[u,c,h]=NBe(o,l,a),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},y5e={kernelName:by,backendName:"webgl",kernelFunc:function g5e(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let s=n.readSync(i.dataId),o=TBe(s,a);return n.makeTensorInfo(i.shape,"int32",o)}},b5e=yt({opSnippet:"return tan(x);"}),w5e={kernelName:zc,backendName:"webgl",kernelFunc:b5e},I5e=yt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),S5e={kernelName:Bc,backendName:"webgl",kernelFunc:I5e},C5e={kernelName:Gp,backendName:"webgl",kernelFunc:function _5e(e){let{inputs:t,backend:n}=e,{tensor:a,indices:i,updates:s}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=E.calculateShapes(s,i,a.shape),d=[h/u,u];if(0===h)return n.makeTensorInfo(a.shape,i.dtype);let p=me({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=me({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=me({inputs:{x:a},backend:n,attrs:{shape:d}}),g=new jM(l,o,p.shape.length,f.shape.length,c,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),v=me({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}},E5e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let r=Ut(this.rank),a=function k5e(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function mX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;if("string"===a.dtype||a.shape.length>5){let o=n.readSync(a.dataId),l="string"===a.dtype?o.map(h=>I.decodeString(h)):o,u=Je(a.shape,a.dtype,l),c=ABe(u,i);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let s=new E5e(a.shape,i);return n.runWebGLProgram(s,[a],a.dtype)}var N5e={kernelName:qo,backendName:"webgl",kernelFunc:mX},T5e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},D5e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function Nd(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function gX(e){let t=1;for(;t<e;)t*=2;return t}var wt,Mv,yX,M5e={kernelName:tf,backendName:"webgl",kernelFunc:function A5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:s}=r,o=H().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=H().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||i>l){let A=n.readSync(a.dataId),[R,M]=MBe(A,u,a.dtype,i,s);return[n.makeTensorInfo(R.shape,R.dtype,R.values),n.makeTensorInfo(M.shape,M.dtype,M.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,Av({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let h=n.texData.get(a.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(a):a,f=I.sizeFromShape(u)/c,m=me({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&Nd(n,p);let g=gX(i),y=gX(c),v=null,b=()=>null===v?[m,m]:[m,v],w=(A,R,M)=>{let _=b(),$=new T5e(M),j=v;v=n.runWebGLProgram($,_,"int32",[[c],[null===v?1:0],[Number.NEGATIVE_INFINITY],[A],[R]]),Nd(n,j)};for(let A=1;A<g;A*=2){let R=2*A;for(let M=A;M>=1;M/=2)w(R,M,[f,y])}for(let A=y;A>g;A/=2){let R=b(),M=new D5e([f,A/2]),$=v;v=n.runWebGLProgram(M,R,"int32",[[c],[null===v?1:0],[g]]),Nd(n,$);let U=g/2,j=2*U;for(let G=U;G>=1;G/=2)w(j,G,v.shape)}let x=v;v=Xf({inputs:{x:v},backend:n,attrs:{begin:0,size:[f,i]}}),Nd(n,x);let C=aX({inputs:{x:m,indices:v},backend:n,attrs:{axis:1,batchDims:1}});Nd(n,m);let k=u.slice(0,-1);k.push(i),x=v,v=me({inputs:{x:v},attrs:{shape:k},backend:n}),Nd(n,x);let T=C;return C=me({inputs:{x:C},attrs:{shape:k},backend:n}),Nd(n,T),[C,v]}},R5e=class{constructor(e,t,n,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let o,s="nearest"===n?1:2;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${s} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}},O5e={kernelName:nf,backendName:"webgl",kernelFunc:function F5e(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:i}=t,{interpolation:s,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=a.shape,[f,m]=u??[h,d],y=new R5e(h,d,s,o,l,[c,f,m,p]);return n.runWebGLProgram(y,[a,i],"float32")}},P5e={kernelName:wy,backendName:"webgl",kernelFunc:function $5e(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;Uf(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let s=r.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=RBe(s,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},z5e={kernelName:rf,backendName:"webgl",kernelFunc:function L5e(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a,o=s.shape.length,l=a.shape[i],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==i&&(u[c++]=s.shape[m]);let h=[],d=new Array(o).fill(0),p=s.shape.slice();p[i]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;let g=Xf({inputs:{x:s},backend:n,attrs:{begin:d,size:p}}),y=me({inputs:{x:g},backend:n,attrs:{shape:u}});f[m]=y,h.push(g)}return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}},B5e=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,s=i*Math.ceil(a/n);this.outputShape=[r,s];let u=4*Math.floor(n/4),c=n%4,h="\n        sumValue += dot(values, segFilter);\n    ",d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}},U5e={kernelName:xy,backendName:"webgl",kernelFunc:function V5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:s}=r,o=a.shape.length,l=[],u=0,c=E.getAxesPermutation([u],o),h=a;null!=c&&(h=Wr({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(h),u=E.getInnerMostAxes(1,o)[0]);let d=E.segment_util.computeOutShape(h.shape,u,s),p=I.sizeFromShape([h.shape[u]]),f=me({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=S0(a.dtype),g=(w,x,C,k,T)=>{let A=w.shape[0],R=w.shape[1],M=E.segment_util.segOpComputeOptimalWindowSize(R,T),$=new B5e({windowSize:M,inSize:R,batchSize:A,numSegments:T},x),U=n.compileAndRun($,[w,C],k);if(l.push(U),U.shape[1]===T)return U;let j=hX({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),G=mX({inputs:{x:j},backend:n,attrs:{reps:[R/M]}});return l.push(j),l.push(G),g(U,x,G,k,T)},v=me({inputs:{x:g(f,"unsortedSegmentSum",i,m,s)},backend:n,attrs:{shape:d}}),b=v;if(null!=c){l.push(v);let w=E.getUndoAxesPermutation(c);b=Wr({inputs:{x:b},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),b}},W5e=[EVe,NVe,AVe,FVe,$Ve,zVe,VVe,WVe,qVe,XVe,QVe,tUe,aUe,lUe,dUe,pUe,mUe,bUe,xUe,SUe,kUe,FUe,$Ue,BUe,UUe,KUe,ZUe,eWe,uVe,rWe,lWe,hWe,vWe,xWe,SWe,CWe,kWe,AWe,FWe,PWe,zWe,VWe,WWe,GWe,KWe,QWe,e4e,r4e,s4e,l4e,h4e,g4e,w4e,S4e,E4e,k4e,T4e,A4e,R4e,O4e,P4e,V4e,j4e,q4e,X4e,Q4e,tje,ije,uje,lVe,dje,sWe,fje,yje,wje,dVe,_je,Nje,Dje,Fje,Pje,Vje,jje,Kje,Qje,tHe,rHe,oHe,uHe,dHe,mHe,yHe,bHe,xHe,SHe,kHe,AHe,OHe,WHe,fVe,qHe,ZHe,JHe,nGe,jUe,iGe,oGe,uGe,hGe,gGe,pVe,vGe,wGe,IGe,_Ge,CGe,HUe,zHe,NGe,MGe,$Ge,gVe,BGe,WGe,qGe,ZGe,e6e,n6e,i6e,l6e,d6e,f6e,y6e,w6e,_6e,k6e,A6e,F6e,MUe,VHe,P6e,z6e,V6e,W6e,H6e,q6e,X6e,Y6e,J6e,n5e,a5e,s5e,l5e,d5e,p5e,m5e,y5e,BHe,SVe,w5e,S5e,C5e,N5e,M5e,O5e,_Ve,P5e,z5e,U5e,sGe];for(let e of W5e)_y(e);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(wt||(wt={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(Mv||(Mv={}));var G5e={kernelName:Vc,backendName:"wasm",setupFunc:function j5e(e){yX=e.wasm.cwrap(Vc,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function H5e(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:i,bias:s,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r,d=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=0;if(null!=s){let T=n.dataIdMap.get(s.dataId);if(1!==T.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=Mv[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],v=u?i.shape[1]:i.shape[2],b=mf.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)),w=n.makeOutput([...b,y,v],a.dtype),x=n.dataIdMap.get(w.dataId).id,C=new Uint8Array(new Int32Array(a.shape).buffer),k=new Uint8Array(new Int32Array(i.shape).buffer);return yX(d,C,a.shape.length,p,k,i.shape.length,l,u,g,f,m,h||0,x),w}};function mt(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function r(i){n=i.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function a(i){let{backend:s,inputs:{x:o}}=i,l=s.dataIdMap.get(o.dataId).id,u=s.makeOutput(o.shape,t||o.dtype),c=s.dataIdMap.get(u.dataId).id;return 0===I.sizeFromShape(u.shape)||n(l,wt[o.dtype],c),u}}}var q5e=mt(np),K5e=mt(Su),X5e=mt(_u);function An(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function a(s){r=s.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function i(s){let{backend:o,inputs:l}=s,{a:u,b:c}=l,h=o.dataIdMap.get(u.dataId).id,d=o.dataIdMap.get(c.dataId).id,p=n??u.dtype,f=E.assertAndGetBroadcastShape(u.shape,c.shape),m=o.makeOutput(f,p);if(0===I.sizeFromShape(f))return m;let g=new Uint8Array(new Int32Array(u.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),v=o.dataIdMap.get(m.dataId).id;return r(h,g,u.shape.length,d,y,c.shape.length,wt[u.dtype],v),m}}}var vX,Y5e=An(Ho),e8e={kernelName:Cu,backendName:"wasm",setupFunc:function Q5e(e){vX=e.wasm.cwrap(Cu,null,["array","number","number","number"])},kernelFunc:function J5e(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===I.sizeFromShape(r.shape))return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),i=new Uint8Array(new Int32Array(a).buffer),s=n.dataIdMap.get(r.dataId).id;return vX(i,a.length,wt[r.dtype],s),r}};function o1(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return $r(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var bX,t8e={kernelName:Qu,backendName:"wasm",kernelFunc:o1};function _l(e){let{inputs:t,backend:n,attrs:r}=e,[a,i]=function a8e(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let i=-1;for(let s=0;s<r.length;++s)r[s]>=a&&(-1===i||r[i]>r[s])&&(i=s);r[i]=a}return[n,r]}(t.x.shape,r.perm),s=!0;for(let f=0;f<i.length;f++)i[f]!==f&&(s=!1);let o=function r8e(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(s){let f=o1({inputs:t,backend:n});return f.shape=o,f}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return bX(c,p,l.shape.length,wt[l.dtype],h,d,i.length),u}var wX,i8e={kernelName:eo,backendName:"wasm",kernelFunc:_l,setupFunc:function n8e(e){bX=e.wasm.cwrap(eo,null,["number","array","number","number","number","array","number"])}};function Cl(e,t,n){let r=e.shape,a=e.shape.length,i=I.parseAxisParam(t,r),s=i,o=E.getAxesPermutation(s,a),l=null,u=!1;if(null!=o){let c=new Array(a);for(let d=0;d<c.length;d++)c[d]=r[o[d]];s=E.getInnerMostAxes(s.length,a),l=_l({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(u=!0)}return{transposed:l,originalAxes:i,axes:s,inputWasTransposed:u}}var xX,l8e={kernelName:rp,backendName:"wasm",setupFunc:function s8e(e){wX=e.wasm.cwrap(rp,null,["number, number, number"])},kernelFunc:function o8e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:d}=Cl(s,a,t);d&&(l=u,o=t.dataIdMap.get(u.dataId).id),E.assertAxesAreInnerMostDims("all",c,l.shape.length);let[f,m]=E.computeOutAndReduceShapes(l.shape,c),g=I.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==I.sizeFromShape(l.shape)){let v=t.dataIdMap.get(y.dataId).id;wX(o,g,v)}if(d&&t.disposeData(u.dataId),i){let v=E.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}},d8e={kernelName:ap,backendName:"wasm",setupFunc:function u8e(e){xX=e.wasm.cwrap(ap,null,["number, number, number"])},kernelFunc:function c8e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:d}=Cl(s,a,t);d&&(l=u,o=t.dataIdMap.get(u.dataId).id),E.assertAxesAreInnerMostDims("any",c,l.shape.length);let[f,m]=E.computeOutAndReduceShapes(l.shape,c),g=I.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==I.sizeFromShape(l.shape)){let v=t.dataIdMap.get(y.dataId).id;xX(o,g,v)}if(d&&t.disposeData(u.dataId),i){let v=E.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}};function IX(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function n(a){t=a.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function r(a){let{backend:i,inputs:s,attrs:o}=a,{axis:l}=o,{x:u}=s,c=i.dataIdMap.get(u.dataId).id,h=c,d=u,{transposed:p,axes:f,inputWasTransposed:m}=Cl(u,l,i);if(m){let x=i.dataIdMap.get(p.dataId).id;x!==c&&(d=p,h=x)}let g=d.shape.slice(0,-1),y=i.makeOutput(g,"int32"),v=i.dataIdMap.get(y.dataId).id,b=I.sizeFromShape(y.shape);return t(h,wt[d.dtype],b,d.shape[f[0]],v),m&&i.disposeData(p.dataId),y}}}var SX,_X,CX,EX,h8e=IX(ip),p8e=IX(sp),f8e=mt(Eu),m8e=mt(ku),g8e=mt(Nu),y8e=An(Du),v8e=mt(Tu),x8e={kernelName:Au,backendName:"wasm",setupFunc:function b8e(e){SX=e.wasm.cwrap(Au,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function w8e(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=n,c=E.computePool2DInfo(a.shape,s,o,1,l,u),h=c.filterHeight,d=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,v=c.strideWidth,b=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let w=r.makeOutput(c.outShape,"float32"),x=r.dataIdMap.get(w.dataId).id;return SX(i,a.shape[0],a.shape[1],a.shape[2],h,d,p,f,m,g,y,v,b,x),w}},_8e={kernelName:op,backendName:"wasm",setupFunc:function I8e(e){_X=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function S8e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=E.computePool3DInfo(a.shape,i,s,1,o,l,u),h=n.makeOutput(c.outShape,a.dtype);return _X(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}},k8e={kernelName:ny,backendName:"wasm",setupFunc:function C8e(e){CX=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function E8e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,c=E.computePool3DInfo(i.shape,s,o,1,l,u),h=n.makeOutput(i.shape,i.dtype);return CX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),h}},D8e={kernelName:ty,backendName:"wasm",setupFunc:function N8e(e){EX=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function T8e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l}=r,u=E.computePool2DInfo(i.shape,s,o,1,l),c=n.makeOutput(i.shape,i.dtype);return EX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}};function ua(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,i=I.sizeFromShape(r.shape),s=I.inferFromImplicitShape(a,i);return I.assert(i===I.sizeFromShape(s),()=>`new shape: ${s}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:s,dtype:r.dtype}}var kX,A8e={kernelName:Up,backendName:"wasm",kernelFunc:ua},F8e={kernelName:Mu,backendName:"wasm",setupFunc:function M8e(e){kX=e.wasm.cwrap(Mu,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function R8e(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:i}=t,{transposeA:s,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=i.shape.length,c=s?a.shape[l-2]:a.shape[l-1],h=o?i.shape[u-1]:i.shape[u-2],d=s?a.shape[l-1]:a.shape[l-2],p=o?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=I.sizeFromShape(f),y=I.sizeFromShape(m),v=mf.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);I.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`);let w=o?[y,p,h]:[y,h,p],x=ua({inputs:{x:a},backend:n,attrs:{shape:s?[g,c,d]:[g,d,c]}}),C=ua({inputs:{x:i},backend:n,attrs:{shape:w}}),k=n.dataIdMap.get(x.dataId).id,T=n.dataIdMap.get(C.dataId).id,A=s?x.shape[2]:x.shape[1],R=o?C.shape[1]:C.shape[2],M=Math.max(g,y),_=n.makeOutput([M,A,R],x.dtype),$=n.dataIdMap.get(_.dataId).id,U=new Uint8Array(new Int32Array(x.shape).buffer),j=new Uint8Array(new Int32Array(C.shape).buffer);return kX(k,U,x.shape.length,T,j,C.shape.length,s,o,$),n.disposeData(x.dataId),n.disposeData(C.dataId),_.shape=v,_}};function Td(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[i,s]=Vn.parseSliceParams(t,n,r),o=Vn.isSliceContinous(t.shape,i,s),l=a.readSync(t.dataId),u=a.makeOutput(s,t.dtype),c=I.computeStrides(t.shape),h=a.dataIdMap.get(u.dataId);if(o){let f=Vn.computeFlatOffset(i,c);return"string"===t.dtype?h.stringBytes=l.slice(f,f+I.sizeFromShape(s)):a.typedArrayFromHeap(u).set(l.subarray(f,f+I.sizeFromShape(s))),u}if("string"===t.dtype){let f=BI(l,i,s,t.shape,t.dtype);return h.stringBytes=f,u}let d=a.typedArrayFromHeap(u),p=t.shape.length;if(2===p)!function O8e(e,t,n,r,a){let i=0,s=r[0],o=r[1],l=s+a[0];for(let u=s;u<l;u++){let c=u*t+o;n.set(e.subarray(c,c+a[1]),i),i+=a[1]}}(l,c[0],d,i,s);else if(3===p)!function $8e(e,t,n,r,a,i){let s=0,o=a[0],l=a[1],u=a[2],c=o+i[0],h=l+i[1];for(let d=o;d<c;d++)for(let p=l;p<h;p++){let f=d*t+p*n+u;r.set(e.subarray(f,f+i[2]),s),s+=i[2]}}(l,c[0],c[1],d,i,s);else if(4===p)!function P8e(e,t,n,r,a,i,s){let o=0,l=i[0],u=i[1],c=i[2],h=l+s[0],d=u+s[1],p=c+s[2],f=i[3];for(let m=l;m<h;m++)for(let g=u;g<d;g++)for(let y=c;y<p;y++){let v=m*t+g*n+y*r+f;a.set(e.subarray(v,v+s[3]),o),o+=s[3]}}(l,c[0],c[1],c[2],d,i,s);else{let f=BI(l,i,s,t.shape,t.dtype);d.set(f)}return u}var NX,L8e={kernelName:Xp,backendName:"wasm",kernelFunc:Td},B8e={kernelName:lp,backendName:"wasm",kernelFunc:function z8e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:s}=r,o=i.reduce((y,v)=>y*v),l=E.getReshaped(a.shape,i,o),u=E.getPermuted(l.length,i.length),c=E.getReshapedPermuted(a.shape,i,o),h=E.getSliceBeginCoords(s,i.length),d=E.getSliceSize(c,s,i.length),p=ua({inputs:{x:a},backend:n,attrs:{shape:l}}),f=_l({inputs:{x:p},backend:n,attrs:{perm:u}}),m=ua({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Td({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}},W8e={kernelName:up,backendName:"wasm",setupFunc:function V8e(e){NX=e.wasm.cwrap(up,null,["number","number","boolean","number","number","number"])},kernelFunc:function U8e(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:s}=r,o=0!==i.shape.reduce((h,d)=>h*d,1),u=t.makeOutput(1===a.shape.length?[s]:[a.shape[0],s],i.dtype);function c(h){return t.dataIdMap.get(h.dataId).id}return NX(c(a),s,o,c(i),wt[i.dtype],c(u)),u}},H8e=An(cp),q8e={kernelName:ry,backendName:"wasm",kernelFunc:function G8e(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.typedArrayFromHeap(r),s=n.typedArrayFromHeap(a),o=E.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function El(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),i=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(i),a}var TX,K8e={kernelName:Ru,backendName:"wasm",kernelFunc:El},X8e=mt(Fu),Q8e={kernelName:Go,backendName:"wasm",setupFunc:function Z8e(e){TX=e.wasm.cwrap(Go,null,["number","number","number","number"])},kernelFunc:function Y8e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:i,clipValueMax:s}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return TX(o,i,s,u),l}};function DX(e){let{inputs:t,backend:n}=e,r=I.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(p=>p.shape);E.assertParamsConsistent(a,r);let i=E.computeOutShape(t.map(p=>p.shape),r),s=t.filter(p=>I.sizeFromShape(p.shape)>0);if(1===s.length)return o1({inputs:{x:s[0]},backend:n});let o=n.makeOutput(i,t[0].dtype);if(0===I.sizeFromShape(i))return o;if("string"===s[0].dtype){let p=s.map(b=>{let w=[-1,I.sizeFromShape(b.shape.slice(r))];return ua({inputs:{x:b},backend:n,attrs:{shape:w}})}),f=p.map(b=>({vals:n.readSync(b.dataId),shape:b.shape}));i=E.computeOutShape(p.map(b=>b.shape),1);let g=sM(f,i,t[0].dtype,1===p[0].shape[0]),y=E.computeOutShape(s.map(b=>b.shape),r);return o.shape=y,n.dataIdMap.get(o.dataId).stringBytes=E.fromStringArrayToUint8(g),p.forEach(b=>n.disposeData(b.dataId)),o}let l=I.sizeFromShape(s[0].shape.slice(0,r)),u=0,c=s.map(p=>{let f=I.sizeFromShape(p.shape.slice(r));return u+=f,f}),h=s.map(p=>n.typedArrayFromHeap(p)),d=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*u;for(let m=0;m<h.length;m++){let g=c[m],y=p*g,v=h[m].subarray(y,y+g);d.set(v,f),f+=g}}return o}var AX,MX,RX,FX,OX,HM,$X,J8e={kernelName:dp,backendName:"wasm",kernelFunc:DX},nqe={kernelName:Ou,backendName:"wasm",setupFunc:function eqe(e){AX=e.wasm.cwrap(Ou,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function tqe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,s=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:h,dataFormat:d}=n,p=E.convertConv2DDataFormat(d),f=E.computeConv2DInfo(a.shape,i.shape,l,u,c,h,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,v=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,x=f.dilationHeight,C=f.dilationWidth,k=f.strideHeight,T=f.strideWidth,A=f.inChannels,R=f.outChannels,M="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(f.outShape,"float32"),$=r.dataIdMap.get(_.dataId).id;return AX(s,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,v,b,w,M,x,C,k,T,A,R,$),_}},iqe={kernelName:$u,backendName:"wasm",setupFunc:function rqe(e){MX=e.wasm.cwrap($u,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function aqe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:i}=n,{strides:s,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(c,i.shape,s,1,o,u,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:v,inWidth:b,outChannels:w,outHeight:x,outWidth:C,strideHeight:k,strideWidth:T}=p,A=m-1-p.padInfo.top,R=g-1-p.padInfo.left,M="channelsLast"===p.dataFormat,_=I.computeStrides(p.inShape),$=I.computeStrides(a.shape),[U,j,G]=I.computeStrides(i.shape),K=_[0],X=M?_[1]:_[2],Y=M?_[2]:1,ee=M?1:_[1],te=$[0],se=M?$[1]:$[2],re=M?$[2]:1,oe=M?1:$[1],le=t.makeOutput(p.inShape,"float32"),Ce=t.dataIdMap.get(le.dataId).id,fe=t.dataIdMap.get(a.dataId).id,_e=t.dataIdMap.get(i.dataId).id;return MX(fe,_e,f,m,g,v,b,y,x,C,w,k,T,A,R,U,j,G,K,X,Y,ee,te,se,re,oe,Ce),le}},lqe={kernelName:Pu,backendName:"wasm",setupFunc:function sqe(e){RX=e.wasm.cwrap(Pu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function oqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=E.computeConv3DInfo(a.shape,i.shape,s,l,o),c=n.makeOutput(u.outShape,a.dtype);return RX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},dqe={kernelName:hp,backendName:"wasm",setupFunc:function uqe(e){FX=e.wasm.cwrap(hp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function cqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:s,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=E.computeConv3DInfo(a.shape,l,s,1,o),c=n.makeOutput(u.filterShape,i.dtype);return FX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},fqe={kernelName:pp,backendName:"wasm",setupFunc:function hqe(e){OX=e.wasm.cwrap(pp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function pqe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:s,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=E.computeConv3DInfo(l,i.shape,o,1,s),c=n.makeOutput(u.inShape,a.dtype);return OX(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},mqe=mt(Lu),gqe=mt(zu);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(HM||(HM={}));var PX,LX,zX,BX,VX,UX,WX,jX,HX,GX,bqe={kernelName:mp,backendName:"wasm",setupFunc:function yqe(e){$X=e.wasm.cwrap(mp,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function vqe(e){let m,{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:i,cropSize:s}=r,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[h,d]=s,p=[c,h,d,o.shape[3]],f=t.dataIdMap.get(o.dataId);"float32"!==o.dtype&&(m=El({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,v=t.dataIdMap.get(u.dataId).id,b=t.makeOutput(p,"float32"),w=t.dataIdMap.get(b.dataId).id,x=new Uint8Array(new Int32Array(o.shape).buffer);return $X(g,y,v,c,x,h,d,HM[a],i,w),null!=m&&t.disposeData(m.dataId),b}},Iqe={kernelName:fp,backendName:"wasm",setupFunc:function wqe(e){PX=e.wasm.cwrap(fp,null,["number","number","number","number","number","number"])},kernelFunc:function xqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r,l=a.shape.length;I.assert("float32"===a.dtype||"int32"===a.dtype,()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let u=E.getAxesPermutation([i],l),c=a;null!==u&&(c=_l({inputs:{x:a},attrs:{perm:u},backend:n}));let h=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumprod",[h],l);let d=n.makeOutput(c.shape,c.dtype),p=c.shape[h],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(d.dataId).id;PX(f,s?1:0,o?1:0,p,m,wt[a.dtype]);let g=d;return null!==u&&(g=_l({inputs:{x:d},attrs:{perm:E.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(d.dataId)),g}},Cqe={kernelName:Bu,backendName:"wasm",setupFunc:function Sqe(e){LX=e.wasm.cwrap(Bu,null,["number","number","number","number","number","number"])},kernelFunc:function _qe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:s,reverse:o}=r,l=a.shape.length;I.assert("float32"===a.dtype||"int32"===a.dtype,()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let u=E.getAxesPermutation([i],l),c=a;null!==u&&(c=_l({inputs:{x:a},attrs:{perm:u},backend:n}));let h=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumsum",[h],l);let d=n.makeOutput(c.shape,c.dtype),p=c.shape[h],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(d.dataId).id;LX(f,s?1:0,o?1:0,p,m,wt[a.dtype]);let g=d;return null!==u&&(g=_l({inputs:{x:d},attrs:{perm:E.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(d.dataId)),g}},Nqe={kernelName:iy,backendName:"wasm",setupFunc:function Eqe(e){zX=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function kqe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:s,binaryOutput:o}=r,l=0!==i.shape.reduce((d,p)=>d*p,1),c=t.makeOutput(1===a.shape.length?[s]:[a.shape[0],s],i.dtype);function h(d){return t.dataIdMap.get(d.dataId).id}return zX(h(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,s,l,h(i),wt[i.dtype],o,h(c)),c}},Aqe={kernelName:gp,backendName:"wasm",setupFunc:function Tqe(e){BX=e.wasm.cwrap(gp,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function Dqe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:i,dataFormat:s}=r,o=a.shape[0],h=("NHWC"===s?a.shape[1]:a.shape[2])*i,d=("NHWC"===s?a.shape[2]:a.shape[3])*i,p=("NHWC"===s?a.shape[3]:a.shape[1])/(i*i),f="NHWC"===s?[o,h,d,p]:[o,p,h,d],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(I.computeStrides(a.shape)).buffer),v=new Uint8Array(new Int32Array(f).buffer),b=new Uint8Array(new Int32Array(I.computeStrides(f)).buffer),w=t.dataIdMap.get(m.dataId).id;return BX(g,i,"NHWC"===s?1:0,y,a.shape.length-1,v,b,f.length,w),m}},Fqe={kernelName:Vu,backendName:"wasm",setupFunc:function Mqe(e){VX=e.wasm.cwrap(Vu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Rqe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,s=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:h}=n,p=E.computeConv2DInfo(a.shape,i.shape,l,u??[1,1],c,h,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,v=p.padInfo.bottom,b=p.padInfo.left,w=p.dilationHeight,x=p.dilationWidth,C=p.strideHeight,k=p.strideWidth,T=p.inChannels,A=p.outChannels,R="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let M=r.makeOutput(p.outShape,"float32"),_=r.dataIdMap.get(M.dataId).id;return VX(s,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,v,b,R,w,x,C,k,T,A,_),M}},Pqe={kernelName:sy,backendName:"wasm",setupFunc:function Oqe(e){UX=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function $qe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=I.sizeFromShape(r.shape),i=n.makeOutput([...r.shape,...r.shape],r.dtype);return UX(n.dataIdMap.get(r.dataId).id,wt[r.dtype],a,n.dataIdMap.get(i.dataId).id),i}},Bqe={kernelName:Uu,backendName:"wasm",setupFunc:function Lqe(e){WX=e.wasm.cwrap(Uu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function zqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:s,pad:o,dilations:l}=r;if(a.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${i.dtype}`);let u=E.computeDilation2DInfo(a.shape,i.shape,s,o,"NHWC",l),c=n.makeOutput(u.outShape,a.dtype);return WX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,wt[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}},Wqe={kernelName:vp,backendName:"wasm",setupFunc:function Vqe(e){jX=e.wasm.cwrap(vp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Uqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==s.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${s.dtype}`);let c=E.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u),h=n.makeOutput(i.shape,i.dtype);return jX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,wt[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}},Gqe={kernelName:yp,backendName:"wasm",setupFunc:function jqe(e){HX=e.wasm.cwrap(yp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Hqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:s}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==s.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${s.dtype}`);let c=E.computeDilation2DInfo(a.shape,i.shape,o,l,"NHWC",u),h=n.makeOutput(a.shape,a.dtype);return HX(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,wt[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}},qqe=mt(ju),Zqe={kernelName:bp,backendName:"wasm",setupFunc:function Kqe(e){GX=e.wasm.cwrap(bp,null,["number","number","number"])},kernelFunc:function Xqe(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=n.makeOutput(a.shape,"float32"),s=o=>n.dataIdMap.get(o.dataId).id;return GX(s(a),s(r),s(i)),i}},Qqe=An(wp,0,"bool"),Jqe=mt(Hu),eKe=mt(Gu,"float32");function GM(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:i}=n,s=a.shape.length,o=a.shape.slice(),l=i;return i<0&&(I.assert(-(s+1)<=i,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),l=s+i+1),o.splice(l,0,1),ua({inputs:{x:a},backend:r,attrs:{shape:o}})}var tKe={kernelName:xp,backendName:"wasm",kernelFunc:GM},nKe=mt(qu,"float32");function qX(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||I.inferDtype(n);let i=r.makeOutput(t,a);return r.typedArrayFromHeap(i).fill(n),i}var KX,XX,ZX,YX,QX,JX,eZ,tZ,nZ,rZ,aZ,iZ,sZ,oZ,lZ,uZ,cZ,dZ,qM,hZ,rKe={kernelName:oy,backendName:"wasm",kernelFunc:qX},sKe={kernelName:Ip,backendName:"wasm",kernelFunc:function iKe(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),i=n.dataIdMap.get(r.dataId).id,s=n.dataIdMap.get(a.dataId).id,[o,l,u,c]=r.shape;return KX(i,o,l,u,c,s),a},setupFunc:function aKe(e){KX=e.wasm.cwrap(Ip,null,["number","number","number","number","number","number"])}},oKe=mt(Ku),uKe=An(Xu),hKe={kernelName:Zu,backendName:"wasm",setupFunc:function cKe(e){XX=e.wasm.cwrap(Zu,null,["number","number","number","number","number","number","number"])},kernelFunc:function dKe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:i,mean:s,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(i.shape,i.dtype);if(0===I.sizeFromShape(i.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return XX(c,h,d,p,f,a,g),m}},mKe={kernelName:Uc,backendName:"wasm",setupFunc:function pKe(e){ZX=e.wasm.cwrap(Uc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function fKe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,i.shape,l,c,u,d),g=Mv[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,v=r.dataIdMap.get(i.dataId).id,b=m.outChannels,w=0;if(null!=s){let re=r.dataIdMap.get(s.dataId);if(1!==re.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${re.shape.length}.`);if(re.shape[0]!==b)throw new Error(`FusedConv2D bias shape (${re.shape}) does not match the number of output channels (${b})`);w=re.id}let x=m.filterHeight,C=m.filterWidth,k=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,M=m.dilationHeight,_=m.dilationWidth,$=m.strideHeight,U=m.strideWidth,j=m.inChannels,G="SAME"===m.padInfo.type?1:0,K=m.batchSize,X=m.inHeight,Y=m.inWidth;if("NHWC"!==h)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),te=r.dataIdMap.get(ee.dataId).id,se=null==o?0:r.dataIdMap.get(o.dataId).id;return ZX(y,K,X,Y,v,x,C,w,k,T,A,R,G,M,_,$,U,j,b,g,se,f||0,te),ee}},vKe={kernelName:Wc,backendName:"wasm",setupFunc:function gKe(e){YX=e.wasm.cwrap(Wc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function yKe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:s,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,i.shape,l,c,u,d,!0),g=Mv[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,v=r.dataIdMap.get(i.dataId).id,b=m.outChannels,w=0;if(null!=s){let re=r.dataIdMap.get(s.dataId);if(1!==re.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${re.shape.length}.`);if(re.shape[0]!==b)throw new Error(`FusedDepthwiseConv2D bias shape (${re.shape}) does not match the number of output channels (${b})`);w=re.id}let x=m.filterHeight,C=m.filterWidth,k=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,M=m.dilationHeight,_=m.dilationWidth,$=m.strideHeight,U=m.strideWidth,j=m.inChannels,G="SAME"===m.padInfo.type?1:0,K=m.batchSize,X=m.inHeight,Y=m.inWidth;if("NHWC"!==h)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),te=r.dataIdMap.get(ee.dataId).id,se=null==o?0:r.dataIdMap.get(o.dataId).id;return YX(y,K,X,Y,v,x,C,w,k,T,A,R,G,M,_,$,U,j,b,g,se,f||0,te),ee}},xKe={kernelName:_p,backendName:"wasm",setupFunc:function bKe(e){QX=e.wasm.cwrap(_p,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function wKe(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[i,s,o,l]=bD.prepareAndValidate(r,a),u=t.makeOutput(i,r.dtype);if(0===s)return u;let c=a.shape,h=c[c.length-1],d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return QX(d,wt[r.dtype],p,s,h,o,f,m),u}},_Ke={kernelName:Sp,backendName:"wasm",setupFunc:function IKe(e){JX=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function SKe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:i}=n,{axis:s,batchDims:o}=r,l=I.parseAxisParam(s,a.shape)[0],u=t.readSync(i.dataId),c=a.shape[l];for(let k=0;k<u.length;++k){let T=u[k];I.assert(T<=c-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${c-1}]`)}let h=E.segment_util.collectGatherOpShapeInfo(a,i,l,o),d=ua({inputs:{x:a},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),p=I.sizeFromShape(i.shape),f=ua({inputs:{x:i},attrs:{shape:[h.batchSize,p/h.batchSize]},backend:t}),m=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],g=t.makeOutput(m,a.dtype);if(0===I.sizeFromShape(a.shape))return g;let y=d.shape.length-1,v=t.dataIdMap.get(d.dataId).id,b=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,x=new Uint8Array(new Int32Array(I.computeStrides(d.shape)).buffer),C=new Uint8Array(new Int32Array(I.computeStrides(m)).buffer);return JX(v,wt[a.dtype],x,y,b,h.batchSize,C,w),t.disposeData(d.dataId),t.disposeData(f.dataId),g.shape=h.outputShape,g}},EKe=An(Cp,0,"bool"),NKe=An(Yu,0,"bool"),TKe=mt(Ju,"bool"),DKe=mt(ec,"bool"),AKe=mt(tc,"bool"),FKe={kernelName:nc,backendName:"wasm",setupFunc:function MKe(e){eZ=e.wasm.cwrap(nc,null,["number","number","number","number"])},kernelFunc:function RKe(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,i=r.makeOutput(t.shape,"float32");if(0!==I.sizeFromShape(t.shape)){let s=r.dataIdMap.get(i.dataId).id;eZ(a,wt[t.dtype],n,s)}return i}},$Ke=An(Ep,0,"bool"),LKe=An(kp,0,"bool"),VKe={kernelName:Np,backendName:"wasm",setupFunc:function zKe(e){tZ=e.wasm.cwrap(Np,null,["number","number","number","number"])},kernelFunc:function BKe(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:i}=t,s=Math.floor(i),o=n.makeOutput([s],"float32");return tZ(n.dataIdMap.get(o.dataId).id,r,a,s),o}},UKe=mt(rc),WKe=mt(ac),HKe=An(Tp,0,"bool"),GKe=mt(Dp),KKe=An(Ap,0,"bool"),ZKe=An(nH,0,"bool"),JKe={kernelName:ic,backendName:"wasm",setupFunc:function YKe(e){nZ=e.wasm.cwrap(ic,null,["number","number","number","number","number","number","number"])},kernelFunc:function QKe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return nZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],i,s,o,l),u}},n7e={kernelName:Mp,backendName:"wasm",setupFunc:function e7e(e){rZ=e.wasm.cwrap(Mp,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function t7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:s}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if("float32"!==a.dtype||"float32"!==i.dtype||"float32"!==s.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(a.shape,a.dtype);return rZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(h.dataId).id,s.shape[3],o,l,u,c),h}},i7e={kernelName:sc,backendName:"wasm",setupFunc:function r7e(e){aZ=e.wasm.cwrap(sc,null,["number","number","number","number"])},kernelFunc:function a7e(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=s,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:d}=Cl(s,a,t);d&&(l=u,o=t.dataIdMap.get(u.dataId).id),E.assertAxesAreInnerMostDims("max",c,l.shape.length);let[f,m]=E.computeOutAndReduceShapes(l.shape,c),g=I.sizeFromShape(m),y=t.makeOutput(f,s.dtype);if(0!==I.sizeFromShape(l.shape)){let v=t.dataIdMap.get(y.dataId).id;aZ(o,wt[s.dtype],g,v)}if(d&&t.disposeData(u.dataId),i){let v=E.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}},o7e=An(oc),c7e={kernelName:lc,backendName:"wasm",setupFunc:function l7e(e){iZ=e.wasm.cwrap(lc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function u7e(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id;I.assert("float32"===a.dtype,()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=n,c=E.computePool2DInfo(a.shape,s,o,1,l,u),h=c.filterHeight,d=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,v=c.dilationWidth,b=c.strideHeight,w=c.strideWidth,x=c.inChannels,C=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let k=r.makeOutput(c.outShape,"float32"),T=r.dataIdMap.get(k.dataId).id;return iZ(i,a.shape[0],a.shape[1],a.shape[2],h,d,p,f,m,g,y,v,b,w,x,C,T),k}},p7e={kernelName:Rp,backendName:"wasm",setupFunc:function d7e(e){sZ=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function h7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=E.computePool3DInfo(a.shape,i,s,1,o,l,u),h=n.makeOutput(c.outShape,a.dtype);return sZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}},g7e={kernelName:uy,backendName:"wasm",setupFunc:function f7e(e){oZ=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function m7e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,c=E.computePool3DInfo(i.shape,s,o,1,l,u),h=n.makeOutput(i.shape,i.dtype);return oZ(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}},b7e={kernelName:ly,backendName:"wasm",setupFunc:function y7e(e){lZ=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function v7e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:s,strides:o,pad:l,dimRoundingMode:u}=r,c=E.computePool2DInfo(i.shape,s,o,1,l,u),h=n.makeOutput(i.shape,i.dtype);return lZ(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),h}},I7e={kernelName:cy,backendName:"wasm",setupFunc:function w7e(e){uZ=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function x7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:l}=r;I.assert(4===a.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let u=[1,1];I.assert(E.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=E.computePool2DInfo(a.shape,i,s,[1,1],o),h=n.makeOutput(c.outShape,a.dtype),d=n.makeOutput(c.outShape,"int32");return uZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(d.dataId).id,wt[a.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[h,d]}},C7e={kernelName:uc,backendName:"wasm",setupFunc:function S7e(e){cZ=e.wasm.cwrap(uc,null,["number, number, number"])},kernelFunc:function _7e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=Cl(s,a,t),f=h;if(p){let w=t.dataIdMap.get(c.dataId).id;w!==o&&(u=c,l=w,f=E.getInnerMostAxes(f.length,u.shape.length))}E.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=E.computeOutAndReduceShapes(u.shape,f),y=I.sizeFromShape(g),v=u;"float32"!==u.dtype&&(v=El({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(v.dataId).id);let b=t.makeOutput(m,"float32");if(0!==I.sizeFromShape(u.shape)){let w=t.dataIdMap.get(b.dataId).id;cZ(l,y,w)}if(p&&t.disposeData(c.dataId),i){let w=E.expandShapeToKeepDim(b.shape,d);b.shape=w}return"float32"!==u.dtype&&t.disposeData(v.dataId),b}},N7e={kernelName:cc,backendName:"wasm",setupFunc:function E7e(e){dZ=e.wasm.cwrap(cc,null,["number","number","number","number"])},kernelFunc:function k7e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=Cl(s,a,t);if(p){let b=t.dataIdMap.get(c.dataId).id;b!==o&&(u=c,l=b)}E.assertAxesAreInnerMostDims("min",h,u.shape.length);let[m,g]=E.computeOutAndReduceShapes(u.shape,h),y=I.sizeFromShape(g),v=t.makeOutput(m,u.dtype);if(0!==I.sizeFromShape(u.shape)){let b=t.dataIdMap.get(v.dataId).id;dZ(l,wt[s.dtype],y,b)}if(p&&t.disposeData(c.dataId),i){let b=E.expandShapeToKeepDim(v.shape,d);v.shape=b}return v}},D7e=An(dc);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(qM||(qM={}));var pZ,R7e={kernelName:hc,backendName:"wasm",kernelFunc:function M7e(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,i=r.map((f,m)=>f[0]+t.shape[m]+f[1]),s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(h).buffer);return hZ(s,u,t.shape.length,wt[t.dtype],d,p,qM[a],l),o},setupFunc:function A7e(e){hZ=e.wasm.cwrap(hc,null,["number","array","number","number","array","array","number","number"])}};function fZ(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,i=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(i.dataId).id,o=n.shape[r],l=I.sizeFromShape(n.shape)/o;return 0===I.sizeFromShape(i.shape)||pZ(a,s,o,l),i}var mZ,gZ,O7e={kernelName:$c,backendName:"wasm",setupFunc:function F7e(e){pZ=e.wasm.cwrap($c,null,["number","number","number","number"])},kernelFunc:fZ},L7e={kernelName:Fp,backendName:"wasm",setupFunc:function $7e(e){mZ=e.wasm.cwrap(Fp,null,["number","number","number","number","number","number"])},kernelFunc:function P7e(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:s,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:fZ({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,c]=l.shape,h=n.makeOutput([u,i],"int32");return mZ(n.dataIdMap.get(l.dataId).id,u,c,i,s,n.dataIdMap.get(h.dataId).id),o||n.disposeData(l.dataId),h}},z7e=An(pc),V7e=An(fc),U7e=mt(Op);function KM(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],i=n[2],s=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:i,pValidOutputs:s}}var yZ,vZ,bZ,wZ,IZ,SZ,_Z,CZ,EZ,kZ,NZ,TZ,DZ,AZ,MZ,RZ,FZ,OZ,$Z,H7e={kernelName:Pp,backendName:"wasm",setupFunc:function W7e(e){gZ=e.wasm.cwrap(Pp,"number",["number","number","number","number","number"])},kernelFunc:function j7e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,h=gZ(u,c,i,a,s),{pSelectedIndices:d,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=KM(t,h);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",d)}},K7e={kernelName:Lp,backendName:"wasm",setupFunc:function G7e(e){yZ=e.wasm.cwrap(Lp,"number",["number","number","number","number","number","bool"])},kernelFunc:function q7e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,d=yZ(c,h,i,a,s,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=KM(t,d);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",g)]}},Y7e={kernelName:zp,backendName:"wasm",setupFunc:function X7e(e){vZ=e.wasm.cwrap(zp,"number",["number","number","number","number","number","number"])},kernelFunc:function Z7e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:s,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,d=vZ(c,h,i,a,s,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=KM(t,d);return t.wasm._free(g),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},J7e=An($p,0,"bool"),n9e={kernelName:mc,backendName:"wasm",setupFunc:function e9e(e){bZ=e.wasm.cwrap(mc,null,["number","number","number","number","number"])},kernelFunc:function t9e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:s,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,s],i),c=n.dataIdMap.get(u.dataId).id,h=n.dataIdMap.get(a.dataId).id;return bZ(h,s,o,l,c),u}},a9e={kernelName:Bp,backendName:"wasm",kernelFunc:function r9e(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}},s9e={kernelName:Vp,backendName:"wasm",kernelFunc:function i9e(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return GM({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach(c=>{I.assertShapesMatch(i,c.shape,"All tensors passed to stack must have matching shapes"),I.assert(s===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=DX({inputs:t.map(c=>{let h=GM({inputs:{input:c},backend:n,attrs:{dim:a}});return o.push(h),h}),backend:n,attrs:{axis:a}});return o.forEach(c=>n.disposeData(c.dataId)),u}},xZ={kernelName:gc,backendName:"wasm",kernelFunc:function l9e(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,i=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(0===I.sizeFromShape(t.shape))return qX({backend:n,attrs:{shape:i,value:a,dtype:t.dtype}});let s=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(h).buffer);return wZ(s,u,t.shape.length,wt[t.dtype],d,p,a,l),o},setupFunc:function o9e(e){wZ=e.wasm.cwrap(gc,null,["number","array","number","number","array","array","number","number"])}},c9e=An(yc),p9e={kernelName:vc,backendName:"wasm",setupFunc:function d9e(e){IZ=e.wasm.cwrap(vc,null,["number","number","number"])},kernelFunc:function h9e(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=n.dataIdMap.get(r.dataId).id,s=n.dataIdMap.get(a.dataId).id,o=i,l=r,u=l;"float32"!==l.dtype&&(u=El({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),h=n.dataIdMap.get(c.dataId).id;return IZ(o,s,h),"float32"!==l.dtype&&n.disposeData(u.dataId),c}},g9e={kernelName:bc,backendName:"wasm",setupFunc:function f9e(e){SZ=e.wasm.cwrap(bc,null,["number","number","number","number"])},kernelFunc:function m9e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=Cl(s,a,t),f=h;if(p){let b=t.dataIdMap.get(c.dataId).id;b!==o&&(u=c,l=b,f=E.getInnerMostAxes(f.length,u.shape.length))}E.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=E.computeOutAndReduceShapes(u.shape,f),y=I.sizeFromShape(g),v=t.makeOutput(m,u.dtype);if(0!==I.sizeFromShape(u.shape)){let b=t.dataIdMap.get(v.dataId).id;SZ(l,y,wt[v.dtype],b)}if(p&&t.disposeData(c.dataId),i){let b=E.expandShapeToKeepDim(v.shape,d);v.shape=b}return v}},v9e={kernelName:dy,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:s}=n,o=uM(r,a,i,s),l=t.makeOutput([o.length],s);return t.typedArrayFromHeap(l).set(o),l}},w9e=An(Wu),x9e=mt(wc),I9e=mt(xc),S9e=mt(_c),E9e={kernelName:Sc,backendName:"wasm",setupFunc:function _9e(e){_Z=e.wasm.cwrap(Sc,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function C9e(e){let g,{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,[c,h,d,p]=a.shape,f=[c,l,u,p],m=t.dataIdMap.get(a.dataId);"float32"!==m.dtype&&(g=El({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,v=t.makeOutput(f,"float32");if(0===I.sizeFromShape(a.shape))return v;let b=t.dataIdMap.get(v.dataId).id;return _Z(y,c,h,d,p,l,u,i?1:0,s?1:0,b),null!=g&&t.disposeData(g.dataId),v}},T9e={kernelName:jp,backendName:"wasm",setupFunc:function k9e(e){CZ=e.wasm.cwrap(jp,null,["number","number","number","array","array","boolean"])},kernelFunc:function N9e(e){let u,{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId);return"float32"!==l.dtype&&(u=El({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),CZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),s),null!=u&&n.disposeData(u.dataId),o}},M9e={kernelName:Ic,backendName:"wasm",setupFunc:function D9e(e){EZ=e.wasm.cwrap(Ic,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function A9e(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:i,halfPixelCenters:s,size:o}=r,[l,u]=o,[c,h,d,p]=a.shape,m=t.makeOutput([c,l,u,p],"float32");if(0===I.sizeFromShape(a.shape))return m;let y,g=t.dataIdMap.get(a.dataId);"float32"!==g.dtype&&(y=El({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let v=g.id,b=t.dataIdMap.get(m.dataId).id;return EZ(v,c,h,d,p,l,u,i?1:0,s?1:0,b),null!=y&&t.disposeData(y.dataId),m}},O9e={kernelName:Wp,backendName:"wasm",setupFunc:function R9e(e){kZ=e.wasm.cwrap(Wp,null,["number","number","number","array","array","boolean"])},kernelFunc:function F9e(e){let u,{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:s}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId);return"float32"!==l.dtype&&(u=El({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),kZ(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),s),null!=u&&n.disposeData(u.dataId),o}},L9e={kernelName:Cc,backendName:"wasm",kernelFunc:function P9e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,s=I.parseAxisParam(i,a.shape);if(0===a.shape.length)return o1({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(a.shape).buffer);NZ(l,c,s.length,h,a.shape.length,u);let d=ua({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d},setupFunc:function $9e(e){NZ=e.wasm.cwrap(Cc,null,["number","array","number","array","number","number"])}},V9e={kernelName:sf,backendName:"wasm",kernelFunc:function B9e(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:i,fillValue:s,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[h,d,p,f]=a.shape,[m,g]=E.getImageCenter(o,d,p),b="number"==typeof s?[s,s,s,0===s?0:255]:[...s,255],w=new Uint8Array(new Int32Array(b).buffer);return TZ(u,h,d,p,f,i,m,g,w,b.length,c),l},setupFunc:function z9e(e){TZ=e.wasm.cwrap(sf,null,["number","number","number","number","number","number","number","number","array","number","number"])}},U9e=mt(Ec),W9e=mt(kc),G9e={kernelName:Hp,backendName:"wasm",setupFunc:function j9e(e){DZ=e.wasm.cwrap(Hp,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function H9e(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:i}=n,{shape:s}=r,o=t.makeOutput(s,i.dtype);if(0===I.sizeFromShape(s))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Y0.calculateShapes(i,a,s),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=new Uint8Array(new Int32Array(h).buffer),g=t.dataIdMap.get(o.dataId).id;return DZ(p,f,wt[i.dtype],l,u,c,m,d,g),o}},X9e={kernelName:qp,backendName:"wasm",setupFunc:function q9e(e){AZ=e.wasm.cwrap(qp,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function K9e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:s}=r;if(a.dtype!==i.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${i.dtype}`);let o=n.makeOutput(i.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return AZ(l(a),l(i),a.shape[0],a.shape[1],i.shape[1],wt[a.dtype],"left"===s,l(o)),o}},Q9e={kernelName:Kp,backendName:"wasm",kernelFunc:function Y9e(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(i.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,h=r.shape.length,p=0===h||h>1||1===a.shape.length?1:I.sizeFromShape(a.shape.slice(1));return MZ(s,o,l,p,c),u},setupFunc:function Z9e(e){MZ=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},J9e=mt(Nc),nXe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function eXe(e){RZ=e.wasm.cwrap(Mc,null,["number","number"])},kernelFunc:function tXe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id;return 0===I.sizeFromShape(a.shape)||RZ(r,i),a}},rXe=mt(Ac),aXe=mt(Tc),iXe=mt(Dc),sXe=mt(Rc),lXe={kernelName:Zp,backendName:"wasm",kernelFunc:function oXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:s}=r,o=I.sizeFromShape(i),l=[[0,0]];l.push(...s);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=xZ.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=E.getReshaped(u.shape,i,o,!1),h=E.getPermuted(c.length,i.length,!1),d=E.getReshapedPermuted(u.shape,i,o,!1),p=ua({inputs:{x:u},backend:n,attrs:{shape:c}}),f=_l({inputs:{x:p},backend:n,attrs:{perm:h}}),m=ua({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}},dXe={kernelName:hy,backendName:"wasm",setupFunc:function uXe(e){FZ=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function cXe(e){let R,{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:i,defaultValue:s}=n,o=r.shape[0],l=r.shape[1],u=t.readSync(i.dataId)[0],c=[o+u,l],h=t.dataIdMap.get(r.dataId).id,d=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(s.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(c.slice(0,1),a.dtype),y=t.dataIdMap.get(g.dataId).id,v=t.makeOutput([u],"bool"),b=t.dataIdMap.get(v.dataId).id,w=t.makeOutput([o],r.dtype),x=t.dataIdMap.get(w.dataId).id,C=t.makeOutput([4],"int32"),k=t.dataIdMap.get(C.dataId).id,T=FZ(h,d,wt[a.dtype],o,u,l,p,m,y,b,x,k),A=t.readSync(C.dataId);switch(A[0]){case 1:R=E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break;case 2:R=E.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break;case 3:R=E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:R=""}if(t.disposeData(C.dataId),R)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(v.dataId),t.disposeData(w.dataId),new Error(R);let M=f,_=g;return T!==c[0]&&(M=Td({inputs:{x:f},attrs:{begin:0,size:[T,l]},backend:t}),_=Td({inputs:{x:g},attrs:{begin:0,size:T},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[M,_,v,w]}},fXe={kernelName:Qp,backendName:"wasm",setupFunc:function hXe(e){OZ=e.wasm.cwrap(Qp,null,["number","number","number","number","number","number","number"])},kernelFunc:function pXe(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:i}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let s=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=r.shape[0],c=I.sizeFromShape(i.shape),h=t.makeOutput([u,c],r.dtype),d=t.dataIdMap.get(h.dataId).id,p=t.makeOutput([c],i.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;OZ(s,o,l,u,d,f,g);let v,y=t.readSync(m.dataId);switch(y[0]){case 0:v=E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break;case 1:v=E.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break;case 2:v=E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let b=Array.from(t.readSync(a.dataId)),w=Array.from(t.readSync(p.dataId));v=E.getSparseReshapeInputOutputMultipleErrorMessage(b,w);break}case 4:{let b=Array.from(t.readSync(a.dataId)),w=Array.from(t.readSync(p.dataId));v=E.getSparseReshapeInputOutputMismatchErrorMessage(b,w);break}default:v=""}if(t.disposeData(m.dataId),v)throw t.disposeData(h.dataId),t.disposeData(p.dataId),new Error(v);return[h,p]}};function PZ(e){$Z=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function LZ(e,t){let{backend:n,inputs:r}=e,{data:a,indices:i,segmentIds:s}=r,o=i.shape[0],l=n.readSync(s.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=a.shape.slice();c[0]=u;let h=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(i.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;$Z(h,wt[a.dtype],a.shape[0],d,p,m,y,t,0);let b,v=n.readSync(g.dataId);switch(v[0]){case 0:b=E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:b=E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var zZ,BZ,VZ,UZ,WZ,jZ,HZ,GZ,gXe={kernelName:py,backendName:"wasm",setupFunc:PZ,kernelFunc:function mXe(e){return LZ(e,!0)}},vXe={kernelName:fy,backendName:"wasm",setupFunc:PZ,kernelFunc:function yXe(e){return LZ(e,!1)}},xXe={kernelName:Jp,backendName:"wasm",setupFunc:function bXe(e){zZ=e.wasm.cwrap(Jp,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function wXe(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=n,{outputShape:o}=r,l=t.makeOutput(o,s.dtype);if(0===I.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=E.calculateShapes(i,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(i.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),v=t.dataIdMap.get(l.dataId).id;return zZ(f,m,i.shape.length,g,wt[s.dtype],u,c,h,y,p,v),l}},SXe={kernelName:Yp,backendName:"wasm",kernelFunc:function IXe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=n,o=I.parseAxisParam(s,a.shape)[0],l=E.prepareSplitSize(a,i,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map(h=>{let d=[...c];d[o]=h;let p=Td({inputs:{x:a},attrs:{begin:u,size:d},backend:r});return u[o]+=h,p})}},_Xe=mt(Fc),CXe=mt(my),kXe=An(Pc),DXe={kernelName:Ko,backendName:"wasm",setupFunc:function NXe(e){BZ=e.wasm.cwrap(Ko,null,["number","number","number","number"])},kernelFunc:function TXe(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:i}=n,s=t.dataIdMap.get(i.dataId).id,o=t.makeOutput(i.shape,i.dtype),l=t.dataIdMap.get(o.dataId).id;return BZ(s,a,wt[i.dtype],l),o}},RXe={kernelName:ef,backendName:"wasm",setupFunc:function AXe(e){VZ=e.wasm.cwrap(ef,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function MXe(e){let x,{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:i,end:s,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:b,strides:w}=Vn.sliceInfo(a.shape,i,s,o,l,u,c,h,d);if(m)x=ua({inputs:{x:a},backend:t,attrs:{shape:f}});else if(g||y){I.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let C=Vn.computeOutShape(v,b,w),k=Td({inputs:{x:a},backend:t,attrs:{begin:v,size:C}});x=ua({inputs:{x:k},backend:t,attrs:{shape:f}}),t.disposeData(k.dataId)}else{let C=t.makeOutput(p,"float32"),k=t.dataIdMap.get(a.dataId).id,T=new Uint8Array(new Int32Array(I.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(v).buffer),R=new Uint8Array(new Int32Array(b).buffer),M=new Uint8Array(new Int32Array(w).buffer),_=new Uint8Array(new Int32Array(p).buffer),$=new Uint8Array(new Int32Array(I.computeStrides(p)).buffer),U=t.dataIdMap.get(C.dataId).id;VZ(k,T,a.shape.length,A,R,M,_,$,p.length,U),x=ua({inputs:{x:C},backend:t,attrs:{shape:f}}),t.disposeData(C.dataId)}return x}},OXe={kernelName:yy,backendName:"wasm",kernelFunc:function FXe(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:i}=n,{separator:s,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:h}=r,d=t.readSync(a.dataId),p=t.readSync(i.dataId),[f,m]=dM(d,p,s,o,l,u,c,h),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let v=t.makeOutput(i.shape,"int32");return t.typedArrayFromHeap(v).set(m),[g,v]}},PXe={kernelName:vy,backendName:"wasm",kernelFunc:function $Xe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:i}=n,{skipEmpty:s}=r,o=t.readSync(a.dataId),l=t.readSync(i.dataId),[u,c,h]=hM(o,l[0],s),d=c.length,p=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([d],"string");t.dataIdMap.get(f.dataId).stringBytes=c;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(h),[p,f,g]}},zXe={kernelName:by,backendName:"wasm",kernelFunc:function LXe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:i}=r,o=pM(t.readSync(a.dataId),i),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}},VXe=An(Lc),jXe={kernelName:Oc,backendName:"wasm",setupFunc:function UXe(e){UZ=e.wasm.cwrap(Oc,null,["number","number","number","number"])},kernelFunc:function WXe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,l=o,u=s,{transposed:c,axes:h,originalAxes:d,inputWasTransposed:p}=Cl(s,a,t),f=h;if(p){let b=t.dataIdMap.get(c.dataId).id;b!==o&&(u=c,l=b,f=E.getInnerMostAxes(f.length,u.shape.length))}E.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=E.computeOutAndReduceShapes(u.shape,f),y=I.sizeFromShape(g),v=t.makeOutput(m,u.dtype);if(0!==I.sizeFromShape(u.shape)){let b=t.dataIdMap.get(v.dataId).id;UZ(l,y,wt[v.dtype],b)}if(p&&t.disposeData(c.dataId),i){let b=E.expandShapeToKeepDim(v.shape,d);v.shape=b}return v}},HXe=mt(zc),GXe=mt(Bc),XXe={kernelName:Gp,backendName:"wasm",setupFunc:function qXe(e){WZ=e.wasm.cwrap(Gp,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function KXe(e){let{backend:t,inputs:n}=e,{tensor:a,indices:i,updates:s}=n,o=t.makeOutput(a.shape,a.dtype);if(0===I.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Y0.calculateShapes(s,i,a.shape),p=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(o.dataId).id;return WZ(p,f,wt[s.dtype],l,u,c,g,d,y,m),o}},QXe={kernelName:qo,backendName:"wasm",setupFunc:function ZXe(e){jZ=e.wasm.cwrap(qo,null,["number","array","number","array","number","number"])},kernelFunc:function YXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,i=n.dataIdMap.get(a.dataId).id,{reps:s}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*s[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,a.dtype),h=n.dataIdMap.get(c.dataId).id;return jZ(i,l,a.shape.length,u,o.length,wt[c.dtype],h),c}},tZe={kernelName:tf,backendName:"wasm",setupFunc:function JXe(e){HZ=e.wasm.cwrap(tf,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:i}=n,s=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,h=t.makeOutput(l,"int32"),d=t.dataIdMap.get(h.dataId).id;return HZ(s,o,r.shape.length,wt[r.dtype],a,i,c,d),[u,h]}},aZe={kernelName:nf,backendName:"wasm",setupFunc:function nZe(e){GZ=e.wasm.cwrap(nf,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function rZe(e){let T,{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:i}=n,{interpolation:s,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=a.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=new Uint8Array(new Int32Array(I.computeStrides(a.shape)).buffer),v=new Uint8Array(new Int32Array(I.computeStrides(g)).buffer),b=t.makeOutput(g,a.dtype),w=t.dataIdMap.get(b.dataId).id,x=t.dataIdMap.get(a.dataId).id,C=t.dataIdMap.get(i.dataId).id,k="nearest"===s?1:2;switch(o){case"constant":default:T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4}return GZ(x,C,i.shape[0]>1,c,f,m,p,d,h,y,a.shape.length-1,v,g.length-1,k,T,l,w),b}},sZe={kernelName:wy,backendName:"wasm",kernelFunc:function iZe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t,{outputValues:s,outputShape:o,indices:l}=mM(r.readSync(i.dataId),a,i.shape,i.dtype);return[r.makeOutput(o,i.dtype,void 0,s),r.makeOutput([l.length],"int32",void 0,l)]}},lZe={kernelName:rf,backendName:"wasm",kernelFunc:function oZe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let s=a.shape[i],o=a.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==i&&(l[u++]=a.shape[p]);let c=new Array(s),h=new Array(o).fill(0),d=a.shape.slice();d[i]=1;for(let p=0;p<c.length;p++)h[i]=p,c[p]=Td({inputs:{x:a},attrs:{begin:h,size:d},backend:n});return c.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}},cZe={kernelName:af,backendName:"wasm",kernelFunc:function uZe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},dZe=[G5e,q5e,K5e,X5e,Y5e,e8e,l8e,d8e,h8e,p8e,f8e,m8e,g8e,y8e,v8e,x8e,D8e,_8e,k8e,F8e,B8e,W8e,H8e,q8e,K8e,X8e,Q8e,J8e,nqe,iqe,lqe,dqe,fqe,mqe,gqe,bqe,Iqe,Cqe,Nqe,Aqe,Fqe,Pqe,Bqe,Wqe,Gqe,qqe,Zqe,Qqe,Jqe,eKe,tKe,nKe,rKe,sKe,oKe,uKe,hKe,mKe,vKe,xKe,_Ke,EKe,NKe,t8e,TKe,DKe,AKe,FKe,$Ke,LKe,VKe,WKe,UKe,HKe,GKe,KKe,ZKe,JKe,n7e,i7e,o7e,c7e,p7e,g7e,b7e,I7e,C7e,N7e,D7e,R7e,L7e,z7e,V7e,U7e,H7e,K7e,Y7e,J7e,n9e,a9e,s9e,xZ,c9e,p9e,g9e,v9e,w9e,x9e,I9e,S9e,A8e,E9e,T9e,M9e,O9e,L9e,V9e,U9e,W9e,G9e,X9e,Q9e,J9e,nXe,rXe,aXe,iXe,L8e,O7e,sXe,lXe,dXe,fXe,gXe,vXe,xXe,SXe,_Xe,CXe,kXe,DXe,RXe,OXe,PXe,zXe,VXe,jXe,HXe,GXe,XXe,QXe,tZe,aZe,i8e,sZe,lZe,cZe];for(let e of dZe)_y(e);var XM=H();XM.registerFlag("WASM_HAS_SIMD_SUPPORT",F(function*(){try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}})),XM.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",F(function*(){if(XM.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}}));var qZ=Uo(wve()),hZe=Uo(xve()),KZ=Uo(Ive()),XZ=qZ.default||qZ,pZe=KZ.default||KZ,ZZ=class extends Yg{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(QZ),QM=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Yx(this,fi())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}time(e){return F(function*(){let t=I.now();return e(),{kernelMs:I.now()-t}})()}move(e,t,n,r,a){let i=this.dataIdNextNumber++;if("string"===r)return void this.dataIdMap.set(e,{id:i,stringBytes:t,shape:n,dtype:r,memoryOffset:null,refCount:a});let s=I.sizeFromShape(n),o=s*I.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(i,s,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}read(e){var t=this;return F(function*(){return t.readSync(e)})()}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:i,stringBytes:s}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=s.length)?s.slice(t,n):s;t=t||0,n=n||I.sizeFromShape(i);let o=I.bytesPerElement(a);return function gZe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(r??null,e,t);else{let i=this.dataIdNextNumber++;a={id:i},this.dataIdMap.set(a,{id:i,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=I.sizeFromShape(e);this.wasm.tfjs.registerTensor(i,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),i=I.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,i);case"int32":return new Int32Array(r,a,i);case"bool":return new Uint8Array(r,a,i);default:throw new Error(`Unknown dtype ${t}`)}}};function YZ(e,t,n){if(null!=l1)return l1;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Fv&&null!=Fv[r]?Fv[r]:n+r}function ZM(){return ZM=F(function*(){let[e,t]=yield Promise.all([H().getAsync("WASM_HAS_SIMD_SUPPORT"),H().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={locateFile:(o,l)=>{if(o.endsWith(".worker.js")){let u=hZe.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?YZ(e,t,Rv??l):l+o}};YM&&(a.instantiateWasm=function fZe(e){return(t,n)=>(I.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(i=>{n(i.instance,i.module)})})}),{})}(YZ(e,t,Rv??"")));let s,i=!1;a.onAbort=()=>{i||Ov||(Ov=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==l1?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+XZ.toString()],{type:"text/javascript"}),s=XZ(a)):s=pZe(a),s.then(o=>{i=!0,Ov=!1,o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",null,["number"]),dispose:o.cwrap("dispose",null,[])},n({wasm:o})}).catch(r)})}),ZM.apply(this,arguments)}var yZe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],l1=null,Rv=null,Fv={},Ov=!1,YM=!1;function vZe(e,t=!1){if(xN("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Ov)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");l1=e,YM=t}function bZe(e,t=!1){if(Ov)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)Rv=e;else{Fv=e;let n=yZe.filter(r=>null==Fv[r]);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}YM=t}var QZ=-1,QM=-1;function wZe(e){QZ=e}function xZe(){if(-1===QM)throw new Error("WASM backend not initialized.");return QM}var IZe="4.16.0";C0("wasm",F(function*(){let{wasm:e}=yield function mZe(){return ZM.apply(this,arguments)}();return new ZZ(e)}),2);var NZe={tfjs:"4.16.0","tfjs-core":"4.16.0","tfjs-converter":"4.16.0","tfjs-backend-cpu":"4.16.0","tfjs-backend-webgl":"4.16.0","tfjs-backend-wasm":"4.16.0"},$v={};function kl(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},i)=>{let s=t[i];e.moveTo(s.x,s.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}Jk($v,{AnchorPosition:()=>pY,DrawBox:()=>mY,DrawBoxOptions:()=>fY,DrawFaceLandmarks:()=>AY,DrawFaceLandmarksOptions:()=>DY,DrawTextField:()=>o2,DrawTextFieldOptions:()=>s2,drawContour:()=>kl,drawDetections:()=>BZe,drawFaceExpressions:()=>tYe,drawFaceLandmarks:()=>rYe}),Jk({},{computeReshapedDimensions:()=>nY,getCenterPoint:()=>c1,isDimensions:()=>e2,isEven:()=>JM,isFloat:()=>tY,isTensor:()=>Yf,isTensor1D:()=>DZe,isTensor2D:()=>eY,isTensor3D:()=>Pv,isTensor4D:()=>go,isValidNumber:()=>Nl,isValidProbablitiy:()=>d1,range:()=>Qf,round:()=>u1});var Dd=class EQ{constructor(t,n){if(!Nl(t)||!Nl(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new EQ(1/this.width,1/this.height)}};function Yf(e,t){return e instanceof Ze&&e.shape.length===t}function DZe(e){return Yf(e,1)}function eY(e){return Yf(e,2)}function Pv(e){return Yf(e,3)}function go(e){return Yf(e,4)}function tY(e){return e%1!=0}function JM(e){return e%2==0}function u1(e,t=2){let n=10**t;return Math.floor(e*n)/n}function e2(e){return e&&e.width&&e.height}function nY({width:e,height:t},n){let r=n/Math.max(t,e);return new Dd(Math.round(e*r),Math.round(t*r))}function c1(e){return e.reduce((t,n)=>t.add(n),new Wt(0,0)).div(new Wt(e.length,e.length))}function Qf(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function Nl(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function d1(e){return Nl(e)&&e>=0&&e<=1}var Wt=class Od{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Od(this.x+t.x,this.y+t.y)}sub(t){return new Od(this.x-t.x,this.y-t.y)}mul(t){return new Od(this.x*t.x,this.y*t.y)}div(t){return new Od(this.x/t.x,this.y/t.y)}abs(){return new Od(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Od(Math.floor(this.x),Math.floor(this.y))}},yo=class Ji{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Nl)}static assertIsValidBox(t,n,r=!1){if(!Ji.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every(Nl),i=[r.x,r.y,r.width,r.height].every(Nl);if(!i&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[s,o,l,u]=i?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];Ji.assertIsValidBox({x:s,y:o,width:l,height:u},"Box.constructor",n),this._x=s,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Wt(this.left,this.top)}get topRight(){return new Wt(this.right,this.top)}get bottomLeft(){return new Wt(this.left,this.bottom)}get bottomRight(){return new Wt(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(i=>Math.round(i));return new Ji({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(i=>Math.floor(i));return new Ji({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,i=Math.abs(r-a);return r<a&&(t-=i/2,r+=i),a<r&&(n-=i/2,a+=i),new Ji({x:t,y:n,width:r,height:a})}rescale(t){let n=e2(t)?t.width:t,r=e2(t)?t.height:t;return new Ji({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,i,s]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Ji({x:r,y:a,width:i,height:s})}clipAtImageBorders(t,n){let{x:r,y:a,right:i,bottom:s}=this,o=Math.max(r,0),l=Math.max(a,0),c=s-l,h=Math.min(i-o,t-o),d=Math.min(c,n-l);return new Ji({x:o,y:l,width:h,height:d}).floor()}shift(t,n){let{width:r,height:a}=this;return new Ji({x:this.x+t,y:this.y+n,width:r,height:a})}padAtBorders(t,n){let r=this.width+1,a=this.height+1,o=r,l=a,u=this.left,c=this.top,h=this.right,d=this.bottom;return h>n&&(o=-h+n+r,h=n),d>t&&(l=-d+t+a,d=t),u<1&&(l=2-u,u=1),c<1&&(l=2-c,c=1),{dy:1,edy:l,dx:1,edx:o,y:c,ey:d,x:u,ex:h,w:r,h:a}}calibrate(t){return new Ji({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},rY=class extends yo{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},aY=class kQ{constructor(t,n,r,a,i){this._imageDims=new Dd(i.width,i.height),this._score=t,this._classScore=n,this._className=r,this._box=new yo(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new yo(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new kQ(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},Ii=class NQ extends aY{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:a,imageDims:i}=super.forSize(t,n);return new NQ(r,a,i)}};function AZe(e,t,n=!0){let i=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?i/(e.area+t.area-i):i/Math.min(e.area,t.area)}function Lv(e,t){return V(()=>{let[n,r,a]=t,i=_a([...e.shape.slice(0,3),1],n,"float32"),s=_a([...e.shape.slice(0,3),1],r,"float32"),o=_a([...e.shape.slice(0,3),1],a,"float32"),l=zt([i,s,o],3);return ye(e,l)})}function t2(e){return 1/(1+Math.exp(-e))}var or,iY=class extends yo{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},zv=class{constructor(e,t,n=new Wt(0,0)){let{width:r,height:a}=t;this._imgDims=new Dd(r,a),this._shift=n,this._positions=e.map(i=>i.mul(new Wt(r,a)).add(n))}get shift(){return new Wt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Wt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Wt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof Ii?e.box.floor():new yo(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=c=>r.sub(c).magnitude(),i=(a(t)+a(n))/2,s=Math.floor(i/.45),o=c1(e),l=Math.floor(Math.max(0,o.x-.5*s)),u=Math.floor(Math.max(0,o.y-.43*s));return new iY(l,u,Math.min(s,this.imageWidth+l),Math.min(s,this.imageHeight+u))}alignMinBbox(e){let t=function MZe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),i=t.reduce((o,l)=>o<l?l:o,0),s=n.reduce((o,l)=>o<l?l:o,0);return new rY(r,a,i,s)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},sY=class extends zv{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(c1)}};function Bv(e){return e.detection instanceof Ii}function p1(e,t){return{...e,detection:t}}function uY(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function n2(){return"object"==typeof global&&typeof process<"u"&&null!=process.versions&&null!=process.versions.node}function cY(e){let t="";if(!e&&n2())try{e=Qye("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(i,s)=>i?a(i):r(s))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function dY(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,s=global.fetch,o=cY();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:s,...o}}function hY(){return"object"==typeof window&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}function r2(e){or=e}function a2(){return hY()?r2(uY()):n2()?r2(dY()):null}var Er={getEnv:function LZe(){if(!or)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return or},setEnv:r2,initialize:a2,createBrowserEnv:uY,createFileSystem:cY,createNodejsEnv:dY,monkeyPatch:function zZe(e){if(or||a2(),!or)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=or.Canvas,Image:n=or.Image}=e;or.Canvas=t,or.Image=n,or.createCanvasElement=e.createCanvasElement||(()=>new t),or.createImageElement=e.createImageElement||(()=>new n),or.ImageData=e.ImageData||or.ImageData,or.Video=e.Video||or.Video,or.fetch=e.fetch||or.fetch,or.readFile=e.readFile||or.readFile},isBrowser:hY,isNodejs:n2};function i2(e){return Er.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function Tl(e){let{Canvas:t,CanvasRenderingContext2D:n}=Er.getEnv();if(e instanceof n)return e;let r=i2(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}a2();var pY=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(pY||{}),s2=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:i,padding:s}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=i||"Georgia",this.padding=s||4}},o2=class DQ{constructor(t,n,r={}){this.text="string"==typeof t?[t]:t instanceof DQ?t.text:t,this.anchor=n,this.options=new s2(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,a)=>r<a?a:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,a="BOTTOM_RIGHT"===r||"TOP_RIGHT"===r,i="BOTTOM_LEFT"===r||"BOTTOM_RIGHT"===r,s=this.measureWidth(t),o=this.measureHeight(),l=a?this.anchor.x-s:this.anchor.x,u=i?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:h}=n;return{x:Math.max(Math.min(l,c-s),0),y:Math.max(Math.min(u,h-o),0)}}return{x:l,y:u}}draw(t){let n=i2(t),r=Tl(n),{backgroundColor:a,fontColor:i,fontSize:s,fontStyle:o,padding:l}=this.options;r.font=`${s}px ${o}`;let u=this.measureWidth(r),c=this.measureHeight();r.fillStyle=a;let h=this.getUpperLeft(r,n);r.fillRect(h.x,h.y,u,c),r.fillStyle=i,this.text.forEach((d,p)=>{r.fillText(d,l+h.x,l+h.y+(p+1)*s)})}},fY=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r,this.drawLabelOptions=new s2({anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor,...a})}},mY=class{constructor(e,t={}){this.box=new yo(e),this.options=new fY(t)}draw(e){let t=Tl(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:i,width:s,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,i,s,o);let{label:l}=this.options;l&&new o2([l],{x:a-r/2,y:i},this.options.drawLabelOptions).draw(e)}};function BZe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Ii?n.score:Bv(n)?n.detection.score:void 0,a=n instanceof Ii?n.box:Bv(n)?n.detection.box:new yo(n),i=r?`${u1(r)}`:void 0;new mY(a,{label:i}).draw(e)})}function gY(e){let{Image:t,Video:n}=Er.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function l2(e){let{Image:t,Video:n}=Er.getEnv();return e instanceof t?new Dd(e.naturalWidth,e.naturalHeight):e instanceof n?new Dd(e.videoWidth,e.videoHeight):new Dd(e.width,e.height)}function f1({width:e,height:t}){let{createCanvasElement:n}=Er.getEnv(),r=n();return r.width=e,r.height=t,r}function yY(e,t){let{ImageData:n}=Er.getEnv();if(!(e instanceof n||gY(e)))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||l2(e),i=f1({width:r,height:a});return e instanceof n?Tl(i).putImageData(e,0,0):Tl(i).drawImage(e,0,0,r,a),i}function u2(){return u2=F(function*(e,t){let n=t||Er.getEnv().createCanvasElement(),[r,a,i]=e.shape.slice(go(e)?1:0),s=V(()=>e.as3D(r,a,i).toInt());return yield Qy.toPixels(s,n),s.dispose(),n}),u2.apply(this,arguments)}function vY(e){let{Image:t,Canvas:n,Video:r}=Er.getEnv();return e instanceof t||e instanceof n||e instanceof r}var m1=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(Pv(n))return this._imageTensors[r]=n,void(this._inputDimensions[r]=n.shape);if(go(n)){let i=n.shape[0];if(1!==i)throw new Error(`NetInput - tf.Tensor4D with batchSize ${i} passed, but not supported in input array`);return this._imageTensors[r]=n,void(this._inputDimensions[r]=n.shape.slice(1))}let a=n instanceof Er.getEnv().Canvas?n:yY(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Qf(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return nY({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,V(()=>{let n=Qf(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof Ze){let i=go(a)?a:nr(a);return i=function FZe(e,t=!1){return V(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),i=Math.round(a*(t?.5:1)),s=n>r?2:1,o=h=>{let d=e.shape.slice();return d[s]=h,_a(d,0,"float32")},l=o(i),u=a-l.shape[s],c=[t&&u?o(u):null,e,l].filter(h=>!!h).map(h=>de(h,"float32"));return zt(c,s)})}(i,t),(i.shape[1]!==e||i.shape[2]!==e)&&(i=Za.resizeBilinear(i,[e,e],!1,!1)),i.as3D(e,e,3)}if(a instanceof Er.getEnv().Canvas)return Qy.fromPixels(function jZe(e,t,n=!1){let{Image:r,Canvas:a}=Er.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return f1({width:1,height:1});let i=l2(e),s=t/Math.max(i.height,i.width),o=s*i.width,l=s*i.height,u=f1({width:t,height:t}),c=e instanceof a?e:yY(e),h=Math.abs(o-l)/2,d=n&&o<l?h:0,p=n&&l<o?h:0;return c.width>0&&c.height>0&&Tl(u).drawImage(c,d,p,o,l),u}(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return Tn(n.map(r=>de(r,"float32"))).as4D(this.batchSize,e,e,3)})}};function jr(e){return c2.apply(this,arguments)}function c2(){return c2=F(function*(e){if(e instanceof m1)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map(i2);return r.forEach((a,i)=>{if(!vY(a)&&!Pv(a)&&!go(a))throw"string"==typeof t[i]?new Error(`toNetInput -${n(i)} string passed, but could not resolve HTMLElement for element id ${t[i]}`):new Error(`toNetInput -${n(i)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(go(a)){let s=a.shape[0];if(1!==s)throw new Error(`toNetInput -${n(i)} tf.Tensor4D with batchSize ${s} passed, but not supported in input array`)}}),yield Promise.all(r.map(a=>vY(a)&&function VZe(e){return new Promise((t,n)=>{function r(i){i.currentTarget&&(i.currentTarget.removeEventListener("load",a),i.currentTarget.removeEventListener("error",r),n(i))}function a(i){i.currentTarget&&(i.currentTarget.removeEventListener("load",a),i.currentTarget.removeEventListener("error",r),t(i))}(e instanceof Er.getEnv().Canvas||gY(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)})}(a))),new m1(r,Array.isArray(e))}),c2.apply(this,arguments)}function d2(e,t){return h2.apply(this,arguments)}function h2(){return h2=F(function*(e,t){let{Canvas:n}=Er.getEnv(),r=e;if(!(e instanceof n)){let i=yield jr(e);if(i.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let s=i.getInput(0);r=s instanceof n?s:yield function WZe(e,t){return u2.apply(this,arguments)}(s)}let a=Tl(r);return t.map(i=>i instanceof Ii?i.forSize(r.width,r.height).box.floor():i).map(i=>i.clipAtImageBorders(r.width,r.height)).map(({x:i,y:s,width:o,height:l})=>{let u=f1({width:o,height:l});return o>0&&l>0&&Tl(u).putImageData(a.getImageData(i,s,o,l),0,0),u})}),h2.apply(this,arguments)}function p2(e,t){return f2.apply(this,arguments)}function f2(){return f2=F(function*(e,t){if(!Pv(e)&&!go(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(go(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return V(()=>{let[n,r,a]=e.shape.slice(go(e)?1:0);return t.map(i=>i instanceof Ii?i.forSize(r,n).box:i).map(i=>i.clipAtImageBorders(r,n)).filter(i=>i.width>0&&i.height>0).map(({x:i,y:s,width:o,height:l})=>Cf(e.as3D(n,r,a),[s,i,0],[l,o,a]))})}),f2.apply(this,arguments)}function m2(){return m2=F(function*(e,t){let{fetch:n}=Er.getEnv(),r=yield n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}),m2.apply(this,arguments)}function y2(){return y2=F(function*(e){return(yield function g1(e,t){return m2.apply(this,arguments)}(e)).json()}),y2.apply(this,arguments)}function bY(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter(o=>o),i=e.endsWith(".json")?a[a.length-1]:n,s=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return s=e.startsWith("/")?`/${s}`:s,{modelBaseUri:s,manifestUri:"/"===s?`/${i}`:`${s}/${i}`}}function w2(){return w2=F(function*(e,t){let{manifestUri:n,modelBaseUri:r}=bY(e,t),a=yield function HZe(e){return y2.apply(this,arguments)}(n);return hr.loadWeights(a,r)}),w2.apply(this,arguments)}var Dl=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Gc)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Gc))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=$r(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}load(e){var t=this;return F(function*(){e instanceof Float32Array?t.extractWeights(e):yield t.loadFromUri(e)})()}loadFromUri(e){var t=this;return F(function*(){if(e&&"string"!=typeof e)throw new Error(`${t._name}.loadFromUri - expected model uri`);let n=yield function qZe(e,t){return w2.apply(this,arguments)}(e,t.getDefaultModelName());t.loadFromWeightMap(n)})()}loadFromDisk(e){var t=this;return F(function*(){if(e&&"string"!=typeof e)throw new Error(`${t._name}.loadFromDisk - expected model file path`);let{readFile:n}=Er.getEnv(),{manifestUri:r,modelBaseUri:a}=bY(e,t.getDefaultModelName()),s=hr.weightsLoaderFactory(u=>Promise.all(u.map(c=>n(c).then(h=>"string"==typeof h?Buffer.from(h):h.buffer)))),o=JSON.parse((yield n(r)).toString()),l=yield s(o,a);t.loadFromWeightMap(l)})()}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,i)=>{if(!a.nextObj.hasOwnProperty(i))throw new Error(`traversePropertyPath - object does not have property ${i}, for path ${e}`);return{obj:a.nextObj,objProp:i,nextObj:a.nextObj[i]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!(n&&r&&n[r]instanceof Ze))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function ei(e,t,n){return V(()=>{let r=_f(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=J(r,t.bias),r})}function x2(e,t,n=!1){return V(()=>{let r=Rt(n?J(Lr(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):ei(e,t.conv0,[2,2])),a=ei(r,t.conv1,[1,1]),s=ei(Rt(J(r,a)),t.conv2,[1,1]);return Rt(J(r,J(a,s)))})}function y1(e,t,n=!1,r=!0){return V(()=>{let a=Rt(n?J(Lr(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):ei(e,t.conv0,r?[2,2]:[1,1])),i=ei(a,t.conv1,[1,1]),o=ei(Rt(J(a,i)),t.conv2,[1,1]),u=ei(Rt(J(a,J(i,o))),t.conv3,[1,1]);return Rt(J(a,J(i,J(o,u))))})}function Vv(e,t,n="same",r=!1){return V(()=>{let a=J(Lr(e,t.filters,[1,1],n),t.bias);return r?Rt(a):a})}function Al(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function I2(e,t){return(n,r,a,i)=>{let s=ll(e(n*r*a*a),[a,a,n,r]),o=Tt(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:s,bias:o}}}function wY(e,t){return(n,r,a)=>{let i=Is(e(n*r),[n,r]),s=Tt(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:i,bias:s}}}var xY=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function S2(e,t){return(n,r,a)=>{let i=ll(e(9*n),[3,3,n,1]),s=ll(e(n*r),[1,1,n,r]),o=Tt(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new xY(i,s,o)}}function _2(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new xY(n,r,a)}}function Ad(e,t){return(n,r,a)=>{let i=e[n];if(!Yf(i,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${i}`);return t.push({originalPath:n,paramPath:a||n}),i}}function Ml(e){let t=e;return{extractWeights:function n(a){let i=t.slice(0,a);return t=t.slice(a),i},getRemainingWeights:function r(){return t}}}function IY(e,t){let n=I2(e,t),r=S2(e,t);function a(s,o,l,u=!1){return{conv0:u?n(s,o,3,`${l}/conv0`):r(s,o,`${l}/conv0`),conv1:r(o,o,`${l}/conv1`),conv2:r(o,o,`${l}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function i(s,o,l,u=!1){let{conv0:c,conv1:h,conv2:d}=a(s,o,l,u);return{conv0:c,conv1:h,conv2:d,conv3:r(o,o,`${l}/conv3`)}}}}function SY(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function _Y(e,t){let n=Ad(e,t),r=SY(n),a=_2(n);return{extractDenseBlock3Params:function i(o,l=!1){return{conv0:l?r(`${o}/conv0`):a(`${o}/conv0`),conv1:a(`${o}/conv1`),conv2:a(`${o}/conv2`)}},extractDenseBlock4Params:function s(o,l=!1){return{conv0:l?r(`${o}/conv0`):a(`${o}/conv0`),conv1:a(`${o}/conv1`),conv2:a(`${o}/conv2`),conv3:a(`${o}/conv3`)}}}}var CY=class extends Dl{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return V(()=>{let a=y1(Lv(de(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return a=y1(a,t.dense1),a=y1(a,t.dense2),a=y1(a,t.dense3),a=ao(a,[7,7],[2,2],"valid"),a})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function ZZe(e){let t=[],{extractDenseBlock4Params:n}=_Y(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Al(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function XZe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ml(e),{extractDenseBlock4Params:a}=IY(n,t),i=a(3,32,"dense0",!0),s=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o,dense3:l}}}(e)}};function C2(e,t){return V(()=>J(et(e,t.weights),t.bias))}function EY(e){let t={},n={};return Object.keys(e).forEach(r=>{(r.startsWith("fc")?n:t)[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var kY=class extends Dl{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return V(()=>{let n=e instanceof m1?this.faceFeatureExtractor.forwardInput(e):e;return C2(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function YZe(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:i}=Ml(e),s=wY(a,r)(t,n,"fc");if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:r,params:{fc:s}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=EY(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function QZe(e){let t=[],n=Ad(e,t),a={fc:function r(i){return{weights:n(`${i}/weights`,2),bias:n(`${i}/bias`,1)}}("fc")};return Al(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),i=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(i)}},NY=["neutral","happy","sad","angry","fearful","disgusted","surprised"],E2=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);NY.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return NY.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}};function tYe(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let i=a instanceof E2?a:function eYe(e){return e.expressions instanceof E2}(a)?a.expressions:void 0;if(!i)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=i.asSortedArray().filter(l=>l.probability>n),o=Bv(a)?a.detection.box.bottomLeft:r||new Wt(0,0);new o2(s.map(l=>`${l.expression} (${u1(l.probability)})`),o).draw(e)})}function k2(e){return Bv(e)&&e.landmarks instanceof zv&&e.unshiftedLandmarks instanceof zv&&e.alignedRect instanceof Ii}function N2(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:i}=e.detection,s=new Ii(e.detection.score,a.rescale(i.reverse()),i),o=function nYe(e){let t=l=>180*l/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let o=e.positions;return r.roll=((l,u)=>{let c=Math.hypot(u.x-l.x,u.y-l.y),d=Math.asin((u.y-l.y)/c),p=t(d);return Math.floor(90-p)*(u.x-l.x<0?-1:1)})(o[27],o[66]),r.pitch=((l,u,c)=>{let h=n(l,c),d=new Wt((l.x+c.x)/2,(l.y+c.y)/2),p=n(u,d),f=Math.atan(p/h);return Math.floor(t(f))*(d.y-u.y<0?-1:1)})(o[14],o[30],o[2]),r.yaw=(u=o[33],c=o[2],Math.floor(o[14].x-u.x)-Math.floor(u.x-c.x)),r;var u,c}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:s,angle:o}}var DY=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:i,pointColor:s}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=i||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=s||"rgba(255, 0, 255, 1)"}},AY=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new DY(t)}draw(e){let t=Tl(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:i,pointSize:s,pointColor:o}=this.options;n&&this.faceLandmarks instanceof sY&&(t.strokeStyle=i,t.lineWidth=a,kl(t,this.faceLandmarks.getJawOutline()),kl(t,this.faceLandmarks.getLeftEyeBrow()),kl(t,this.faceLandmarks.getRightEyeBrow()),kl(t,this.faceLandmarks.getNose()),kl(t,this.faceLandmarks.getLeftEye(),!0),kl(t,this.faceLandmarks.getRightEye(),!0),kl(t,this.faceLandmarks.getMouth(),!0)),r&&(t.strokeStyle=o,t.fillStyle=o,this.faceLandmarks.positions.forEach(u=>{t.beginPath(),t.arc(u.x,u.y,s,0,2*Math.PI),t.fill()}))}};function rYe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof zv?n:k2(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new AY(r).draw(e)})}function MY(e,t,n){return J(Lr(e,t.filters,n,"same"),t.bias)}function T2(e,t,n=!0){let r=n?Rt(e):e;return r=ei(r,t.separable_conv0,[1,1]),r=ei(Rt(r),t.separable_conv1,[1,1]),r=rr(r,[3,3],[2,2],"same"),r=J(r,MY(e,t.expansion_conv,[2,2])),r}var uYe=class extends Dl{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return V(()=>{let r=Lv(de(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),a=Rt(MY(r,t.entry_flow.conv_in,[2,2]));return a=T2(a,t.entry_flow.reduction_block_0,!1),a=T2(a,t.entry_flow.reduction_block_1),Qf(this._numMainBlocks,0,1).forEach(i=>{a=function lYe(e,t){let n=ei(Rt(e),t.separable_conv0,[1,1]);return n=ei(Rt(n),t.separable_conv1,[1,1]),n=ei(Rt(n),t.separable_conv2,[1,1]),n=J(n,e),n}(a,t.middle_flow[`main_block_${i}`])}),a=T2(a,t.exit_flow.reduction_block),a=Rt(ei(a,t.exit_flow.separable_conv,[1,1])),a})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return function oYe(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:i,extractMainBlockParams:s}=function sYe(e,t){let n=Ad(e,t),r=SY(n),a=_2(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function i(o){return{separable_conv0:a(`${o}/separable_conv0`),separable_conv1:a(`${o}/separable_conv1`),expansion_conv:r(`${o}/expansion_conv`)}},extractMainBlockParams:function s(o){return{separable_conv0:a(`${o}/separable_conv0`),separable_conv1:a(`${o}/separable_conv1`),separable_conv2:a(`${o}/separable_conv2`)}}}}(e,n),c={conv_in:r("entry_flow/conv_in"),reduction_block_0:i("entry_flow/reduction_block_0"),reduction_block_1:i("entry_flow/reduction_block_1")},h={};Qf(t,0,1).forEach(m=>{h[`main_block_${m}`]=s(`middle_flow/main_block_${m}`)});let f={reduction_block:i("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return Al(e,n),{params:{entry_flow:c,middle_flow:h,exit_flow:f},paramMappings:n}}(e,this._numMainBlocks)}extractParams(e){return function iYe(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Ml(e),{extractConvParams:i,extractSeparableConvParams:s,extractReductionBlockParams:o,extractMainBlockParams:l}=function aYe(e,t){let n=I2(e,t),r=S2(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function a(s,o,l){return{separable_conv0:r(s,o,`${l}/separable_conv0`),separable_conv1:r(o,o,`${l}/separable_conv1`),expansion_conv:n(s,o,1,`${l}/expansion_conv`)}},extractMainBlockParams:function i(s,o){return{separable_conv0:r(s,s,`${o}/separable_conv0`),separable_conv1:r(s,s,`${o}/separable_conv1`),separable_conv2:r(s,s,`${o}/separable_conv2`)}}}}(r,n),d={conv_in:i(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},p={};Qf(t,0,1).forEach(y=>{p[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let g={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:s(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:p,exit_flow:g}}}(e,this._numMainBlocks)}},hYe=(e=>(e.FEMALE="female",e.MALE="male",e))(hYe||{}),RY=class extends kY{postProcess(e,t,n){let r=n.map(({width:i,height:s})=>{let o=t/Math.max(s,i);return{width:i*o,height:s*o}}),a=r.length;return V(()=>{let i=(u,c)=>Tn([_a([68],u,"float32"),_a([68],c,"float32")],1).as2D(1,136).as1D(),s=(u,c)=>{let{width:h,height:d}=r[u];return c(h,d)?Math.abs(h-d)/2:0};return e.mul(_a([a,136],t,"float32")).sub(Tn(Array.from(Array(a),(u,c)=>i((u=>s(u,(c,h)=>c<h))(c),(u=>s(u,(c,h)=>h<c))(c))))).div(Tn(Array.from(Array(a),(u,c)=>i(r[c].width,r[c].height))))})}forwardInput(e){return V(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}detectLandmarks(e){var t=this;return F(function*(){let n=yield jr(e),r=V(()=>vn(t.forwardInput(n))),a=yield Promise.all(r.map(function(){var i=F(function*(s,o){let l=Array.from(s.dataSync()),u=l.filter((h,d)=>JM(d)),c=l.filter((h,d)=>!JM(d));return new sY(Array(68).fill(0).map((h,d)=>new Wt(u[d],c[d])),{height:n.getInputHeight(o),width:n.getInputWidth(o)})});return function(s,o){return i.apply(this,arguments)}}()));return r.forEach(i=>i.dispose()),n.isBatchInput?a:a[0]})()}getClassifierChannelsOut(){return 136}},yYe=class extends Dl{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return V(()=>{let a=x2(Lv(de(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return a=x2(a,t.dense1),a=x2(a,t.dense2),a=ao(a,[14,14],[2,2],"valid"),a})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function mYe(e){let t=[],{extractDenseBlock3Params:n}=_Y(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Al(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function gYe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ml(e),{extractDenseBlock3Params:a}=IY(n,t),i=a(3,32,"dense0",!0),s=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:s,dense2:o}}}(e)}};function D2(e,t,n,r,a="same"){let{filters:i,bias:s}=t.conv,o=Lr(e,i,n,a);return o=J(o,s),o=function bYe(e,t){return J(z(e,t.weights),t.biases)}(o,t.scale),r?Rt(o):o}function FY(e,t){return D2(e,t,[1,1],!1)}function OY(e,t){return D2(e,t,[2,2],!0,"valid")}function xYe(e,t){function i(o,l,u,c){let h=function r(o,l,u,c){let h=function n(o,l,u){let c=e(o),h=c.length/(l*u*u);if(tY(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return V(()=>tt(ll(c,[l,h,u,u]),[2,3,1,0]))}(o,l,u),d=Tt(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:h,bias:d}}(o,l,u,`${c}/conv`),d=function a(o,l){let u=Tt(e(o)),c=Tt(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}(l,`${c}/scale`);return{conv:h,scale:d}}return{extractConvLayerParams:i,extractResidualLayerParams:function s(o,l,u,c,h=!1){return{conv1:i((h?.5:1)*o,l,u,`${c}/conv1`),conv2:i(o,l,u,`${c}/conv2`)}}}}function Ms(e,t){let n=function wYe(e,t){return D2(e,t,[1,1],!0)}(e,t.conv1);return n=FY(n,t.conv2),n=J(n,e),n=Rt(n),n}function v1(e,t){let n=OY(e,t.conv1);n=FY(n,t.conv2);let r=ao(e,2,2,"valid"),a=mn(r.shape),i=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let s=[...n.shape];s[1]=1;let o=mn(s);n=zt([n,o],1);let l=[...n.shape];l[2]=1;let u=mn(l);n=zt([n,u],2)}return r=i?zt([r,a],3):r,n=J(r,n),n=Rt(n),n}function Rs(e,t,n){return V(()=>{let r=Lr(e,t.filters,n,"same");return r=J(r,t.batch_norm_offset),Sr(r,0,6)})}function RYe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),i=Math.min(r[t][1],r[t][3]),s=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),h=Math.max(r[n][1],r[n][3]),d=(s-a)*(o-i),p=(c-l)*(h-u);if(d<=0||p<=0)return 0;let f=Math.max(a,l),m=Math.max(i,u),g=Math.min(s,c),y=Math.min(o,h),v=Math.max(g-f,0)*Math.max(y-m,0);return v/(d+p-v)}function Jf(e,t){return V(()=>{let n=e.shape[0];return{boxPredictionEncoding:B(Vv(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:B(Vv(e,t.class_predictor),[n,-1,3])}})}var em=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},VYe=[new Wt(.738768,.874946),new Wt(2.42204,2.65704),new Wt(4.30971,7.04493),new Wt(10.246,4.59428),new Wt(12.6868,11.8741)],UYe=[new Wt(1.603231,2.094468),new Wt(6.041143,7.080126),new Wt(2.882459,3.518061),new Wt(4.266906,5.178857),new Wt(9.041765,10.66308)],WYe=[117.001,114.697,97.404],b1=e=>"number"==typeof e;function A2(e){return V(()=>{let t=z(e,ke(.10000000149011612));return J(Rt(ye(e,t)),t)})}function Rl(e,t){return V(()=>{let n=Wi(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Lr(n,t.conv.filters,[1,1],"valid"),n=ye(n,t.bn.sub),n=z(n,t.bn.truediv),n=J(n,t.conv.bias),A2(n)})}function Fl(e,t){return V(()=>{let n=Wi(e,[[0,0],[1,1],[1,1],[0,0]]);return n=_f(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=J(n,t.bias),A2(n)})}var w1=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!=0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},YYe=(()=>{let e=class AQ extends Dl{constructor(n){super("TinyYolov2"),function GYe(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!b1(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>"string"==typeof t))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>b1(t.x)&&b1(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(b1)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(n),this._config=n}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(n,r){let a=Rl(n,r.conv0);return a=rr(a,[2,2],[2,2],"same"),a=Rl(a,r.conv1),a=rr(a,[2,2],[2,2],"same"),a=Rl(a,r.conv2),a=rr(a,[2,2],[2,2],"same"),a=Rl(a,r.conv3),a=rr(a,[2,2],[2,2],"same"),a=Rl(a,r.conv4),a=rr(a,[2,2],[2,2],"same"),a=Rl(a,r.conv5),a=rr(a,[2,2],[1,1],"same"),a=Rl(a,r.conv6),a=Rl(a,r.conv7),Vv(a,r.conv8,"valid",!1)}runMobilenet(n,r){let a=this.config.isFirstLayerConv2d?A2(Vv(n,r.conv0,"valid",!1)):Fl(n,r.conv0);return a=rr(a,[2,2],[2,2],"same"),a=Fl(a,r.conv1),a=rr(a,[2,2],[2,2],"same"),a=Fl(a,r.conv2),a=rr(a,[2,2],[2,2],"same"),a=Fl(a,r.conv3),a=rr(a,[2,2],[2,2],"same"),a=Fl(a,r.conv4),a=rr(a,[2,2],[2,2],"same"),a=Fl(a,r.conv5),a=rr(a,[2,2],[1,1],"same"),a=r.conv6?Fl(a,r.conv6):a,a=r.conv7?Fl(a,r.conv7):a,Vv(a,r.conv8,"valid",!1)}forwardInput(n,r){let{params:a}=this;if(!a)throw new Error("TinyYolov2 - load model before inference");return V(()=>{let i=de(n.toBatchTensor(r,!1),"float32");return i=this.config.meanRgb?Lv(i,this.config.meanRgb):i,i=i.div(255),this.config.withSeparableConvs?this.runMobilenet(i,a):this.runTinyYolov2(i,a)})}forward(n,r){var a=this;return F(function*(){return a.forwardInput(yield jr(n),r)})()}detect(n,r={}){var a=this;return F(function*(){let{inputSize:i,scoreThreshold:s}=new w1(r),o=yield jr(n),l=yield a.forwardInput(o,i),u=V(()=>vn(l)[0].expandDims()),c={width:o.getInputWidth(0),height:o.getInputHeight(0)},h=yield a.extractBoxes(u,o.getReshapedInputDimensions(0),s);l.dispose(),u.dispose();let d=h.map(g=>g.box),p=h.map(g=>g.score),f=h.map(g=>g.classScore),m=h.map(g=>a.config.classes[g.label]);return function RZe(e,t,n,r=!0){let a=t.map((s,o)=>({score:s,boxIndex:o})).sort((s,o)=>s.score-o.score).map(s=>s.boxIndex),i=[];for(;a.length>0;){let s=a.pop();i.push(s);let o=a,l=[];for(let u=0;u<o.length;u++)l.push(AZe(e[s],e[o[u]],r));a=a.filter((u,c)=>l[c]<=n)}return i}(d.map(g=>g.rescale(i)),p,a.config.iouThreshold,!0).map(g=>new aY(p[g],f[g],m[g],d[g],c))})()}getDefaultModelName(){return""}extractParamsFromWeightMap(n){return function ZYe(e,t){let s,n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:i}=function XYe(e,t){let n=Ad(e,t);function a(o){return{filters:n(`${o}/filters`,4),bias:n(`${o}/bias`,1)}}return{extractConvParams:a,extractConvWithBatchNormParams:function i(o){let l=a(`${o}/conv`),u=function r(o){return{sub:n(`${o}/sub`,1),truediv:n(`${o}/truediv`,1)}}(`${o}/bn`);return{conv:l,bn:u}},extractSeparableConvParams:_2(n)}}(e,n);if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;s={conv0:t.isFirstLayerConv2d?r("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:o>7?i("conv6"):void 0,conv7:o>8?i("conv7"):void 0,conv8:r("conv8")}}else s={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return Al(e,n),{params:s,paramMappings:n}}(n,this.config)}extractParams(n){let r=this.config.filterSizes||AQ.DEFAULT_FILTER_SIZES,a=r?r.length:void 0;if(7!==a&&8!==a&&9!==a)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return function KYe(e,t,n,r){let c,{extractWeights:a,getRemainingWeights:i}=Ml(e),s=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=function qYe(e,t){let n=I2(e,t),i=S2(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function a(s,o,l){let u=n(s,o,3,`${l}/conv`),c=function r(s,o){let l=Tt(e(s)),u=Tt(e(s));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}(o,`${l}/bn`);return{conv:u,bn:c}},extractSeparableConvParams:i}}(a,s);if(t.withSeparableConvs){let[h,d,p,f,m,g,y,v,b]=r;c={conv0:t.isFirstLayerConv2d?o(h,d,3,"conv0"):u(h,d,"conv0"),conv1:u(d,p,"conv1"),conv2:u(p,f,"conv2"),conv3:u(f,m,"conv3"),conv4:u(m,g,"conv4"),conv5:u(g,y,"conv5"),conv6:v?u(y,v,"conv6"):void 0,conv7:b?u(v,b,"conv7"):void 0,conv8:o(b||v||y,5*n,1,"conv8")}}else{let[h,d,p,f,m,g,y,v,b]=r;c={conv0:l(h,d,"conv0"),conv1:l(d,p,"conv1"),conv2:l(p,f,"conv2"),conv3:l(f,m,"conv3"),conv4:l(m,g,"conv4"),conv5:l(g,y,"conv5"),conv6:l(y,v,"conv6"),conv7:l(v,b,"conv7"),conv8:o(b,5*n,1,"conv8")}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:c,paramMappings:s}}(n,this.config,this.boxEncodingSize,r)}extractBoxes(n,r,a){var i=this;return F(function*(){let{width:s,height:o}=r,l=Math.max(s,o),u=l/s,c=l/o,h=n.shape[1],d=i.config.anchors.length,[p,f,m]=V(()=>{let b=n.reshape([h,h,d,i.boxEncodingSize]);return[b.slice([0,0,0,0],[h,h,d,4]),b.slice([0,0,0,4],[h,h,d,1]),i.withClassScores?sl(b.slice([0,0,0,5],[h,h,d,i.config.classes.length]),3):ke(0)]}),g=[],y=yield f.array(),v=yield p.array();for(let b=0;b<h;b++)for(let w=0;w<h;w++)for(let x=0;x<d;x++){let C=t2(y[b][w][x][0]);if(!a||C>a){let k=(w+t2(v[b][w][x][0]))/h*u,T=(b+t2(v[b][w][x][1]))/h*c,A=Math.exp(v[b][w][x][2])*i.config.anchors[x].x/h*u,R=Math.exp(v[b][w][x][3])*i.config.anchors[x].y/h*c,M=k-A/2,_=T-R/2,$={row:b,col:w,anchor:x},{classScore:U,label:j}=i.withClassScores?yield i.extractPredictedClass(m,$):{classScore:1,label:0};g.push({box:new rY(M,_,M+A,_+R),score:C,classScore:C*U,label:j,...$})}}return p.dispose(),f.dispose(),m.dispose(),g})()}extractPredictedClass(n,r){var a=this;return F(function*(){let{row:i,col:s,anchor:o}=r,l=yield n.array();return Array(a.config.classes.length).fill(0).map((u,c)=>l[i][s][o][c]).map((u,c)=>({classScore:u,label:c})).reduce((u,c)=>u.classScore>c.classScore?u:c)})()}};return e.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024],e})(),VY=YYe,WY=class extends w1{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Uv=class{then(e){var t=this;return F(function*(){return e(yield t.run())})()}run(){return F(function*(){throw new Error("ComposableTask - run is not implemented")})()}};function x1(e,t,n,r){return M2.apply(this,arguments)}function M2(){return M2=F(function*(e,t,n,r,a=(({alignedRect:i})=>i)){let i=e.map(l=>k2(l)?a(l):l.detection),s=r||(t instanceof Ze?yield p2(t,i):yield d2(t,i)),o=yield n(s);return s.forEach(l=>l instanceof Ze&&l.dispose()),o}),M2.apply(this,arguments)}var JYe=[new Wt(1.603231,2.094468),new Wt(6.041143,7.080126),new Wt(2.882459,3.518061),new Wt(4.266906,5.178857),new Wt(9.041765,10.66308)],eQe=[117.001,114.697,97.404],Dt={ssdMobilenetv1:new class extends Dl{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return V(()=>{let n=de(e.toBatchTensor(512,!1),"float32"),a=function MYe(e,t){return V(()=>{let n,r=Rs(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,i)=>{let s=i+1,o=function AYe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}(s);r=function DYe(e,t,n){return V(()=>{let r=ed(e,t.filters,n,"same");return r=Qc(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,.0010000000474974513),Sr(r,0,6)})}(r,a.depthwise_conv,o),r=Rs(r,a.pointwise_conv,[1,1]),11===s&&(n=r)}),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}(ye(ve(n,127.5),1),t.mobilenetv1),{boxPredictions:i,classPredictions:s}=function LYe(e,t,n){return V(()=>{let r=Rs(e,n.conv_0,[1,1]),a=Rs(r,n.conv_1,[2,2]),i=Rs(a,n.conv_2,[1,1]),s=Rs(i,n.conv_3,[2,2]),o=Rs(s,n.conv_4,[1,1]),l=Rs(o,n.conv_5,[2,2]),u=Rs(l,n.conv_6,[1,1]),c=Rs(u,n.conv_7,[2,2]),h=Jf(t,n.box_predictor_0),d=Jf(e,n.box_predictor_1),p=Jf(a,n.box_predictor_2),f=Jf(s,n.box_predictor_3),m=Jf(l,n.box_predictor_4),g=Jf(c,n.box_predictor_5);return{boxPredictions:zt([h.boxPredictionEncoding,d.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:zt([h.classPrediction,d.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}})}(a.out,a.conv11,t.prediction_layer);return function PYe(e,t,n){return V(()=>{let r=e.shape[0],a=function $Ye(e,t){let{sizes:n,centers:r}=function OYe(e){let t=vn(tt(e,[1,0])),n=[ye(t[2],t[0]),ye(t[3],t[1])];return{sizes:n,centers:[J(t[0],ve(n[0],2)),J(t[1],ve(n[1],2))]}}(e),a=vn(tt(t,[1,0])),i=ve(z(_r(ve(a[2],5)),n[0]),2),s=J(z(ve(a[0],10),n[0]),r[0]),o=ve(z(_r(ve(a[3],5)),n[1]),2),l=J(z(ve(a[1],10),n[1]),r[1]);return tt(Tn([ye(s,i),ye(l,o),J(s,i),J(l,o)]),[1,0])}(B(Ea(n.extra_dim,[r,1,1]),[-1,4]),B(e,[-1,4]));a=B(a,[r,a.shape[0]/r,4]);let i=mi(ct(t,[0,0,1],[-1,-1,-1])),s=ct(i,[0,0,0],[-1,-1,1]);return s=B(s,[r,s.shape[1]]),{boxes:vn(a),scores:vn(s)}})}(i,s,t.output_layer)})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}locateFaces(e,t={}){var n=this;return F(function*(){let{maxResults:r,minConfidence:a}=new em(t),i=yield jr(e),{boxes:s,scores:o}=n.forwardInput(i),l=s[0],u=o[0];for(let v=1;v<s.length;v++)s[v].dispose(),o[v].dispose();let c=Array.from(u.dataSync()),h=function FYe(e,t,n,r,a){let s=Math.min(n,e.shape[0]),o=t.map((c,h)=>({score:c,boxIndex:h})).filter(c=>c.score>a).sort((c,h)=>h.score-c.score),l=c=>c<=r?1:0,u=[];return o.forEach(c=>{if(u.length>=s)return;let h=c.score;for(let d=u.length-1;d>=0;--d){let p=RYe(e,c.boxIndex,u[d]);if(0!==p&&(c.score*=l(p),c.score<=a))break}h===c.score&&u.push(c.boxIndex)}),u}(l,c,r,.5,a),d=i.getReshapedInputDimensions(0),p=i.inputSize,f=p/d.width,m=p/d.height,g=l.arraySync(),y=h.map(v=>{let[b,w]=[Math.max(0,g[v][0]),Math.min(1,g[v][2])].map(k=>k*m),[x,C]=[Math.max(0,g[v][1]),Math.min(1,g[v][3])].map(k=>k*f);return new Ii(c[v],new iY(x,b,C-x,w-b),{height:i.getInputHeight(0),width:i.getInputWidth(0)})});return l.dispose(),u.dispose(),y})()}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return function NYe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function kYe(e,t){let n=Ad(e,t);function r(u,c,h){return{filters:n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${h}/filters`),batch_norm_offset:n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`)}}function a(u){let c=`mobilenetv1/conv_${u}`,h=`MobilenetV1/Conv2d_${u}_depthwise`,d=`${c}/depthwise_conv`,p=`${c}/pointwise_conv`;return{depthwise_conv:{filters:n(`${h}/depthwise_weights`,4,`${d}/filters`),batch_norm_scale:n(`${h}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),batch_norm_offset:n(`${h}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),batch_norm_mean:n(`${h}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),batch_norm_variance:n(`${h}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",u,p)}}function s(u,c){return{filters:n(`${u}/weights`,4,`${c}/filters`),bias:n(`${u}/biases`,1,`${c}/bias`)}}function o(u){return{box_encoding_predictor:s(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),class_predictor:s(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`)}}return{extractMobilenetV1Params:function i(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Pv(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let i={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Al(e,t),{params:i,paramMappings:t}}(e)}extractParams(e){return function EYe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ml(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:i}=function CYe(e,t){function r(l,u,c,h,d){let p=ll(e(l*u*c*c),[c,c,l,u]),f=Tt(e(u));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${d?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function a(l,u,c,h){let{filters:d,bias:p}=r(l,u,c,h,!0);return{filters:d,batch_norm_offset:p}}function i(l,u,c){let h=function n(l,u){let c=ll(e(9*l),[3,3,l,1]),h=Tt(e(l)),d=Tt(e(l)),p=Tt(e(l)),f=Tt(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:h,batch_norm_offset:d,batch_norm_mean:p,batch_norm_variance:f}}(l,`${c}/depthwise_conv`);return{depthwise_conv:h,pointwise_conv:a(l,u,1,`${c}/pointwise_conv`)}}return{extractMobilenetV1Params:function s(){return{conv_0:a(3,32,3,"mobilenetv1/conv_0"),conv_1:i(32,64,"mobilenetv1/conv_1"),conv_2:i(64,128,"mobilenetv1/conv_2"),conv_3:i(128,128,"mobilenetv1/conv_3"),conv_4:i(128,256,"mobilenetv1/conv_4"),conv_5:i(256,256,"mobilenetv1/conv_5"),conv_6:i(256,512,"mobilenetv1/conv_6"),conv_7:i(512,512,"mobilenetv1/conv_7"),conv_8:i(512,512,"mobilenetv1/conv_8"),conv_9:i(512,512,"mobilenetv1/conv_9"),conv_10:i(512,512,"mobilenetv1/conv_10"),conv_11:i(512,512,"mobilenetv1/conv_11"),conv_12:i(512,1024,"mobilenetv1/conv_12"),conv_13:i(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function o(){return{conv_0:a(1024,256,1,"prediction_layer/conv_0"),conv_1:a(256,512,3,"prediction_layer/conv_1"),conv_2:a(512,128,1,"prediction_layer/conv_2"),conv_3:a(128,256,3,"prediction_layer/conv_3"),conv_4:a(256,128,1,"prediction_layer/conv_4"),conv_5:a(128,256,3,"prediction_layer/conv_5"),conv_6:a(256,64,1,"prediction_layer/conv_6"),conv_7:a(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:r(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:r(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:r(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:r(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:r(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}(n,t),s=a(),o=i(),l={extra_dim:Z0(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:s,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}},tinyFaceDetector:new class extends VY{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:JYe,meanRgb:eQe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}locateFaces(e,t){var n=this;return F(function*(){return(yield n.detect(e,t)).map(r=>new Ii(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))})()}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},tinyYolov2:new class extends VY{constructor(e=!0){super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:UYe,meanRgb:WYe}:{anchors:VYe,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}locateFaces(e,t){var n=this;return F(function*(){return(yield n.detect(e,t)).map(r=>new Ii(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))})()}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},faceLandmark68Net:new class extends RY{constructor(e=new CY){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}},faceLandmark68TinyNet:new class extends RY{constructor(e=new yYe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new class extends Dl{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return V(()=>{let a=OY(Lv(de(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);a=rr(a,3,2,"valid"),a=Ms(a,t.conv32_1),a=Ms(a,t.conv32_2),a=Ms(a,t.conv32_3),a=v1(a,t.conv64_down),a=Ms(a,t.conv64_1),a=Ms(a,t.conv64_2),a=Ms(a,t.conv64_3),a=v1(a,t.conv128_down),a=Ms(a,t.conv128_1),a=Ms(a,t.conv128_2),a=v1(a,t.conv256_down),a=Ms(a,t.conv256_1),a=Ms(a,t.conv256_2),a=v1(a,t.conv256_down_out);let i=a.mean([1,2]);return et(i,t.fc)})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}computeFaceDescriptor(e){var t=this;return F(function*(){var n;if(null!=(n=e?.shape)&&n.some(s=>s<=0))return new Float32Array(128);let r=yield jr(e),a=V(()=>vn(t.forwardInput(r))),i=yield Promise.all(a.map(s=>s.data()));return a.forEach(s=>s.dispose()),r.isBatchInput?i:i[0]})()}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function _Ye(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=function SYe(e,t){let n=Ad(e,t);function a(s){let o=n(`${s}/conv/filters`,4),l=n(`${s}/conv/bias`,1),u=function r(s){return{weights:n(`${s}/scale/weights`,1),biases:n(`${s}/scale/biases`,1)}}(s);return{conv:{filters:o,bias:l},scale:u}}return{extractConvLayerParams:a,extractResidualLayerParams:function i(s){return{conv1:a(`${s}/conv1`),conv2:a(`${s}/conv2`)}}}}(e,t),a=n("conv32_down"),i=r("conv32_1"),s=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),h=r("conv64_3"),d=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),v=r("conv256_down_out"),{fc:b}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!eY(b))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${b}`);let w={conv32_down:a,conv32_1:i,conv32_2:s,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:h,conv128_down:d,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:v,fc:b};return Al(e,t),{params:w,paramMappings:t}}(e)}extractParams(e){return function IYe(e){let{extractWeights:t,getRemainingWeights:n}=Ml(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:i}=xYe(t,r),s=a(4704,32,7,"conv32_down"),o=i(9216,32,3,"conv32_1"),l=i(9216,32,3,"conv32_2"),u=i(9216,32,3,"conv32_3"),c=i(36864,64,3,"conv64_down",!0),h=i(36864,64,3,"conv64_1"),d=i(36864,64,3,"conv64_2"),p=i(36864,64,3,"conv64_3"),f=i(147456,128,3,"conv128_down",!0),m=i(147456,128,3,"conv128_1"),g=i(147456,128,3,"conv128_2"),y=i(589824,256,3,"conv256_down",!0),v=i(589824,256,3,"conv256_1"),b=i(589824,256,3,"conv256_2"),w=i(589824,256,3,"conv256_down_out"),x=V(()=>tt(Is(t(32768),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:s,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:h,conv64_2:d,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:v,conv256_2:b,conv256_down_out:w,fc:x},paramMappings:r}}(e)}},faceExpressionNet:new class extends kY{constructor(e=new CY){super("FaceExpressionNet",e)}forwardInput(e){return V(()=>sl(this.runNet(e)))}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}predictExpressions(e){var t=this;return F(function*(){let n=yield jr(e),r=yield t.forwardInput(n),a=yield Promise.all(vn(r).map(function(){var s=F(function*(o){let l=o.dataSync();return o.dispose(),l});return function(o){return s.apply(this,arguments)}}()));r.dispose();let i=a.map(s=>new E2(s));return n.isBatchInput?i:i[0]})()}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends Dl{constructor(e=new uYe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return V(()=>{let n=e instanceof m1?this.faceFeatureExtractor.forwardInput(e):e,r=ao(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:C2(r,t.fc.age).as1D(),gender:C2(r,t.fc.gender)}})}forwardInput(e){return V(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:sl(n)}})}forward(e){var t=this;return F(function*(){return t.forwardInput(yield jr(e))})()}predictAgeAndGender(e){var t=this;return F(function*(){let n=yield jr(e),r=yield t.forwardInput(n),a=vn(r.age),i=vn(r.gender),s=a.map((l,u)=>({ageTensor:l,genderTensor:i[u]})),o=yield Promise.all(s.map(function(){var l=F(function*({ageTensor:u,genderTensor:c}){let h=u.dataSync()[0],d=c.dataSync()[0],p=d>.5,f=p?"male":"female",m=p?d:1-d;return u.dispose(),c.dispose(),{age:h,gender:f,genderProbability:m}});return function(u){return l.apply(this,arguments)}}()));return r.age.dispose(),r.gender.dispose(),n.isBatchInput?o:o[0]})()}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function cYe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ml(e),a=wY(n,t),i=a(512,1,"fc/age"),s=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:i,gender:s}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=EY(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function dYe(e){let t=[],n=Ad(e,t);function r(i){return{weights:n(`${i}/weights`,2),bias:n(`${i}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Al(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},tQe=class extends Uv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},O2=class extends tQe{run(){var e=this;return F(function*(){let t=yield e.parentTask,n=yield x1(t,e.input,function(){var r=F(function*(a){return Promise.all(a.map(i=>Dt.faceExpressionNet.predictExpressions(i)))});return function(a){return r.apply(this,arguments)}}(),e.extractedFaces);return t.map((r,a)=>function TY(e,t){return{...e,expressions:t}}(r,n[a]))})()}withAgeAndGender(){return new L2(this,this.input)}},$2=class extends O2{withAgeAndGender(){return new z2(this,this.input)}withFaceDescriptors(){return new V2(this,this.input)}},nQe=class extends Uv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},L2=class extends nQe{run(){var e=this;return F(function*(){let t=yield e.parentTask,n=yield x1(t,e.input,function(){var r=F(function*(a){return Promise.all(a.map(i=>Dt.ageGenderNet.predictAgeAndGender(i)))});return function(a){return r.apply(this,arguments)}}(),e.extractedFaces);return t.map((r,a)=>{let{age:i,gender:s,genderProbability:o}=n[a];return function LY(e,t){return{...e,age:t}}(function zY(e,t,n){return{...e,gender:t,genderProbability:n}}(r,s,o),i)})})()}withFaceExpressions(){return new O2(this,this.input)}},z2=class extends L2{withFaceExpressions(){return new $2(this,this.input)}withFaceDescriptors(){return new V2(this,this.input)}},rQe=class extends Uv{constructor(e,t){super(),this.parentTask=e,this.input=t}},V2=class extends rQe{run(){var e=this;return F(function*(){let t=yield e.parentTask;return(yield x1(t,e.input,n=>Promise.all(n.map(r=>Dt.faceRecognitionNet.computeFaceDescriptor(r))),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}))).map((n,r)=>function PY(e,t){return{...e,descriptor:t}}(t[r],n))})()}withFaceExpressions(){return new $2(this,this.input)}withAgeAndGender(){return new z2(this,this.input)}},aQe=class extends Uv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Dt.faceLandmark68TinyNet:Dt.faceLandmark68Net}},iQe=class extends aQe{run(){var e=this;return F(function*(){let t=yield e.parentTask,n=t.map(i=>i.detection),r=e.input instanceof Ze?yield p2(e.input,n):yield d2(e.input,n),a=yield Promise.all(r.map(i=>e.landmarkNet.detectLandmarks(i)));return r.forEach(i=>i instanceof Ze&&i.dispose()),t.filter((i,s)=>a[s]).map((i,s)=>N2(i,a[s]))})()}withFaceExpressions(){return new $2(this,this.input)}withAgeAndGender(){return new z2(this,this.input)}withFaceDescriptors(){return new V2(this,this.input)}},oQe=class extends Uv{constructor(e,t=new em){super(),this.input=e,this.options=t}},qY=class extends oQe{run(){var e=this;return F(function*(){let r,{input:t,options:n}=e;if(n instanceof WY)r=Dt.tinyFaceDetector.locateFaces(t,n);else if(n instanceof em)r=Dt.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof w1))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");r=Dt.tinyYolov2.locateFaces(t,n)}return r})()}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>p1({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new iQe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new O2(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new L2(this.runAndExtendWithFaceDetections(),this.input)}};function KY(e,t){let{width:n,height:r}=new Dd(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(a=>KY(a,{width:n,height:r}));if(k2(e)){let a=e.detection.forSize(n,r),i=e.unshiftedLandmarks.forSize(a.box.width,a.box.height);return N2(p1(e,a),i)}return Bv(e)?p1(e,e.detection.forSize(n,r)):e instanceof zv||e instanceof Ii?e.forSize(n,r):e}const cQe=["videoElement"],dQe=["canvas"],hQe=e=>({"bg-off":e});function pQe(e,t){1&e&&(Ar(0,"div",10),l_(),Ar(1,"svg",11),Oi(2,"path",12),Mr()())}(function ffe(e,t){return xde({rootComponent:e,...f4(t)})})(Zye,{providers:[function Fye(e,...t){return function xm(e){return{\u0275providers:e}}([{provide:Qh,multi:!0,useValue:e},[],{provide:qh,useFactory:Rj,deps:[ms]},{provide:Eg,multi:!0,useFactory:Fj},t.map(n=>n.\u0275providers)])}([{path:"",redirectTo:"/webcam-detection",pathMatch:"full"},{path:"webcam-detection",component:(()=>{class e{videoElement;canvas;intervalId;isWebcamActive=!1;ngAfterViewInit(){return F(function*(){console.log("Component initialized - Models will load when the webcam starts.")})()}ngOnDestroy(){this.stopCamera()}loadModels(){return F(function*(){const n="/assets/models";try{yield Promise.all([Dt.tinyFaceDetector.loadFromUri(n),Dt.faceLandmark68Net.loadFromUri(n),Dt.faceExpressionNet.loadFromUri(n),Dt.ageGenderNet.loadFromUri(n)]),console.log("Models loaded successfully")}catch(r){console.error("Failed to load models:",r)}})()}toggleWebcam(n){n.target.checked?this.startCamera():this.stopCamera()}startCamera(){var n=this;return F(function*(){yield n.loadModels(),navigator.mediaDevices.getUserMedia({video:!0}).then(r=>{n.videoElement.nativeElement.srcObject=r,n.videoElement.nativeElement.play().then(()=>{n.startFaceDetection(),n.isWebcamActive=!0})}).catch(r=>{console.error("Error accessing the camera:",r),n.isWebcamActive=!1})})()}stopCamera(){if(this.videoElement.nativeElement.srcObject&&(this.videoElement.nativeElement.srcObject.getTracks().forEach(r=>r.stop()),this.videoElement.nativeElement.srcObject=null,this.isWebcamActive=!1),this.intervalId){clearInterval(this.intervalId);const n=this.canvas.nativeElement.getContext("2d");n&&n.clearRect(0,0,this.canvas.nativeElement.width,this.canvas.nativeElement.height)}console.log("Webcam stopped")}startFaceDetection(){const n=this.videoElement.nativeElement,r=this.canvas.nativeElement;r.width=n.videoWidth,r.height=n.videoHeight;const a={width:n.videoWidth,height:n.videoHeight};(function KZe(e,t,n=!1){let{width:r,height:a}=n?l2(t):t;e.width=r,e.height=a})(r,a),this.intervalId=window.setInterval(F(function*(){const s=KY(yield function W2(e,t=new em){return new qY(e,t)}(n,new WY).withFaceLandmarks().withFaceExpressions().withAgeAndGender(),a),o=r.getContext("2d");o&&(o.clearRect(0,0,r.width,r.height),$v.drawDetections(r,s),$v.drawFaceLandmarks(r,s),$v.drawFaceExpressions(r,s),s.forEach(l=>{const{age:u,gender:c,genderProbability:h}=l,d=`${Math.round(u)} years old ${c} (${Math.round(100*h)}%)`;new $v.DrawTextField([d],l.detection.box.bottomRight).draw(r)}))}),100)}static \u0275fac=function(r){return new(r||e)};static \u0275cmp=jd({type:e,selectors:[["app-facial-recognition"]],viewQuery:function(r,a){if(1&r&&(gE(cQe,7),gE(dQe,7)),2&r){let i;Ww(i=jw())&&(a.videoElement=i.first),Ww(i=jw())&&(a.canvas=i.first)}},standalone:!0,features:[Oh],decls:10,vars:4,consts:[["videoElement",""],["canvas",""],[1,"content"],[1,"video-container",3,"ngClass"],["class","placeholder-icon",4,"ngIf"],["width","720","height","560",2,"position","absolute","top","0","left","0"],[2,"position","absolute","top","0","left","0","z-index","10"],[1,"toggle-switch"],["type","checkbox",3,"change"],[1,"toggle-switch-slider"],[1,"placeholder-icon"],["xmlns","http://www.w3.org/2000/svg","width","100","height","100","fill","#909090","viewBox","0 0 16 16",1,"bi","bi-camera-video-off"],["fill-rule","evenodd","d","M10.961 12.365a2 2 0 0 0 .522-1.103l3.11 1.382A1 1 0 0 0 16 11.731V4.269a1 1 0 0 0-1.406-.913l-3.111 1.382A2 2 0 0 0 9.5 3H4.272l.714 1H9.5a1 1 0 0 1 1 1v6a1 1 0 0 1-.144.518zM1.428 4.18A1 1 0 0 0 1 5v6a1 1 0 0 0 1 1h5.014l.714 1H2 a2 2 0 0 1-2-2V5c0-.675.334-1.272.847-1.634zM15 11.73l-3.5-1.555v-4.35L15 4.269zm-4.407 3.56-10-14 .814-.58 10 14z"]],template:function(r,a){if(1&r){const i=function KB(){return ne()}();Ar(0,"div",2)(1,"div",3),jC(2,pQe,3,0,"div",4),Oi(3,"video",5,0)(5,"canvas",6,1),Mr(),Ar(7,"label",7)(8,"input",8),Uw("change",function(o){return function uP(e){return Ve.lFrame.contextLView=e,e[en]}(i),function cP(e){return Ve.lFrame.contextLView=null,e}(a.toggleWebcam(o))}),Mr(),Oi(9,"span",9),Mr()()}2&r&&(rC(),$w("ngClass",iU(2,hQe,!a.isWebcamActive)),rC(),$w("ngIf",!a.isWebcamActive))},dependencies:[mpe,UW,HW],styles:['html[_ngcontent-%COMP%], body[_ngcontent-%COMP%]{height:100%;margin:0;padding:0;display:flex;align-items:center;justify-content:center;background-color:#e0e0e0}.content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center}.video-container[_ngcontent-%COMP%]{position:relative;width:720px;height:560px;margin-top:20px}video[_ngcontent-%COMP%], canvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}canvas[_ngcontent-%COMP%]{z-index:10}.toggle-switch[_ngcontent-%COMP%]{margin-top:20px;position:relative;width:60px;height:34px;display:flex;align-items:center}.toggle-switch[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:0;width:0;height:0}.toggle-switch-slider[_ngcontent-%COMP%]{position:absolute;cursor:pointer;inset:0;background-color:#ccc;transition:.4s;border-radius:34px}.placeholder-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:flex;align-items:center;justify-content:center;width:100%;height:100%}.toggle-switch-slider[_ngcontent-%COMP%]:before{position:absolute;content:"";height:26px;width:26px;left:4px;bottom:4px;background-color:#fff;transition:.4s;border-radius:50%}.bg-off[_ngcontent-%COMP%]{background-color:#e0e0e0}input[_ngcontent-%COMP%]:checked + .toggle-switch-slider[_ngcontent-%COMP%]{background-color:#0ab231}input[_ngcontent-%COMP%]:checked + .toggle-switch-slider[_ngcontent-%COMP%]:before{transform:translate(26px)}']})}return e})(),data:{title:"Webcam Detection"}},{path:"image-detection",component:(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275cmp=jd({type:e,selectors:[["app-image-detection"]],standalone:!0,features:[Oh],decls:3,vars:0,consts:[[1,"coming-soon"]],template:function(r,a){1&r&&(Ar(0,"div",0)(1,"h1"),Fh(2,"Coming Soon!"),Mr()())},styles:[".coming-soon[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:100vh;font-size:2rem;color:#333}"]})}return e})(),data:{title:"Image Detection"}}])]}).catch(e=>console.error(e))},291:cm=>{function Io(So){var dm=new Error("Cannot find module '"+So+"'");throw dm.code="MODULE_NOT_FOUND",dm}Io.keys=()=>[],Io.resolve=Io,Io.id=291,cm.exports=Io}},cm=>{cm(cm.s=563)}]);